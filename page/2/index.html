<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":250,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":false,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="摸鱼窝">
<meta property="og:type" content="website">
<meta property="og:title" content="岛屿尽">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="岛屿尽">
<meta property="og:description" content="摸鱼窝">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="dyinjin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<link rel="stylesheet" type="text/css" href="/css/injector/main.css" /><link rel="preload" as="style" href="/css/injector/light.css" /><link rel="preload" as="style" href="/css/injector/dark.css" />
  <title>岛屿尽</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">岛屿尽</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">dyingjin</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-cube fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-bookmark fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-cubes fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-server fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/20/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE/%E5%8C%BA%E5%9D%97%E9%93%BENFT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/20/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE/%E5%8C%BA%E5%9D%97%E9%93%BENFT/" class="post-title-link" itemprop="url">区块链NFT</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-20 19:16:52" itemprop="dateCreated datePublished" datetime="2022-03-20T19:16:52+08:00">2022-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-20 14:53:01" itemprop="dateModified" datetime="2022-04-20T14:53:01+08:00">2022-04-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ERC721"><a href="#ERC721" class="headerlink" title="ERC721"></a>ERC721</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/41437f66afa8">《什么是ERC-721 代币？》</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/393935101">《智能合约NFT之ERC721代币详解》</a></p>
<p>本质上说就是定义的函数接口标准</p>
<h2 id="ERC721标准"><a href="#ERC721标准" class="headerlink" title="ERC721标准"></a>ERC721标准</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.20;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface ERC721 &#123;</span><br><span class="line">    /// @dev 当任何NFT的所有权更改时（不管哪种方式），就会触发此事件。</span><br><span class="line">    ///  包括在创建时（`from` == 0）和销毁时(`to` == 0), 合约创建时除外。</span><br><span class="line">    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);</span><br><span class="line"></span><br><span class="line">    /// @dev 当更改或确认NFT的授权地址时触发。</span><br><span class="line">    ///  零地址表示没有授权的地址。</span><br><span class="line">    ///  发生 `Transfer` 事件时，同样表示该NFT的授权地址（如果有）被重置为“无”（零地址）。</span><br><span class="line">    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);</span><br><span class="line"></span><br><span class="line">    /// @dev 所有者启用或禁用操作员时触发。（操作员可管理所有者所持有的NFTs）</span><br><span class="line">    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);</span><br><span class="line"></span><br><span class="line">    /// @notice 统计所持有的NFTs数量</span><br><span class="line">    /// @dev NFT 不能分配给零地址，查询零地址同样会异常</span><br><span class="line">    /// @param _owner ： 待查地址</span><br><span class="line">    /// @return 返回数量，也许是0</span><br><span class="line">    function balanceOf(address _owner) external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    /// @notice 返回所有者</span><br><span class="line">    /// @dev NFT 不能分配给零地址，查询零地址抛出异常</span><br><span class="line">    /// @param _tokenId NFT 的id</span><br><span class="line">    /// @return 返回所有者地址</span><br><span class="line">    function ownerOf(uint256 _tokenId) external view returns (address);</span><br><span class="line"></span><br><span class="line">    /// @notice 将NFT的所有权从一个地址转移到另一个地址</span><br><span class="line">    /// @dev 如果`msg.sender` 不是当前的所有者（或授权者）抛出异常</span><br><span class="line">    /// 如果 `_from` 不是所有者、`_to` 是零地址、`_tokenId` 不是有效id 均抛出异常。</span><br><span class="line">    ///  当转移完成时，函数检查  `_to` 是否是合约，如果是，调用 `_to`的 `onERC721Received` 并且检查返回值是否是 `0x150b7a02` (即：`bytes4(keccak256(&quot;onERC721Received(address,address,uint256,bytes)&quot;))`)  如果不是抛出异常。</span><br><span class="line">    /// @param _from ：当前的所有者</span><br><span class="line">    /// @param _to ：新的所有者</span><br><span class="line">    /// @param _tokenId ：要转移的token id.</span><br><span class="line">    /// @param data : 附加额外的参数（没有指定格式），传递给接收者。</span><br><span class="line">    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;</span><br><span class="line"></span><br><span class="line">    /// @notice 将NFT的所有权从一个地址转移到另一个地址，功能同上，不带data参数。</span><br><span class="line">    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;</span><br><span class="line"></span><br><span class="line">    /// @notice 转移所有权 -- 调用者负责确认`_to`是否有能力接收NFTs，否则可能永久丢失。</span><br><span class="line">    /// @dev 如果`msg.sender` 不是当前的所有者（或授权者、操作员）抛出异常</span><br><span class="line">    /// 如果 `_from` 不是所有者、`_to` 是零地址、`_tokenId` 不是有效id 均抛出异常。</span><br><span class="line">    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;</span><br><span class="line"></span><br><span class="line">    /// @notice 更改或确认NFT的授权地址</span><br><span class="line">    /// @dev 零地址表示没有授权的地址。</span><br><span class="line">    ///  如果`msg.sender` 不是当前的所有者或操作员</span><br><span class="line">    /// @param _approved 新授权的控制者</span><br><span class="line">    /// @param _tokenId ： token id</span><br><span class="line">    function approve(address _approved, uint256 _tokenId) external payable;</span><br><span class="line"></span><br><span class="line">    /// @notice 启用或禁用第三方（操作员）管理 `msg.sender` 所有资产</span><br><span class="line">    /// @dev 触发 ApprovalForAll 事件，合约必须允许每个所有者可以有多个操作员。</span><br><span class="line">    /// @param _operator 要添加到授权操作员列表中的地址</span><br><span class="line">    /// @param _approved True 表示授权, false 表示撤销</span><br><span class="line">    function setApprovalForAll(address _operator, bool _approved) external;</span><br><span class="line"></span><br><span class="line">    /// @notice 获取单个NFT的授权地址</span><br><span class="line">    /// @dev 如果 `_tokenId` 无效，抛出异常。</span><br><span class="line">    /// @param _tokenId ：  token id</span><br><span class="line">    /// @return 返回授权地址， 零地址表示没有。</span><br><span class="line">    function getApproved(uint256 _tokenId) external view returns (address);</span><br><span class="line"></span><br><span class="line">    /// @notice 查询一个地址是否是另一个地址的授权操作员</span><br><span class="line">    /// @param _owner 所有者</span><br><span class="line">    /// @param _operator 代表所有者的授权操作员</span><br><span class="line">    function isApprovedForAll(address _owner, address _operator) external view returns (bool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解析与实现"><a href="#解析与实现" class="headerlink" title="解析与实现"></a>解析与实现</h2><h3 id="Transfer-event"><a href="#Transfer-event" class="headerlink" title="Transfer event"></a>Transfer event</h3><p>当任何NFT的所有权更改时（不管哪种方式），就会触发此事件，即成立为交易（包括创建，转让，销毁）</p>
<h3 id="Approval-event"><a href="#Approval-event" class="headerlink" title="Approval event"></a>Approval event</h3><p>当更改或确认NFT的<strong>授权</strong>地址时触发。</p>
<h3 id="ApprovalForAll-event"><a href="#ApprovalForAll-event" class="headerlink" title="ApprovalForAll event"></a>ApprovalForAll event</h3><p>所有者启用或禁用<strong>授权</strong>第三方（操作员）管理时触发。</p>
<h3 id="balanceOf"><a href="#balanceOf" class="headerlink" title="balanceOf*"></a>balanceOf*</h3><p>查找owner的资产数量，参数_owner，返回数量</p>
<h3 id="ownerOf"><a href="#ownerOf" class="headerlink" title="ownerOf*"></a>ownerOf*</h3><p>查找资产对应所有者，参数资产tokenid，返回拥有者</p>
<h3 id="safeTransferFrom"><a href="#safeTransferFrom" class="headerlink" title="safeTransferFrom"></a>safeTransferFrom</h3><p>安全的资产所有权转移（修改owner），参数当前所有者、目的所有者、资产tokenid、任意备注（可不带）</p>
<h3 id="transferFrom"><a href="#transferFrom" class="headerlink" title="transferFrom*"></a>transferFrom*</h3><p>资产所有权转移，相比safeTransferFrom参数一致</p>
<h3 id="approve"><a href="#approve" class="headerlink" title="approve*"></a>approve*</h3><p>更改或确认NFT的授权地址，参数新授权人、资产tokenid</p>
<h3 id="setApprovalForAll"><a href="#setApprovalForAll" class="headerlink" title="setApprovalForAll"></a>setApprovalForAll</h3><p>所有者启用或禁用授权第三方（操作员）管理，参数要授权的的操作员、启用/禁用布尔值</p>
<h3 id="getApproved"><a href="#getApproved" class="headerlink" title="getApproved*"></a>getApproved*</h3><p>获取资产授权地址，参数资产tokenid，返回授权地址</p>
<h3 id="isApprovedForAll"><a href="#isApprovedForAll" class="headerlink" title="isApprovedForAll"></a>isApprovedForAll</h3><p>查询一个操作员是否是一个所有者的授权操作员，参数所有者、操作员</p>
<h1 id="链码分析"><a href="#链码分析" class="headerlink" title="链码分析"></a>链码分析</h1><p>资产本身的信息是一组需要区块链记录的结构体，还有每次进行交易时希望对交易信息进行记录则交易信息也设定为一结构体（特殊类型定义为string 设置为宏定义方便转换用）</p>

      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/11/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE/qkledu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/11/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE/qkledu/" class="post-title-link" itemprop="url">区块链简单成绩系统实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-11 17:37:54" itemprop="dateCreated datePublished" datetime="2022-03-11T17:37:54+08:00">2022-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-31 17:22:33" itemprop="dateModified" datetime="2022-03-31T17:22:33+08:00">2022-03-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39200980?type=blog">从0到1：Hyperledger Fabric开发精要【最系统】</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/lvyibin890?type=blog">hubwiz私人博客</a><br><a target="_blank" rel="noopener" href="http://blog.hubwiz.com/categories/Hyperledger-Fabric/">CSDN TLpigff博客</a><br><a target="_blank" rel="noopener" href="https://www.chaindesk.cn/witbook/11/217">CSDN 烟火不完美博客</a></p>
<p><code>github.com/hyperledger/fabric/core/chaincode/shim</code><br><code>github.com/hyperledger/fabric/protos/peer</code><br>改为<br><code>github.com/hyperledger/fabric-chaincode-go/shim</code><br><code>github.com/hyperledger/fabric-protos-go/peer</code></p>
<p>报错：<code>undefined:discovery.ChaincodeCall</code><br>go.mod中<br><code>github.com/hyperledger/fabric-protos-go v0.0.0-20211006172752-14f4318ce71c</code><br>改为<br><code>github.com/hyperledger/fabric-protos-go v0.0.0-20200707132912-fee30f3ccd23</code></p>
<h1 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h1><p>以目录为检索结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">│  config.yaml</span><br><span class="line">│  main.go//重点，执行入口</span><br><span class="line">│  </span><br><span class="line">├─chaincode</span><br><span class="line">│  │  edu.go//业务层重点</span><br><span class="line">│  │  go.mod</span><br><span class="line">│  │  go.sum</span><br><span class="line">│  └─vendor</span><br><span class="line">│</span><br><span class="line">├─fixtures</span><br><span class="line">│  │  configtx.yaml//网络层重点</span><br><span class="line">│  │  crypto-config.yaml//网络层重点</span><br><span class="line">│  │  docker-compose.yaml//网络层重点</span><br><span class="line">│  ├─channel-artifacts    </span><br><span class="line">│  └─crypto-config </span><br><span class="line">│</span><br><span class="line">├─sdkInit</span><br><span class="line">│      integration.go//重点</span><br><span class="line">│      sdkInfo.go//重点</span><br><span class="line">│      sdkSetting.go//重点</span><br><span class="line">│</span><br><span class="line">├─service</span><br><span class="line">│      domain.go//业务层重点</span><br><span class="line">│      eduService.go//业务层重点</span><br><span class="line">│</span><br><span class="line">└─web//常见go网页应用工程MVC模式</span><br><span class="line">    │  webServer.go//各种http.HandleFunc</span><br><span class="line">    ├─controller    </span><br><span class="line">    ├─static      </span><br><span class="line">    └─tpl</span><br></pre></td></tr></table></figure>

<h2 id="fixtures"><a href="#fixtures" class="headerlink" title="fixtures"></a>fixtures</h2><p>三种配置文件、根据配置文件生成的组织结构以及基础区块</p>
<h3 id="crypto-config-yaml"><a href="#crypto-config-yaml" class="headerlink" title="crypto-config.yaml"></a>crypto-config.yaml</h3><p>用于生成相关组织的私钥和证书<br>Fabric 中会有两种类型的公私钥和证书</p>
<ul>
<li>  给节点之间通讯安全而准备的TLS证书</li>
<li>  用户登录和权限控制的用户证书。</li>
</ul>
<p>配置参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/lvyibin890/article/details/106213960">crypto-config配置参考</a></p>
<h3 id="configtx-yaml"><a href="#configtx-yaml" class="headerlink" title="configtx.yaml"></a>configtx.yaml</h3><p>configtx.yaml主要用来配置fabric的组织结构，通道及锚节点的配置。它主要完成以下几个功能：</p>
<ul>
<li>生成启动 Orderer 需要的创世区块orderer.block(genesis.block)</li>
<li>创建应用通道所需的配置交易文件</li>
<li>生成组织锚节点更新配置交易文件</li>
</ul>
<p>配置参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/lvyibin890/article/details/106217716?spm=1001.2014.3001.5502">configtx配置参考</a><br>之后可以使用configtxgen进行生成操作</p>
<h3 id="docker-compose-yaml"><a href="#docker-compose-yaml" class="headerlink" title="docker-compose.yaml"></a>docker-compose.yaml</h3><p>用以配置fabric网络的相关容器<br>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。<br>fabric区块链中多使用docker来创建虚拟容器</p>
<h2 id="chaincode"><a href="#chaincode" class="headerlink" title="chaincode"></a>chaincode</h2><p>链码，合约，或者这里我们理解为接口API<br>是在可执行代码中定义不同组织之间业务规则的代码<br>是业务逻辑中需要的组织交互逻辑而不是全部业务逻辑</p>
<h2 id="sdkinit"><a href="#sdkinit" class="headerlink" title="sdkinit"></a>sdkinit</h2><p>这一块结合main.go主函数理解，主要用于初始化启动SDK</p>
<h2 id="按执行顺序"><a href="#按执行顺序" class="headerlink" title="按执行顺序"></a>按执行顺序</h2><p>.sh脚本内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo docker rm -f $(sudo docker ps -aq)</span><br><span class="line">sudo docker network prune</span><br><span class="line">sudo docker volume prune</span><br><span class="line">删除可能的网络与容器</span><br><span class="line">cd fixtures &amp;&amp; docker-compose up -d</span><br><span class="line">启动docker容器（按fixtures配置）</span><br><span class="line">cd ..</span><br><span class="line">sudo rm education</span><br><span class="line">go build</span><br><span class="line">编译主函数</span><br><span class="line">./education</span><br><span class="line">执行</span><br></pre></td></tr></table></figure>

<h3 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h3><p>sdkInit.Setup<br>包含</p>
<ul>
<li>fabsdk.New</li>
<li>sdk.Context</li>
</ul>
<p>主要工作：初始化SDK</p>
<h3 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h3><p>sdkInit.CreateAndJoinChannel<br>包含</p>
<ul>
<li>createChannel</li>
<li>org.OrgResMgmt.JoinChannel</li>
</ul>
<p>主要工作：创建通道并将组织加入通道</p>
<h3 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h3><p>sdkInit.CreateCCLifecycle<br>分为：</p>
<ul>
<li>打包智能合约</li>
<li>安装智能合约</li>
<li>“认可”智能合约(Approve)</li>
<li>智能合约初始化</li>
</ul>
<p>主要工作：智能合约上链与初始化</p>
<h3 id="第四步："><a href="#第四步：" class="headerlink" title="第四步："></a>第四步：</h3><p>service.InitService<br>包含</p>
<ul>
<li>sdk.ChannelContext</li>
<li>channel.New</li>
</ul>
<p>主要功能：创建通道客户端实例。<br>通道客户端用于查询链码，执行链码，注册/取消特定通道上的链码事件。</p>
<h3 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h3><p>serviceSetup.SaveEdu<br>进行交易实验（添加信息）<br><strong>可跳过</strong></p>
<h3 id="第六步"><a href="#第六步" class="headerlink" title="第六步"></a>第六步</h3><p>serviceSetup.FindEduInfoByEntityID<br>进行交易实验（查询信息）<br><strong>可跳过</strong></p>
<h3 id="第七步"><a href="#第七步" class="headerlink" title="第七步"></a>第七步</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(&quot;第七步&quot;)</span><br><span class="line">app := controller.Application&#123;</span><br><span class="line">	Setup: serviceSetup,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动服务</p>
<h3 id="第八步"><a href="#第八步" class="headerlink" title="第八步"></a>第八步</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(&quot;第八步&quot;)</span><br><span class="line">web.WebStart(app)</span><br></pre></td></tr></table></figure>
<p>建立服务网站</p>
<h3 id="怎么调用链码的"><a href="#怎么调用链码的" class="headerlink" title="怎么调用链码的"></a>怎么调用链码的</h3><p><code>req := channel.Request&#123;ChaincodeID: t.ChaincodeID, Fcn: &quot;addEdu&quot;, Args: [][]byte&#123;b, []byte(eventID)&#125;&#125;</code><br>用这种语句在GO中调用链码写入信息</p>
<h3 id="couchDB"><a href="#couchDB" class="headerlink" title="couchDB"></a>couchDB</h3><p>fabric支持的唯二数据库，是一个NoSQL文档存储数据库。<br>它使用JSON存储数据（文档），使用http协议为api访问文档，使用Web浏览器查询索引。</p>
<h3 id="问题：为什么老是运行的以前的链码？"><a href="#问题：为什么老是运行的以前的链码？" class="headerlink" title="问题：为什么老是运行的以前的链码？"></a>问题：为什么老是运行的以前的链码？</h3><p>太大意了！<br><img src="/2022/03/11/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE/qkledu/1647281435396.png"><br>已经将文件命名为5edu了，却没有改对应路径QAQ</p>

      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/08/%E7%BD%91%E7%BB%9C/SRWE1-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/08/%E7%BD%91%E7%BB%9C/SRWE1-4/" class="post-title-link" itemprop="url">SRWE 1-4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-08 21:12:38" itemprop="dateCreated datePublished" datetime="2022-03-08T21:12:38+08:00">2022-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-11 17:18:56" itemprop="dateModified" datetime="2022-03-11T17:18:56+08:00">2022-03-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>交换、路由和无线基础</p>
<h1 id="基本设备配置"><a href="#基本设备配置" class="headerlink" title="基本设备配置"></a>基本设备配置</h1><h2 id="使用初始设置配置交换机"><a href="#使用初始设置配置交换机" class="headerlink" title="使用初始设置配置交换机"></a>使用初始设置配置交换机</h2><p>在一台思科交换机开机之后，会经过五步启动顺序：</p>
<ul>
<li>步骤 1: 首先，交换机会加载一个存储在ROM中的上电<strong>自检 (POST) 程序</strong>。POST 会校验CPU子系统。它会测试 CPU、DRAM 以及构成 Flash 文件系统的闪存设备部分。</li>
<li>步骤 2: 接下来，交换机加载<strong>启动加载程序</strong>软件。启动加载程序是存储在 ROM 中并在 POST 成功完成后立即运行的小程序。</li>
<li>步骤 3: 启动加载程序执行<strong>低级 CPU 初始化</strong>。启动加载程序初始化 CPU 寄存器，寄存器控制物理内存的映射位置、内存量以及内存速度。</li>
<li>步骤 4: 启动加载程序<strong>初始化</strong>系统主板上的 <strong>Flash 文件系统</strong>。</li>
<li>步骤 5: 最后，启动加载程序找到并将默认的 <strong>IOS 操作系统</strong>软件映像<strong>加载到内存</strong>，并将对交换机的控制权转交给 IOS。</li>
</ul>
<h3 id="boot-system-命令"><a href="#boot-system-命令" class="headerlink" title="boot system 命令"></a>boot system 命令</h3><p>使用 boot system 全局配置模式命令来设置 BOOT 环境变量。<br>如：<code>boot system flash:/c2960-lanbasek9-mz.150-2.SE/c2960-lanbasek9-mz.150-2.SE.bin</code><br>| 命令 | 定义 |<br>| — | — |<br>| boot system| 主命令。 |<br>| flash:| 存储设备 |<br>| c2960-lanbasek9-mz.150-2.SE/| 文件系统的路径 |<br>| c2960-lanbasek9-mz.150-2.SE.bin| IOS 文件名称 |</p>
<h3 id="交换机-LED-指示灯"><a href="#交换机-LED-指示灯" class="headerlink" title="交换机 LED 指示灯"></a>交换机 LED 指示灯</h3><ul>
<li><strong>SYST</strong> - 系统LED</li>
<li><strong>RPS</strong> - 冗余电源系统LED</li>
<li><strong>STAT</strong> - 端口状态LED</li>
<li><strong>DUPLX</strong> - 端口双工模式LED</li>
<li><strong>SPEED</strong> - 端口速率LED</li>
<li><strong>POE</strong> - 以太网端口供电LED</li>
</ul>
<h3 id="从系统崩溃中恢复"><a href="#从系统崩溃中恢复" class="headerlink" title="从系统崩溃中恢复"></a>从系统崩溃中恢复</h3><h2 id="配置交换机端口"><a href="#配置交换机端口" class="headerlink" title="配置交换机端口"></a>配置交换机端口</h2><h2 id="安全远程访问"><a href="#安全远程访问" class="headerlink" title="安全远程访问"></a>安全远程访问</h2><h2 id="路由器基本配置"><a href="#路由器基本配置" class="headerlink" title="路由器基本配置"></a>路由器基本配置</h2><h2 id="验证直连网络"><a href="#验证直连网络" class="headerlink" title="验证直连网络"></a>验证直连网络</h2><h1 id="交换的概念"><a href="#交换的概念" class="headerlink" title="交换的概念"></a>交换的概念</h1><h2 id="帧转发"><a href="#帧转发" class="headerlink" title="帧转发"></a>帧转发</h2><h2 id="交换域"><a href="#交换域" class="headerlink" title="交换域"></a>交换域</h2>
      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/04/%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/04/%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-title-link" itemprop="url">数据库概念概述1、2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-04 19:06:38" itemprop="dateCreated datePublished" datetime="2022-03-04T19:06:38+08:00">2022-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-31 12:49:08" itemprop="dateModified" datetime="2022-05-31T12:49:08+08:00">2022-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据库及其系统概念"><a href="#数据库及其系统概念" class="headerlink" title="数据库及其系统概念"></a>数据库及其系统概念</h1><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>数据(Data)是数据库中存储的基本对象</p>
<ul>
<li>数据的定义<br>  描述事物的符号记录</li>
<li>数据的种类<br>  文字、图形、图象、声音</li>
<li>数据的特点<br>  数据与其语义是不可分的</li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>数据库的<strong>定义</strong>：<br>数据库(Database,简称DB)是长期储存在计算机内、有组织的、可共享的大量数据的集合。<br>数据库的基本<strong>特征</strong>：</p>
<ul>
<li>数据按一定的数据模型组织、描述和储存</li>
<li>可为各种用户共享</li>
<li>冗余度较小</li>
<li>数据独立性较高</li>
<li>易扩展</li>
</ul>
<p>概括地讲，数据库具有<strong>永久存储</strong>、<strong>有组织</strong>、<strong>可共享</strong>三个基本特点。</p>
<h2 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h2><ul>
<li>什么是DBMS：<br>  数据库管理系统（Database Management System，简称DBMS）是位于用户与操作系统之间的一层数据管理软件。</li>
<li>DBMS的用途：<br>  科学地组织和存储数据、高效地获取和维护数据</li>
</ul>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li><strong>数据定义功能</strong><br>  提供数据定义语言(DDL) 定义数据库中的数据对象</li>
<li><strong>数据组织、存储和管理</strong><br>  分类组织、存储和管理各种数据<br>  确定组织数据的文件结构和存取方式<br>  实现数据之间的联系<br>  提供多种存取方法提高存取效率</li>
<li><strong>数据操纵功能</strong><br>  提供数据操纵语言(DML)<br>  实现对数据库的基本操作 (查询、插入、删除和修改)</li>
<li><strong>数据库的事务管理和运行管理</strong><br>  数据库在建立、运行和维护时由DBMS统一管理和控制 保证数据的安全性、完整性、多用户对数据的并发使用 发生故障后的系统恢复</li>
<li><strong>数据库的建立和维护功能</strong>(实用程序)<br>  数据库初始数据装载转换<br>  数据库转储<br>  介质故障恢复<br>  数据库的重组织<br>  性能监视分析等</li>
<li><strong>其它功能</strong><br>  DBMS与网络中其它软件系统的通信<br>  两个DBMS系统的数据转换<br>  异构数据库之间的互访和互操作</li>
</ul>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>数据模型是指描述事物对象的数据结构组成、数据语义联系、数据约束的抽象结构及其说明</p>
<ol>
<li><strong>数据结构</strong>: 用于描述事物对象的静态特征，包括事物对象的数据组成、数据类型、数据性质等。</li>
<li><strong>数据操作</strong>:用于描述事物对象的动态特征，包括数据的插入、修改、删除和查询等访问操作。</li>
<li><strong>数据约束</strong>：用于描述数据结构中数据之间的语义联系、数据之间的制约和依存关系，以及数据动态变化的规则等。<br>有：</li>
</ol>
<p><strong>层次</strong>数据模型、<strong>网状</strong>数据模型、<strong>关系</strong>数据模型、其它数据模型（如对象数据模型、键值对数据模型、列式数据模型、文档数据模型、图形数据模型等）</p>
<h2 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h2><p>数据库系统（Database Systems）是一类基于数据库进行数据管理与信息服务的软件系统。数据库系统由用户、数据库应用程序、数据库管理系统和数据库<strong>四个部分组成</strong>。</p>
<h3 id="关系数据库中数据内容"><a href="#关系数据库中数据内容" class="headerlink" title="关系数据库中数据内容"></a>关系数据库中数据内容</h3><p>在关系数据库中，除了存储和管理应用的<strong>用户数据</strong>外，还需要存储与管理数据库本身的<strong>元数据</strong>、<strong>索引数据</strong>、<strong>运行数据</strong>等系统数据。</p>
<h2 id="数据库系统应用结构"><a href="#数据库系统应用结构" class="headerlink" title="数据库系统应用结构"></a>数据库系统应用结构</h2><p>单机用户结构、单机用户结构、客户/服务器结构、分布式结构</p>
<h2 id="数据库应用系统生命周期"><a href="#数据库应用系统生命周期" class="headerlink" title="数据库应用系统生命周期"></a>数据库应用系统生命周期</h2><p>需求分析、系统设计、系统实现、系统测试、系统运行与维护</p>
<h2 id="典型数据库管理系统"><a href="#典型数据库管理系统" class="headerlink" title="典型数据库管理系统"></a>典型数据库管理系统</h2><p>ACCESS——微软公司推出的桌面数据库管理系统<br> SQL SERVER——微软公司推出的商用数据库管理系统<br> Oracle Database——甲骨文公司推出的企业级数据库管理系统<br> IBM DB2——IBM公司推出的企业级数据库管理系统<br> Sybase ASE——Sybase公司推出的企业级数据库管理系统<br> MySql——应用广泛的开源关系数据库管理系统<br> PostgreSQL——技术领先的开源对象-关系数据库管理系统<br> Sybase SQL Anywhere——Sybase推出的移动计算数据库管理系统<br> SQLite——开源的轻量级嵌入式数据库管理系统</p>
<h1 id="关系及其相关概念"><a href="#关系及其相关概念" class="headerlink" title="关系及其相关概念"></a>关系及其相关概念</h1><h2 id="关系、实体"><a href="#关系、实体" class="headerlink" title="关系、实体"></a>关系、实体</h2><p><strong>实体</strong>（entity）——是指包含有数据特征的事物对象在概念模型世界中的抽象名称。<br><strong>关系</strong>（relation）——是指具有关系特征、用于存放实体数据的二维表。关系也常被称为关系表。</p>
<h2 id="关系键"><a href="#关系键" class="headerlink" title="关系键"></a>关系键</h2><p>在关系中，可以用来唯一标识元组的属性列，称为键（Key），其它属性列都为非键列。</p>
<ul>
<li><strong>复合键</strong>（Compound Key）——是指关系中用来唯一标识元组的多列作为键。</li>
<li><strong>候选键</strong>（Candidate Key）——关系中可能有多个列均适合作为键，将其中每个都称为候选键。</li>
<li><strong>主键</strong>（Primary key）是关系表中最有代表性的一个候选键，每个关系表中只能定义一个主键。<br>  主键作用：<ul>
<li>唯一标识关系表的每行（元组）</li>
<li>与关联表的外键建立联系，实现关系表之间连接</li>
<li>数据库文件使用主键值来组织关系表的数据存储</li>
<li>数据库使用主键索引快速检索数据</li>
</ul>
</li>
<li><strong>代理键</strong>——采用DBMS自动生成的数字序列作为关系表的主键。</li>
</ul>
<h2 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h2><p><strong>关系模型</strong>（Relation Model）——是一种基于二维表结构存储数据实体及实体间联系的数据模型。<br>由<strong>数据结构</strong>、<strong>数据操作方式</strong>、<strong>数据关系约束</strong>组成。</p>
<h2 id="关系模型的操作"><a href="#关系模型的操作" class="headerlink" title="关系模型的操作"></a>关系模型的操作</h2><p>选择、投影、连接、除</p>
<ul>
<li>选择 - 行选择</li>
<li>投影 - 列选择</li>
<li>连接 - θ连接（全匹配）自然连接（一一对应）外连接（相对于前，不丢失填空值）</li>
<li>除 - 取第一个表能代表概括第二个表的值</li>
</ul>
<h2 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h2><h3 id="关系模型完整性"><a href="#关系模型完整性" class="headerlink" title="关系模型完整性"></a>关系模型完整性</h3><p>关系模型完整性是指在关系数据模型中对关系实施的完整性约束。<br>完整性约束作用：</p>
<ul>
<li>消除关系表的元组重复存储</li>
<li>保持关联表的数据一致性</li>
<li>实现业务数据规则</li>
</ul>
<p>关系模型完整性约束组成：</p>
<ul>
<li>实体完整性约束</li>
<li>参照完整性约束</li>
<li>用户自定义完整性约束</li>
</ul>
<h3 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h3><p>实体完整性是指在关系表中实施的主键取值约束，以保证关系表中的每个元组可以被<strong>唯一标识</strong>。<br>实体完整性<strong>约束规则</strong>：</p>
<ul>
<li>每个关系表中的主键属性列都不允许为空值（NULL），否则就不可能标识实体。</li>
<li>现实世界中的实体是靠主键来标识，主键取值应该唯一，并区分关系表中的每个元组。</li>
</ul>
<h3 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h3><p>参照完整性是指关系表之间需要遵守的数据约束，以保证关系之间关联列的数据<strong>一致性</strong>。<br>参照完整性<strong>约束规则</strong>：若关系R中的外键F与关系S中的主键K相关联，则R中外键F值必须与S中主键K值一致。</p>
<p><strong>外键</strong>（Foreign key）——在关联的两个关系中，它们具有一个或多个相同属性。若关联列在第一个关系中作为主键，则在第二个关系中作为外键。</p>
<h3 id="用户自定义完整性"><a href="#用户自定义完整性" class="headerlink" title="用户自定义完整性"></a>用户自定义完整性</h3><p>用户自定义完整性是指用户根据具体业务对数据处理规则要求所定义的数据约束。<br>用户可以定义如下类型的完整性约束：</p>
<ul>
<li>定义列的数据类型与取值范围</li>
<li>定义列的缺省值</li>
<li>定义列是否允许取空值</li>
<li>定义列取值唯一性</li>
<li>定义列之间的数据依赖性</li>
</ul>

      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1-3)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1-3)/" class="post-title-link" itemprop="url">计算机操作系统(1-3)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-04 14:34:00" itemprop="dateCreated datePublished" datetime="2022-03-04T14:34:00+08:00">2022-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-22 17:56:34" itemprop="dateModified" datetime="2022-04-22T17:56:34+08:00">2022-04-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="操作系统引论"><a href="#操作系统引论" class="headerlink" title="操作系统引论"></a>操作系统引论</h1><h2 id="目标和作用"><a href="#目标和作用" class="headerlink" title="目标和作用"></a>目标和作用</h2><p>目标：方便性、有效性、可扩展性、开放性<br>作用</p>
<ol>
<li>作为用户与计算机硬件系统之间的接口</li>
<li>操作系统引论作为计算机系统资源的管理者</li>
<li>实现了对计算机资源的抽象</li>
</ol>
<h2 id="发展过程"><a href="#发展过程" class="headerlink" title="发展过程"></a>发展过程</h2><p>人工操作方式、脱机输入输出方式<br>单批道处理系统<br>多批道处理系统（资源利用率高，系统吞吐量大，平均周转时间长，无交互能力）<br>分时系统（多路性、独立性、及时性、交互性）<br>实时系统（多路性、独立性、及时性、交互性、可靠性）<br>微机操作系统（单用户多用户）</p>
<h2 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h2><ul>
<li>并发 -  <strong>并发性</strong>是指两个或多个事件在同一时间间隔内发生，而<strong>并行性</strong>是指两个或多个事件在同一时刻发生。</li>
<li>共享 -  <strong>资源共享</strong>是指系统中的资源可供内存中多个并发执行的进程共同使用。一段时间内只允许一个进程访问的资源称为<strong>临界资源</strong>一个进程访问结束并释放系统资源后才允许另一进程对该资源访问的方式称为<strong>互斥访问</strong></li>
<li>虚拟 -  通过<strong>空分复用</strong>或<strong>时分复用</strong>技术将一条物理信道变为若干条逻辑信道的技术</li>
<li>异步 -  进程的执行本身具有异步性（不可预知完成时间与顺序）所以要设计同步机制</li>
</ul>
<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><h3 id="处理机管理功能"><a href="#处理机管理功能" class="headerlink" title="处理机管理功能"></a>处理机管理功能</h3><ul>
<li>进程控制</li>
<li>进程同步</li>
<li>进程通信</li>
<li>调度</li>
</ul>
<h3 id="内存管理功能"><a href="#内存管理功能" class="headerlink" title="内存管理功能"></a>内存管理功能</h3><ul>
<li>内存分配</li>
<li>内存保护</li>
<li>地址映射</li>
<li>内存扩充</li>
</ul>
<h3 id="I-O-设备管理功能"><a href="#I-O-设备管理功能" class="headerlink" title="(I/O)设备管理功能"></a>(I/O)设备管理功能</h3><ul>
<li>缓冲管理</li>
<li>设备分配</li>
<li>设备处理</li>
</ul>
<h3 id="文件管理功能"><a href="#文件管理功能" class="headerlink" title="文件管理功能"></a>文件管理功能</h3><ul>
<li>文件存储空间管理</li>
<li>目录管理</li>
<li>文件读写管理与保护</li>
</ul>
<h3 id="操作系统与用户之间的接口"><a href="#操作系统与用户之间的接口" class="headerlink" title="操作系统与用户之间的接口"></a>操作系统与用户之间的接口</h3><ul>
<li>用户接口（联机用户接口、脱机用户接口、程序接口）</li>
<li>程序接口</li>
</ul>
<h2 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h2><h3 id="无结构"><a href="#无结构" class="headerlink" title="无结构"></a>无结构</h3><p>程序紧凑，高效利用内存<br>但是随着系统的不断扩大，所设计出的操作系统就会变得既庞大又杂乱。<br>一方面会使编制的程序错误很多给调试工作带来困难<br>另一方面也使程序难以阅读和理解，增加了维护负担</p>
<h3 id="模块化结构"><a href="#模块化结构" class="headerlink" title="模块化结构"></a>模块化结构</h3><p>模块化OS由程序设计的模块化设计思想演变而来<br>衡量模块化设计的两个标准：内聚性、耦合性<br>优点：</p>
<ol>
<li>提高OS设计的正确性、可理解性和可维护性。</li>
<li>增强OS的可适应性。</li>
<li>加速OS开发过程。<br>问题：</li>
<li>最初模块接口规定难以满足实际需求</li>
<li>无序设计</li>
</ol>
<h3 id="分层式结构"><a href="#分层式结构" class="headerlink" title="分层式结构"></a>分层式结构</h3><p>将模块接口法中对模块的设计顺序由无序变为有序，自底向上分层设计<br>优点：</p>
<ol>
<li>易保证系统的正确性</li>
<li>易扩充和易维护性<br>缺点：</li>
<li>系统效率降低：单向依赖的层次使得必须建立层次之间的通信机制增加通信开销</li>
</ol>
<h3 id="文件管理功能-文件管理功能"><a href="#文件管理功能-文件管理功能" class="headerlink" title="文件管理功能### 文件管理功能"></a>文件管理功能### 文件管理功能</h3><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><ol>
<li><p>设计现代OS的主要目标是什么？<br>方便性、有效性、可扩展性、开放性</p>
</li>
<li><p>试说明推动分时系统形成和发展的主要动力是什么。<br>满足人机交互需求，实现共享主机</p>
</li>
<li><p>为什么要引入实时操作系统？<br>更好的满足实时控制实时信息处理领域对时间控制的需求</p>
</li>
<li><p>试从交互性、及时性以及可靠性方面将分时系统与实时系统进行比较。<br>交互性：实时系统的交互性不像分时系统为终端用户提供数据和资源共享服务，而限于特定专用服务程序<br>及时性：分时系统的响应时间间隔通常为人们所能接受的1~3秒，实时系统由截至时间所确定通常为秒级到毫秒级<br>可靠性：实时系统相比分时系统要求更高的可靠性，所以采取多级容错措施保障系统的安全性</p>
</li>
<li><p>OS有几大特征？最基本的特征是什么？<br>并发性、共享性、虚拟性、异步性；并发性最基本</p>
</li>
<li><p>处理机管理有哪些主要功能？其主要任务是什么？<br>进程控制、进程同步、进程通信、调度<br>创建进程结束进程控制正在运行的进程、使多个进程有序同步进行、交换进程任务的信息、选择作业分配资源运行的作业调度和选择进程分配处理器设置现场执行的进程调度</p>
</li>
<li><p>存储器有哪些主要功能？其主要任务是什么？<br>内存分配、内存保护、地址映射、内存扩充<br>为程序分配内存空间、确保程序运行空间不干扰、将逻辑地址映射为物理地址、实现调用置换等功能</p>
</li>
<li><p>设备管理有哪些主要功能？其主要任务是什么？<br>缓冲管理、设备分配、设备处理<br>完成用户IO请求分配所需IO设备执行IO操作、提高CPU和IO设备的利用率提高IO速度方便用户使用</p>
</li>
<li><p>文件管理有哪些主要功能？其主要任务是什么？<br>文件存储空间管理、目录管理、文件读写管理与保护<br>分配外存空间提高外存利用率、为文件建立目录加以有效组织、根据用户请求读写外存数据、防止文件被非法窃取和受到破坏保障文件安全性</p>
</li>
</ol>
<h1 id="进程的描述与控制"><a href="#进程的描述与控制" class="headerlink" title="进程的描述与控制"></a>进程的描述与控制</h1><h2 id="前趋图和程序执行"><a href="#前趋图和程序执行" class="headerlink" title="前趋图和程序执行"></a>前趋图和程序执行</h2><p>前趋图（Precedence  Graph）是一个有向无循环图，用于描述进程之间执行的前后关系。</p>
<h3 id="程序的顺序执行"><a href="#程序的顺序执行" class="headerlink" title="程序的顺序执行"></a>程序的顺序执行</h3><ul>
<li>顺序性</li>
<li>封闭性</li>
<li>可再现性</li>
</ul>
<h3 id="程序的并发执行"><a href="#程序的并发执行" class="headerlink" title="程序的并发执行"></a>程序的并发执行</h3><ul>
<li>间断性</li>
<li>失去封闭性</li>
<li>不可再现性</li>
</ul>
<h2 id="进程的描述"><a href="#进程的描述" class="headerlink" title="进程的描述"></a>进程的描述</h2><p>而由程序段、相关的数据段和PCB三部分便构成了进程实体。</p>
<h3 id="典型定义"><a href="#典型定义" class="headerlink" title="典型定义"></a>典型定义</h3><ol>
<li>进程是程序的一次执行。</li>
<li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</li>
<li>进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</li>
</ol>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul>
<li>动态性</li>
<li>并发性</li>
<li>独立性</li>
<li>异步性</li>
</ul>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p><img src="/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1-3)/IMG_20220304_151207_edit_772433114767030.jpg" alt="IMG_20220304_151207_edit_772433114767030"></p>
<h3 id="PCB数据结构"><a href="#PCB数据结构" class="headerlink" title="PCB数据结构"></a>PCB数据结构</h3><ol>
<li><strong>进程标识符</strong> - 用于惟一地标识一个进程。分为内部标识符和外部标识符</li>
<li><strong>处理机状态</strong> - 组成：①通用寄存器②指令计数器③程序状态字PSW④用户栈指针</li>
<li><strong>进程调度信息</strong> - 包括：①进程状态②进程优先级③进程调度所需的其它信息④事件，阻塞原因</li>
<li><strong>进程控制信息</strong> - ①程序和数据的地址 ②进程同步和通信机制 ③资源清单 ④链接指针</li>
</ol>
<table>
<thead>
<tr>
<th>pid</th>
</tr>
</thead>
<tbody><tr>
<td>进程状态</td>
</tr>
<tr>
<td>现场</td>
</tr>
<tr>
<td>优先级</td>
</tr>
<tr>
<td>阻塞原因</td>
</tr>
<tr>
<td>程序地址</td>
</tr>
<tr>
<td>同步机制</td>
</tr>
<tr>
<td>资源清单</td>
</tr>
<tr>
<td>链接指针</td>
</tr>
</tbody></table>
<h3 id="PCB的组织方式"><a href="#PCB的组织方式" class="headerlink" title="PCB的组织方式"></a>PCB的组织方式</h3><ol>
<li><strong>线性方式</strong> 将系统中的所有PCB组织在一张线性表中，将该表的首地址存放在一个专用区域中。</li>
<li><strong>链接方式</strong> 把具有同一状态的PCB，用其中的链接字链接成一个队列，排成就绪队列，若干个阻塞队列以及空白队列。</li>
<li><strong>索引方式</strong> 系统根据所有进程的状态建立几张索引表。</li>
</ol>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>进程控制是用于创建一个新进程，终止一个已完成的进程，或去终止一个因出现某事件而使其无法运行下去的进程，还负责进程运行中的状态转换。</p>
<h3 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h3><p>OS内核—-常驻内存。<br>包含与硬件紧密相关的模块（中断处理） 常用设备驱动、运行频率高的模块（时钟管理、进程调度）<br>目的：1、保护；2、提供OS效率</p>
<ol>
<li>支撑功能 - 中断处理 时钟管理 原语操作</li>
<li>资源管理功能 - 进程管理 存储器管理 设备管理</li>
</ol>
<h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><h4 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h4><p>即父进程、子进程（可以继承父进程所拥有的资源）</p>
<h4 id="引起创建进程的事件"><a href="#引起创建进程的事件" class="headerlink" title="引起创建进程的事件"></a>引起创建进程的事件</h4><ol>
<li>用户登录</li>
<li>作业调度</li>
<li>提供服务</li>
<li>应用请求</li>
</ol>
<h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><p>调用进程创建原语Creat（ ）按下述步骤创建一个新进程：</p>
<ol>
<li>申请空白PCB。</li>
<li>为新进程分配资源。</li>
<li>初始化进程控制块。包括：<br>①初始化标识信息。<br>②初始化处理机状态信息。<br>③初始化处理机控制信息。</li>
<li>将新进程插入就绪队列。</li>
</ol>
<h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><h4 id="引起进程终止的事件"><a href="#引起进程终止的事件" class="headerlink" title="引起进程终止的事件"></a>引起进程终止的事件</h4><ol>
<li>正常结束: 批处理中用Holt指令，分时中用Logs off指令。</li>
<li>异常结束：<br>①越界错误。存储区。<br>②保护错。写一个只读文件。<br>③非法指令。执行一条不存在的指令。<br>④特权指令错。用户访问只允许OS执行的指令。<br>⑤运行超时。<br>⑥等待超时。<br>⑦算术运算错。被0除。<br>⑧I/O故障。</li>
<li>外界干预：外界干预并非指在本进程运行中出现了异常事件，而是指进程应外界的请求而终止运行。<br>① 操作员或操作系统干预。<br>② 父进程请求终止该进程。<br>③ 当父进程终止时，OS也将他的所有子孙进程终止。</li>
</ol>
<h4 id="进程的终止过程"><a href="#进程的终止过程" class="headerlink" title="进程的终止过程"></a>进程的终止过程</h4><ol>
<li>根据被终止进程的标识符ID，从PCB集合中检索出该进程的PCB，从中读出该进程的状态。</li>
<li>若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度。</li>
<li>若该进程还有子孙进程，还应将其所有子孙进程予以终止，以防他们成为不可控的进程。</li>
<li>将被终止进程所拥有的全部资源，或者归还给其父进程，或者归还给系统。</li>
<li>将被终止进程（它的PCB）从所在队列（或链表）中移出，等待其他程序来搜集信息。</li>
</ol>
<h3 id="进程的阻塞与唤醒、挂起与激活"><a href="#进程的阻塞与唤醒、挂起与激活" class="headerlink" title="进程的阻塞与唤醒、挂起与激活"></a>进程的阻塞与唤醒、挂起与激活</h3><h4 id="引起进程阻塞的事件"><a href="#引起进程阻塞的事件" class="headerlink" title="引起进程阻塞的事件"></a>引起进程阻塞的事件</h4><ol>
<li>请求系统服务：提出I/O服务时，并不立即满足该进程的要求时，转变为阻塞状态来等待</li>
<li>启动某种操作：当进程启动某种操作后，在该操作完成之后才能继续执行。</li>
<li>新数据尚未到达：对于相互合作的进程而言。 </li>
<li>无新工作可做。如发送进程。</li>
</ol>
<h4 id="进程阻塞过程"><a href="#进程阻塞过程" class="headerlink" title="进程阻塞过程"></a>进程阻塞过程</h4><p>正在执行的进程，当发现上述某事件时，由于无法继续执行，于是进程便通过调用阻塞原语block( )把自己阻塞。</p>
<ol>
<li>把进程控制块中的现行状态由“执行”改为“阻塞”，并将PCB插入阻塞队列。</li>
<li>转调度程序进行重新调度，将处理机分配给另一就绪进程，并进行切换。</li>
</ol>
<h4 id="进程唤醒过程"><a href="#进程唤醒过程" class="headerlink" title="进程唤醒过程"></a>进程唤醒过程</h4><p>当被阻塞进程所期待的事件出现时，则由有关进程（比如，用完并释放了该I/O设备的进程）调用唤醒原语wakeup( )，将等待该事件的进程唤醒。</p>
<ol>
<li>首先把被阻塞的进程从等待该事件的阻塞队列中移出，将其PCB中的现行状态由阻塞改为就绪</li>
<li>然后再将该PCB插入到就绪队列中。</li>
</ol>
<h4 id="进程的挂起"><a href="#进程的挂起" class="headerlink" title="进程的挂起"></a>进程的挂起</h4><p>当出现了引起进程挂起的事件时，系统将利用挂起原语suspend( )将指定进程进程挂起。</p>
<ol>
<li>首先检查被挂起进程的状态，若处于活动就绪状态，便将其改为静止就绪；</li>
<li>对于活动阻塞状态的进程，则将之改为静止阻塞状态。</li>
</ol>
<h4 id="进程的激活"><a href="#进程的激活" class="headerlink" title="进程的激活"></a>进程的激活</h4><p>当发生激活进程的事件时，则可将在外存上处于静止就绪状态的进程换入内存。 系统利用激活原语active( )将指定进程激活:</p>
<ol>
<li>激活原语先将进程从外存调入内存，检查该进程的现行状态; </li>
<li>若是静止就绪，便将之改为活动就绪；若为静止阻塞，便将之改为活动阻塞。</li>
</ol>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>为什么：<br>由于进程的异步性，也会给系统造成混乱，在OS中引入进程同步。<br>任务：<br>使并发执行的诸进程之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性。</p>
<h3 id="进程同步的基本概念"><a href="#进程同步的基本概念" class="headerlink" title="进程同步的基本概念"></a>进程同步的基本概念</h3><ul>
<li>两种形式的制约关系：1）间接相互制约关系。由于资源共享 2）直接相互制约关系。主要由于进程间的合作。</li>
<li><strong>临界资源</strong> 一次仅允许一个进程访问的资源为临界资源 。</li>
<li><strong>临界区</strong> 把在每个进程中访问临界资源的那段代码称为临界区。</li>
<li>同步机制<strong>规则</strong> ：1)空闲让进 2)忙则等待 3)有限等待 4)让权等待</li>
</ul>
<h3 id="硬件同步机制"><a href="#硬件同步机制" class="headerlink" title="硬件同步机制"></a>硬件同步机制</h3><p>利用计算机硬件指令解决临界区问题<br>    对临界区管理将标识看做一个锁，“锁开”进入，“锁关”等待。 初始打开，每个进入临界区的进程必须对锁进行测试。 测试和关锁操作必须连续（原子操作）<br>方法：</p>
<ul>
<li>关中断</li>
<li>利用Test-and-Set指令实现互斥</li>
<li>利用Swap指令实现进程互斥</li>
</ul>
<p>优点：</p>
<ul>
<li>适用于任意数目的进程，在单处理器或多处理器上</li>
<li>简单，容易验证其正确性</li>
<li>可以支持进程内存在多个临界区，只需为每个临界区设立一个布尔变量</li>
</ul>
<p>缺点：</p>
<ul>
<li>等待要耗费CPU时间，不能实现“让权等待”</li>
<li>可能“饥饿”：从等待进程中随机选择一个进入临界区，有的进程可能一直选不上</li>
</ul>
<h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><p>信号量（Semaphores）机制:是一种卓有成效的进程同步工具。</p>
<h4 id="整形信号量"><a href="#整形信号量" class="headerlink" title="整形信号量"></a>整形信号量</h4><ol>
<li>必须置一次且只能置一次初值，并且初值不能为负数。</li>
<li>只能执行P、V操作。</li>
<li>必须成对使用P、V操作：P操作遗漏则不能保证互斥访问，V操作遗漏则不能在使用临界资源之后将其释放；P，V次序不能错误、重复或遗漏。<br>整形信号量机制的问题：忙等。<br>wait操作中信号量S&lt;=0时，会不停的测试<br>未遵循让权等待的原则</li>
</ol>
<h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h4><p>只能用于共享一个临界资源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">	int value;</span><br><span class="line">	struct process_control_block *list;</span><br><span class="line">&#125;semaphore;</span><br><span class="line"></span><br><span class="line">wait(semaphore *S)&#123;</span><br><span class="line">	S-&gt;value--;</span><br><span class="line">	if(S-&gt;value&lt;0)block(S-&gt;list);</span><br><span class="line">&#125;</span><br><span class="line">signal(semaphore *S)&#123;</span><br><span class="line">	S-&gt;value++;</span><br><span class="line">	if(S-&gt;value&lt;=0)wakeup(S-&gt;list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>信号量的初值：0，1，n三种情况<br>    1：表示临界资源；<br>    0：表示进程间的同步（前驱）关系<br>    n：表示若干个资源</p>
<h4 id="AND型信号量"><a href="#AND型信号量" class="headerlink" title="AND型信号量"></a>AND型信号量</h4><p><strong>AND同步机制的基本思想</strong>：将进程在整个运行过程中需要的所有资源，一次性全都地分配给进程，待进程使用完后再一起释放。只要尚有一个资源未能分配给进程，其它所有可能为之分配的资源，也不分配给他。<br><strong>原子操作</strong>：要么全部分配到进程，要么一个也不分配。<br>在wait操作中，增加了一个“AND”条件，故称为AND同步，或称为同时wait操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Swait（S1，S2，···，Sn ） &#123;</span><br><span class="line">     while（true）&#123;</span><br><span class="line">         if（ S1≥1 and S2≥1 and…and Sn≥1 ）&#123;</span><br><span class="line">            for (i = 1 ; i&lt;= n; i++)&#123;</span><br><span class="line">                     Si =  Si – 1;</span><br><span class="line">             &#125;</span><br><span class="line">             break;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">               place  the process  in  the waiting  queue  associated  with  the  first  Si  found  with  Si＜1,  and  set  the program  count  of  this  process  to  the  beginning  of  Swait  operation//将进程置于与在 Si&lt;1 的条件下找到的**第一个** Si 关联的等待队列中，并将此过程的程序计数设置为 Swait 操作的开始</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ssignal（S1，S2，···，Sn）&#123;</span><br><span class="line">    for(  i = 1; i&lt;= n; i++ )&#123;</span><br><span class="line">         Si = Si+1;</span><br><span class="line">         Remove  all  the  process  waiting  in  the  queue  associated  with  Si  into  the  ready  queue//将与 Si 关联的队列中**所有**等待的进程移动到就绪队列中</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="信号量集"><a href="#信号量集" class="headerlink" title="信号量集"></a>信号量集</h4><p>一般信号量集是指同时需要多种资源、每种占用的数目不同、且可分配的资源(预留下限)还存在一个临界值时的信号量处理<br>一般信号量集的基本思路就是在AND型信号量集的基础上进行扩充，在一次原语操作中完成所有的资源申请</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Swait（S1，t1，d1，…，Sn，tn，dn）（满足ti≥ di）    </span><br><span class="line">    if( S1 ≥t1 &amp;…&amp; Sn≥tn)&#123;  </span><br><span class="line">          for(  i =1; i&lt;=n; i++)&#123;</span><br><span class="line">                    Si ＝Si － di;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">          Place  the  executing  process  in  the  waiting  queue  of  the  first Si  with Si＜ti  and  set  its  program  counter  to  the  beginning  of  the  Swait  operation//将进程置于与在 Si&lt;ti 的条件下找到的**第一个** Si 关联的等待队列中，并将此过程的程序计数设置为 Swait 操作的开始</span><br><span class="line">    &#125;//end if</span><br><span class="line">&#125;//end Swait </span><br><span class="line"></span><br><span class="line"> Ssignal（S1，d1，···，Sn，dn）&#123;</span><br><span class="line">    for( i =1; i&lt;= n; i++)&#123;  </span><br><span class="line">        Si = Si + di；</span><br><span class="line">        Remove  all  the  process  waiting  in  the  queue  associated  with  Si  into  the  ready  queue//将与 Si 关联的队列中**所有**等待的进程移动到就绪队列中</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三种特例：</p>
<ol>
<li>Swait(S,d,d)：允许每次申请d个资源。当资源数少于d时，不予分配。</li>
<li>Swait (S,1,1)：S&gt;1，记录型信号量。S=1时，互斥型信号量。</li>
<li>Swait(S,1,0)，可控开关，当S&gt;=1时，允许进入，S&lt;1时，不能进入。</li>
</ol>
<h2 id="经典进程的同步问题"><a href="#经典进程的同步问题" class="headerlink" title="经典进程的同步问题"></a>经典进程的同步问题</h2><h3 id="生产者——消费者问题"><a href="#生产者——消费者问题" class="headerlink" title="生产者——消费者问题"></a>生产者——消费者问题</h3><h4 id="记录型信号量解决"><a href="#记录型信号量解决" class="headerlink" title="记录型信号量解决"></a>记录型信号量解决</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void producer( )&#123;</span><br><span class="line">    do&#123;</span><br><span class="line">		…</span><br><span class="line">		Produce an item in nextp;</span><br><span class="line">		…</span><br><span class="line">		wait(empty);</span><br><span class="line">		wait(mutex);</span><br><span class="line">		buffer(in):=nextp;</span><br><span class="line">		in:=(in+1) mod n;</span><br><span class="line">		signal(mutex);</span><br><span class="line">		signal(full);</span><br><span class="line">	&#125;while(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void consumer&#123;</span><br><span class="line">  do&#123;</span><br><span class="line">  		wait(full);</span><br><span class="line">		wait(mutex);</span><br><span class="line">		nextc:=buffer(out);</span><br><span class="line">		out:=(out+1) mod n;</span><br><span class="line">		signal(mutex);</span><br><span class="line">		signal(empty);</span><br><span class="line">		Consumer the item in nextc;</span><br><span class="line">		……</span><br><span class="line">	&#125;while(TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AND信号量解决"><a href="#AND信号量解决" class="headerlink" title="AND信号量解决"></a>AND信号量解决</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int  in=0, out=0;</span><br><span class="line">item    buffer[ n ];</span><br><span class="line">semaphore  mutex=1, empty=n, full=0;</span><br><span class="line">void producer( )&#123;</span><br><span class="line">	do&#123;</span><br><span class="line">		…</span><br><span class="line">		produce an item in nextp;</span><br><span class="line">		…</span><br><span class="line">		Swait(empty, mutex);</span><br><span class="line">		buffer[in] = nextp;</span><br><span class="line">		in = (in+1) % n;</span><br><span class="line">		Ssignal(mutex, full);</span><br><span class="line">	&#125;while(TRUE);</span><br><span class="line">&#125; //end producer</span><br><span class="line"></span><br><span class="line">void consumer&#123;</span><br><span class="line">	do&#123;</span><br><span class="line">		Swait(full, mutex);</span><br><span class="line">		nextc = buffer[out];</span><br><span class="line">		out = (out+1) % n;</span><br><span class="line">		Ssignal(mutex, empty);</span><br><span class="line">		consumer the item in nextc;</span><br><span class="line">	&#125;while(TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><p>几种解决方法：</p>
<ol>
<li>至多只允许有四位哲学家同时去拿左边的筷子，最终能保证至少有一位哲学家能够进餐，并在用毕时能释放出他用过的两只筷子，从而使更多的哲学家能够进餐。</li>
<li>仅当哲学家的左、右两只筷子均可用时，才允许他拿起筷子进餐。</li>
<li>规定奇数号哲学家先拿他左边的筷子，然后再去拿右边的筷子；而偶数号哲学家则相反。按此规定，将是1、 2号哲学家竞争1号筷子；3、4号哲学家竞争3号筷子。即五位哲学家都先竞争奇数号筷子，获得后，再去竞争偶数号筷子，最后总会有一位哲学家能获得两只筷子而进餐</li>
</ol>
<h4 id="AND信号量解决-1"><a href="#AND信号量解决-1" class="headerlink" title="AND信号量解决"></a>AND信号量解决</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[5]=&#123;1,1,1,1,1&#125;;</span><br><span class="line">do&#123;</span><br><span class="line">	……;</span><br><span class="line">	think;</span><br><span class="line">	Sswait(chopstick[(i+1) % 5],chopstick[i]);</span><br><span class="line">	eat;</span><br><span class="line">	Ssignal(chopstick[(i+1) % 5],chopstick[i]);</span><br><span class="line">&#125;while(TRUE);</span><br></pre></td></tr></table></figure>

<h3 id="读者——写者问题"><a href="#读者——写者问题" class="headerlink" title="读者——写者问题"></a>读者——写者问题</h3><h4 id="记录型信号量解决-1"><a href="#记录型信号量解决-1" class="headerlink" title="记录型信号量解决"></a>记录型信号量解决</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">semaphore rmutex=1, wmutex = 1;</span><br><span class="line">int readcount = 0;</span><br><span class="line"></span><br><span class="line">void reader( )&#123;</span><br><span class="line">	do&#123;</span><br><span class="line">		wait(rmutex);</span><br><span class="line">		if  readcount=0  then  wait(wmutex);</span><br><span class="line">		readcount:=readcount+1;</span><br><span class="line">		signal(rmutex);</span><br><span class="line">		…				</span><br><span class="line">		perform read operation</span><br><span class="line">		…</span><br><span class="line">		wait(rmutex);</span><br><span class="line">		readcount:=readcount-1;</span><br><span class="line">		if readcount=0  then signal(wmutex);</span><br><span class="line">		signal(rmutex);</span><br><span class="line">	&#125;while(TRUE);</span><br><span class="line">&#125;//end reader</span><br><span class="line"></span><br><span class="line">void writer( )&#123;</span><br><span class="line">	do&#123;</span><br><span class="line">		wait(wmutex)</span><br><span class="line">		perform write operation;</span><br><span class="line">		signal(wmutex)</span><br><span class="line">	&#125;while(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">	cobegin</span><br><span class="line">	reader(); writer();</span><br><span class="line">	coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="信号量集解决"><a href="#信号量集解决" class="headerlink" title="信号量集解决"></a>信号量集解决</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int RN;</span><br><span class="line">Semaphore L=RN, mx=1;</span><br><span class="line">//RN标示同时允许多少读进程存在</span><br><span class="line">void reader( )&#123;</span><br><span class="line">	   do&#123;</span><br><span class="line">              swait(L,1,1);</span><br><span class="line">              swait(mx,1,0);</span><br><span class="line">                   …</span><br><span class="line"> 	        perform read operation;</span><br><span class="line">		        …</span><br><span class="line">	         ssignal(L,1);</span><br><span class="line">        &#125;while(TRUE);</span><br><span class="line">&#125;//end reader</span><br><span class="line"></span><br><span class="line"> void writer( )&#123;</span><br><span class="line">        do&#123;</span><br><span class="line">             swait(mx,1,1; L,RN,0);</span><br><span class="line">             perform write operation;</span><br><span class="line">             ssignal(mx, 1);</span><br><span class="line">        &#125;while(TRUE);</span><br><span class="line"> &#125; //end writer</span><br><span class="line"></span><br><span class="line"> void main( )&#123;</span><br><span class="line">    cobegin</span><br><span class="line">       reader(); writer();</span><br><span class="line">    coedn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul>
<li><strong>共享存储器系统</strong> - 基于共享数据结构的通信方式。基于共享存储区的通信方式。</li>
<li><strong>消息传递系统</strong> - 是目前的主要通信方式，信息单位：消息（报文）实现：一组通信命令（原语），具有透明性、同步的实现。实现方式的不同，而分成：<br>   （1）直接通信方式<br>   （2）间接通信方式</li>
<li><strong>管道通信系统</strong> - 管道：连接一个读进程和一个写进程之间通信的共享文件。 功能：大量的数据发收。 注意：<pre><code>（1）互斥
（2）同步
（3）对方是否存在
</code></pre>
</li>
<li><strong>客户机服务器系统</strong></li>
</ul>
<h3 id="消息传递通信的实现方法"><a href="#消息传递通信的实现方法" class="headerlink" title="消息传递通信的实现方法"></a>消息传递通信的实现方法</h3><ul>
<li><p>直接通信方式<br>这是指发送进程利用OS所提供的发送命令，直接把消息发送给目标进程。<br>系统提供下述两条通信命令（<strong>原语</strong>）：<br>   Send  （Receiver，  message）；<br>   Receive（Sender，  message）； </p>
</li>
<li><p>间接通信方式<br>指进程之间利用信箱的通信方式。发送进程发送给目标进程的消息存放信箱；接收进程则从该信箱中，取出对方发送给自己的消息；消息在信箱中可以安全地保存，只允许核准的目标用户随时读取。<br>   系统为信箱通信提供了若干条<strong>原语</strong>，分别用于信箱的创建、撤消和消息的发送、接收等。优点：在读/写时间上的随机性<br>信箱分为以下三类：<br>（1）私用信箱<br>（2）公用信箱<br>（3）共享信箱<br>在利用信箱通信时，在发送进程和接收进程之间，存在以下四种关系：<br>（1）一对一关系。<br>（2）多对一关系，客户/服务器交互。<br>（3）一对多关系， 广播方式。<br>（4）多对多关系。</p>
</li>
</ul>
<h3 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h3><p>消息头：含控制信息如：收/发进程名，消息长度、类型、编号<br>消息内容：<br>    定长消息：系统开销小，用户不便（特别是传长消息用户）<br>    变长消息：开销大，用户方便。</p>
<h3 id="消息格式进程同步方式"><a href="#消息格式进程同步方式" class="headerlink" title="消息格式进程同步方式"></a>消息格式进程同步方式</h3><p>1）发送和接收进程阻塞（汇合）用于紧密同步，无缓冲区时。<br>2）发送进程不阻塞，接收进程阻塞（多个）相当于接收进程（可能是多个）一直等待发送进程，如：打印进程等待打印任务。<br>3）发送/接收进程均不阻塞一般在发、收进程间有多个缓冲区时。</p>
<h2 id="进程运行与监控"><a href="#进程运行与监控" class="headerlink" title="进程运行与监控"></a>进程运行与监控</h2><h3 id="Linux进程控制块"><a href="#Linux进程控制块" class="headerlink" title="Linux进程控制块"></a>Linux进程控制块</h3><h4 id="task-struct结构"><a href="#task-struct结构" class="headerlink" title="task_struct结构"></a>task_struct结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pid_t pid;</span><br><span class="line">uid_t uid,euid; </span><br><span class="line">gid_t gid,egid;</span><br><span class="line">volatile long state;</span><br><span class="line">int exit_state;</span><br><span class="line">unsigned int rt_priority;</span><br><span class="line">unsigned int policy;</span><br><span class="line">struct list_head tasks;</span><br><span class="line">struct task_struct *real_parent;</span><br><span class="line">struct task_struct *parent;</span><br><span class="line">struct list_head children,sibling;</span><br><span class="line">struct fs_struct *fs;</span><br><span class="line">struct files_struct *files;</span><br><span class="line">struct mm_struct *mm;</span><br><span class="line">struct signal_struct *signal;</span><br><span class="line">struct sighand_struct *sighand;</span><br><span class="line">cputime_t utime, stime;</span><br><span class="line">struct timespec start_time;</span><br><span class="line">struct timespec real_start_time;</span><br></pre></td></tr></table></figure>

<h4 id="task-struct-进程状态"><a href="#task-struct-进程状态" class="headerlink" title="task_struct:进程状态"></a>task_struct:进程状态</h4><p>——<code>volatile long state;</code><br>state成员的可能取值如下： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define TASK_RUNNING	0  </span><br><span class="line">#define TASK_INTERRUPTIBLE	1  </span><br><span class="line">#define TASK_UNINTERRUPTIBLE	2  </span><br><span class="line">#define TASK_ZOMBIE	4  </span><br><span class="line">#define TASK_STOPPED	8</span><br></pre></td></tr></table></figure>

<h4 id="进程状态切换"><a href="#进程状态切换" class="headerlink" title="进程状态切换"></a>进程状态切换</h4><p><img src="/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1-3)/1646809311457.png"></p>
<h4 id="task-struct-文件管理"><a href="#task-struct-文件管理" class="headerlink" title="task_struct:文件管理"></a>task_struct:文件管理</h4><p><img src="/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1-3)/1647413678022.png"></p>
<h3 id="进程的启动"><a href="#进程的启动" class="headerlink" title="进程的启动"></a>进程的启动</h3><p>UNIX&amp;Linux中创建进程的方式：</p>
<ul>
<li><p>在shell中执行命令或可执行文件由shell进程调用fork函数创建子进程</p>
</li>
<li><p>在代码中（已经存在的进程中）调用fork函数创建子进程，fork创建的进程为子进程，原进程为父进程</p>
</li>
<li><p>Linux系统中进程0 （PID=0）是由内核创建，其他所有进程都是由父进程调用fork函数所创建的。进程0在创建子进程（PID=1，init进程）后，进程0就转为交换进程或空闲进程</p>
</li>
<li><p>进程1（init进程）是系统中其他所有进程的共同祖先</p>
</li>
</ul>
<h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><p><code>#include&lt;unistd.h&gt;</code>头文件定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* Clone the calling process, creating an exact copy.</span><br><span class="line">	Return -1 for errors, 0 to the new process,</span><br><span class="line">	and the process ID of the new process to the old process.  */</span><br></pre></td></tr></table></figure>
<p>fork函数被正确调用后，将会在子进程中和父进程中分别返回</p>
<ul>
<li>在子进程中返回值为0（不合法的PID，提示当前运行在子进程中）</li>
<li>在父进程中返回值为子进程ID（让父进程掌握所创建子进程的ID号）</li>
<li>出错返回-1</li>
</ul>
<p>子进程是父进程的副本</p>
<ul>
<li>子进程复制/拷贝父进程的PCB、用户空间（数据段、堆和栈）</li>
<li>父子进程共享正文段（只读）<br>父进程继续执行fork函数调用之后的代码，子进程也从fork函数调用之后的代码开始执行为了提高效率，fork后不并立即复制父进程数据段、堆和栈，采用了写时复制机制（Copy-On-Write）：当父子进程任意之一要修改数据段、堆、栈时，进行复制操作，并且仅复制修改区域</li>
</ul>
<p>子进程复制父进程的进程控制块</p>
<ul>
<li>父进程的文件描述符表被子进程复制，父子进程的同一文件描述符<strong>指向同一个文件表</strong></li>
<li>父子进程对同一文件访问基于<strong>相同的文件当前位置</strong></li>
</ul>
<p>父子进程对共享文件的常见处理方式：</p>
<ul>
<li>父进程等待子进程完成。当子进程终止后，文件当前位置已经得到了相应的更新</li>
<li>父子进程各自执行不同的程序段，各自关闭不需要的文件</li>
</ul>
<p>vfork函数保证子进程先执行，在它调用exec或者exit之后，父进程才会继续被调度执行（父进程处于TASK_UNINTERRUPTIBLE状态）</p>
<h4 id="进程内存空间布局"><a href="#进程内存空间布局" class="headerlink" title="进程内存空间布局"></a>进程内存空间布局</h4><ul>
<li>命令行参数和环境变量 - 主要用于支撑函数调用 存放参数、局部变量等</li>
<li>堆栈 - 用于动态分配内存</li>
<li>未初始化的数据 - 程序执行之前，将此段中 的数据初始化为0，如 全局变量long sum[1000];</li>
<li>初始化的数据 - 包含了程序中需明确赋 初值的变量，如全局变量 int maxcount=99;</li>
<li>正文 - CPU执行的代码部分，正文 段通常是共享、只读的</li>
</ul>
<h3 id="进程的运行控制"><a href="#进程的运行控制" class="headerlink" title="进程的运行控制"></a>进程的运行控制</h3><h4 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h4><p>设置环境变量的三种方法： </p>
<ul>
<li>putenv - 将环境变量字符串放入环境变量表中</li>
<li>setenv - 将指定环境变量的值设置为参数指定值</li>
<li>unsetenv - 删除指定的环境变量字符串</li>
</ul>
<h4 id="exec系列函数"><a href="#exec系列函数" class="headerlink" title="exec系列函数"></a>exec系列函数</h4><p>进程调用exec系列函数在进程中加载执行另外一个可执行文件<br>exec系列函数替换了当前进程（执行该函数的进程）的正文段、数据段、堆和栈（来源于加载的可执行文件），但并不修改PCB！<br>执行exec系列函数后从加载可执行文件的main函数开始重新执行<br>exec系列函数<strong>并不创建新进程</strong>，所以在调用exec系列函数后其进程ID(uid)并未改变，已经打开的文件描述符不变</p>
<p>execl execle execlp execv execve execvp<br>六个函数开头均为exec，所以称为exec系列函数</p>
<ul>
<li>l：表示list，每个命令行参数都说明为一个单独的参数</li>
<li>v：表示vector，命令行参数放在数组中</li>
<li>e：表示由函数调用者提供环境变量表</li>
<li>p：表示通过环境变量PATH来指定路径，查找可执行文件</li>
</ul>
<h3 id="进程的监测"><a href="#进程的监测" class="headerlink" title="进程的监测"></a>进程的监测</h3><h4 id="终止进程函数"><a href="#终止进程函数" class="headerlink" title="终止进程函数"></a>终止进程函数</h4><p>头文件stdlib.h定义：void  exit( int  status )<br>头文件unistd.h定义：void  _exit (int  status ）<br>调用这两个函数均会正常地终止一个进程<br>调用 <strong>_exit</strong> 函数将会<strong>立即</strong>返回内核<br>调用 <strong>exit</strong> 函数执行一些预先注册的终止处理函数,执行文件I/O操作的善后工作，使得所有缓冲的输出数据被更新到相应的设备,返回内核</p>
<h4 id="获知子进程状态改变"><a href="#获知子进程状态改变" class="headerlink" title="获知子进程状态改变"></a>获知子进程状态改变</h4><ul>
<li>主动获取 - 调用wait或waitpid函数等待子进程状态信息改变，并获取其状态信息</li>
<li>异步通知 - 当一个进程发生特定的状态变化（进程终止、暂停以及恢复）时，内核向其父进程发送SIGCHLD信号，父进程可以选择忽略该信号，也可以对信号进行处理（默认处理方式为忽略该信号）</li>
</ul>
<p>僵尸进程：<br>进程在退出之前会释放进程用户空间的所有资源，但PCB等内核空间资源不会被释放。当父进程调用wait或waitpid函数后，内核将根据情况<strong>关闭</strong>该进程打开的所有文件。而对于已经终止但父进程尚未对其调用wait或waitpid函数的进程（TASK_ZOMBIE状态），称为僵尸进程。</p>
<p>孤儿进程：<br>如果 <strong>父进程在子进程终止之前终止</strong>，则子进程的父进程将变为init进程，保证每个进程都有父进程，由init进程调用wait函数进行善后</p>
<h5 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h5><p>头文件：sys/wait.h<br>功能：获取任意子进程的状态改变信息（如果是终止状态则对子进程进行善后处理）<br><code>pid_t wait(int *statloc); </code><br>参数statloc：用于存储子进程的状态改变信息<br>若成功返回状态信息改变的子进程ID，出错返回-1<br>子进程状态改变信息包含了多种类型的信息，可以通过<strong>系统提供的宏</strong>来快速解析子进程的状态<br>如：<br>| 宏 | 功能说明 |<br>| — | — |<br>| WIFEXITED(statloc) | 当子进程正常终止时该宏为真，对于这种情况可进一步执行WEXITSTATUS(statloc)，获取子进程传递给exit、_exit函数参数的低8位 |<br>| WIFSIGNALED(statloc) | 当子进程异常终止时该宏为真，对于这种情况可进一步执行WTERMSTG(statloc)，获取使子进程终止的信号编号 |<br>| WIFSTOPPED(statloc) | 当子进程暂停时该宏为真，对于这种情况可进一步执行WSTOPSIG(statloc)，获取使子进程暂停的信号编号 |<br>| WIFCONTINUED(statloc) | 若子进程在暂停后已经继续则该宏为真 |</p>
<p>如果一个进程有几个子进程，那么只要有一个子进程状态改变，wait函数就返回</p>
<p>如何才能使用wait函数等待某个<strong>特定</strong>子进程的状态改变？</p>
<ol>
<li>调用wait，然后将其返回的进程ID和所期望的子进程ID进行比较</li>
<li>如果ID不一致，则保存该ID，并循环调用wait函数，直到等到所期望的子进程ID为止</li>
</ol>
<h5 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h5><p>功能：等待某个<strong>特定</strong>子进程状态改变<br><code>pid_t waitpid(pid_t pid, int *statloc, int options);</code><br>参数：</p>
<ul>
<li>pid：pid == -1：等待任意子进程状态改变（同wait）；pid &gt; 0：等待进程ID为pid的子进程状态改变；pid == 0：等待其组ID等于调用进程组ID的任意子进程；pid &lt; -1：等待其组ID等于pid绝对值的任意子进程</li>
<li>statloc：用于存储子进程的状态改变信息</li>
<li>options：可以为0，也可以是以下常量：WNOHANG：如果没有任何已经终止的子进程则马上返回, 函数不等待，此时返回值为0；WUNTRACED：用于跟踪调试<br>成功返回终止子进程ID，失败返回-1</li>
</ul>
<p>waitpid可以实现非阻塞的等待操作，有时希望取得子进程的状态改变信息，但不希望阻塞父进程等待子进程状态改变</p>
<h2 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h2><ol>
<li>在一个已有进程中<strong>创建</strong>一个新线程比创建一个全新进程所需的时间少。</li>
<li><strong>终止</strong>一个线程比终止一个进程花费的时间少。</li>
<li>线程间<strong>切换</strong>比进程间切换花费的时间少。</li>
<li>线程提高了不同的执行程序间<strong>通信</strong>的效率。同一个进程中的线程共享存储空间和文件，它们无需调用内核就可以互相通信。</li>
</ol>
<h3 id="线程的引入"><a href="#线程的引入" class="headerlink" title="线程的引入"></a>线程的引入</h3><p>引入进程是为了使多个程序能够并发执行，以提高资源利用率和系统吞吐量；<br>引入线程是为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性<br> 进程的两个基本属性</p>
<ul>
<li>一个可拥有资源的独立单位</li>
<li>一个可调度和分派的基本单位</li>
</ul>
<p>调度和分派的部分通常称为<strong>线程</strong>或轻型进程，而资源所有权的部分通常称为<strong>进程</strong>。</p>
<h3 id="线程与进程的比较"><a href="#线程与进程的比较" class="headerlink" title="线程与进程的比较"></a>线程与进程的比较</h3><p>从调度性、并发性、系统开销和拥有资源等方面对线程和进程进行比较。<br>（线程必须在某个进程内执行 一个进程可以包含一个线程或多个线程）</p>
<h4 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h4><p>在传统的操作系统中，进程作为拥有资源和独立调度、分派的基本单位。而在引入线程的操作系统中，则把线程作为调度和分派的基本单位，而进程作为资源拥有的基本单位。</p>
<h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可并发执行，使得操作系统具有更好的并发性，从而能更加有效地提高系统资源的利用率和系统的吞吐量。</p>
<h4 id="拥有资源"><a href="#拥有资源" class="headerlink" title="拥有资源"></a>拥有资源</h4><p>一般而言，线程<strong>自己不拥有系统资源</strong>(也有一点必不可少的资源)，但它可以访问其隶属进程的资源，即一个进程的代码段、数据段及所拥有的系统资源，如已打开的文件、I/O 设备等，可以<strong>供</strong>该进程中的所有线程所共享。</p>
<h4 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h4><p>同一进程中的不同线程共享进程的内存空间和资源。<br>同一进程中的<strong>不同线程</strong>的独立性低于<strong>不同进程</strong>。</p>
<h4 id="系统开销"><a href="#系统开销" class="headerlink" title="系统开销"></a>系统开销</h4><p>线程的切换只需要保存和设置少量的寄存器内容，不涉及存储器管理方面的操作。<br>由于一个进程中的多个线程具有相同的地址空间，在同步和通信的实现方面线程也比进程容易。在一些操作系统中，线程的切换、同步和通信都无须操作系统内核的干预。（少）</p>
<h4 id="支持多处理机系统"><a href="#支持多处理机系统" class="headerlink" title="支持多处理机系统"></a>支持多处理机系统</h4><p>一个进程分为多个线程分配到多个处理机上并行执行，可加速进程的完成。</p>
<h3 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h3><ol>
<li>轻型实体<br> 线程自己基本不拥有系统资源，只拥有少量必不可少的资源：TCB，程序计数器、一组寄存器、栈。</li>
<li>独立调度和分派的基本单位<br> 在多线程OS中,线程是独立运行的基本单位,因而也是独立调度和分派的基本单位。</li>
<li>可并发执行<br> 同一进程中的多个线程之间可以并发执行，一个线程可以创建和撤消另一个线程。</li>
<li>共享进程资源<br> 它可与同属一个进程的其它线程共享进程所拥有的全部资源。</li>
</ol>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>同进程一样，线程之间也存在共享资源和相互合作的制约关系，致使线程在运行时也具有间断性。<br>线程运行时有以下3种状态：<br>①<strong>执行</strong>状态:表示线程正获得CPU而运行；<br>②<strong>就绪</strong>状态:表示线程已具备了各种运行条件，一旦获得CPU便可执行；<br>③<strong>阻塞</strong>状态:表示线程在运行中因某事件而受阻，处于暂停执行的状态；</p>
<h3 id="线程的组成"><a href="#线程的组成" class="headerlink" title="线程的组成"></a>线程的组成</h3><p>每个线程有一个TCB结构，即线程控制块，用于保存自己私有的信息，主要由以下部分组成：</p>
<ul>
<li>一个唯一的线程标识符；</li>
<li>一组寄存器 ：包括程序计数器、状态寄存器、通用寄存器的内容；</li>
<li>线程运行状态：用于描述线程正处于何种运行状态；</li>
<li>优先级：描述线程执行的优先程度；</li>
<li>线程专有存储器：用于保存线程自己的局部变量拷贝；</li>
<li>信号屏蔽：对某些信号加以屏蔽；</li>
<li>两个栈指针：核心栈、用户栈。</li>
</ul>
<h3 id="进程线程对比"><a href="#进程线程对比" class="headerlink" title="进程线程对比"></a>进程线程对比</h3><table>
<thead>
<tr>
<th>应用功能</th>
<th>线程</th>
<th>进程</th>
</tr>
</thead>
<tbody><tr>
<td>创建</td>
<td>pthread_create</td>
<td>fork,vfork</td>
</tr>
<tr>
<td>退出</td>
<td>pthread_exit</td>
<td>exit</td>
</tr>
<tr>
<td>等待</td>
<td>pthread_join</td>
<td>wait、waitpid</td>
</tr>
<tr>
<td>取消/终止</td>
<td>pthread_cancel</td>
<td>abort</td>
</tr>
<tr>
<td>读取ID</td>
<td>pthread_self()</td>
<td>getpid()</td>
</tr>
<tr>
<td>同步互斥/通信机制</td>
<td>互斥锁、条件变量、读写锁</td>
<td>无名管道、有名管道、信号、消息队列、信号量、共享内存</td>
</tr>
</tbody></table>
<h3 id="线程间的同步和通信"><a href="#线程间的同步和通信" class="headerlink" title="线程间的同步和通信"></a>线程间的同步和通信</h3><p>▪为使系统中的多线程能有条不紊的运行，系统必须提供用于实现线程间同步和通信的机制。在多线程OS中，通常提供多种同步机制:</p>
<ul>
<li>互斥锁(mutex) - 互斥锁是一种比较简单的、用于实现进程间对资源互斥访问的机制。 由于操作互斥锁的时间和空间开销都较低，因而较适合于高频度使用的关键共享数据和程序段。</li>
<li>条件变量 - 每一个条件变量通常都与一个互斥锁一起使用。 单纯的互斥锁用于短期锁定，主要是用来保证对临界区的互斥进入。而条件变量则用于线程的长期等待， 直至所等待的资源成为可用的。</li>
<li>信号量机制 - 当某线程需利用信号量来实现同一进程中各线程之间的同步时，可调用创建信号量的命令来创建一私用信号量，其数据结构存放在应用程序的地址空间中。</li>
</ul>
<h2 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h2><h3 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h3><p>用户级线程仅存在于用户空间中。对于这种线程的创建、撤消、线程之间的同步与通信等功能，都无须内核来实现。<br>优点：</p>
<ul>
<li>线程切换<strong>不调用内核</strong></li>
<li>调度是应用程序特定的：可以选择<strong>最好的算法</strong></li>
<li>可运行在任何操作系统上（只需要线程库），可以在一个<strong>不支持线程的OS</strong>上实现<br>缺点：</li>
<li>当线程执行一个系统调用时，该线程及其所属进程内的所有线程都会<strong>被阻塞</strong>。</li>
<li>多线程应用<strong>不能利用</strong>多处理机进行多重处理。</li>
</ul>
<h3 id="内核支持线程"><a href="#内核支持线程" class="headerlink" title="内核支持线程"></a>内核支持线程</h3><p>内核支持线程，是在内核的支持下运行的，即无论是用户进程中的线程，还是系统进程中的线程，他们的创建、撤消和切换等，是依靠内核实现的。<br>优点：</p>
<ul>
<li>在多处理器系统中，内核能够<strong>同时</strong>调度同一进程中多个线程并行执行；</li>
<li>如果进程中的一个线程被阻塞了，内核<strong>可以</strong>调度该进程中的其它线程占有处理器运行，也可以运行其它进程中的线程；</li>
<li>内核支持线程具有很小的数据结构和堆栈，线程的切换比较<strong>快</strong>，切换<strong>开销小</strong>；</li>
<li>内核本身也可以采用多线程技术，可以提高系统的执行<strong>速度和效率</strong>。<br>缺点：<br>对于线程切换而言，其模式切换的开销较大 在同一个进程中，从一个线程切换到另一个线程时，需要<strong>从用户态转到内核态再转到用户态</strong>进行，这是因为用户进程的线程在用户态运行，而线程调度和管理是在内核实现的，系统开销较大。</li>
</ul>
<h3 id="组合方式"><a href="#组合方式" class="headerlink" title="组合方式"></a>组合方式</h3><p>用户级线程是在用户空间实现的。所有用户级线程都具有相同的数据结构，它们都运行在一个中间系统上：<br>运行时系统（又称为线程库）<br>内核控制线程又称为轻型进程LWP<br><img src="/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1-3)/1647413220791.png" alt="enter description here"></p>
<h2 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h2><ol>
<li><p>什么是前趋图？为什么要引入前趋图？<br>指一个有向无环图，用于描述进程之间执行的先后顺序</p>
</li>
<li><p>画出前趋图：S1:a=x+y;S2:b=z+1;S3:c=a-b;S4:w=c+1;<br><img src="/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1-3)/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" alt="未命名文件"></p>
</li>
<li><p>为什么要引入进程，会产生什么影响？<br>为了使程序并发的执行，并且可以对并发执行的程序加以描述与控制；使程序可以并发执行</p>
</li>
<li><p>从动态性、并发性和独立性的角度比较进程和程序<br>动态性：进程的实质是进程实体的执行过程，具有生命周期。而程序是静态的一组有序指令集。<br>并发性：进程可以并发执行。程序没有建立PCB不能并发执行。<br>独立性：进程是一个能够独立运行的、独立获得资源的、独立接受调度的基本单位。未建立PCB的程序不能独立参与运行</p>
</li>
<li><p>PCB的作用？为什么说PCB是进程唯一标志<br>PCB是进程实体的一部分，PCB使一个程序成为能够独立运行的基本单位，PCB描述进程的基本情况和活动过程，进而控制和管理进程。操作系统是通过PCB来对进程进行控制和管理的。</p>
</li>
<li><p>进程的三个基本状态转化原因<br>有1就绪状态——执行状态：进程调度<br>执行状态——就绪状态：时间片完成<br>执行状态——阻塞状态：I/O请求<br>阻塞状态——就绪状态：I/O完成</p>
</li>
<li><p>为什么要引入挂起状态，有什么性质？<br>有终端用户需求、父进程请求、负荷调节的需要、操作系统的需要；挂起状态进程静止不能被调度</p>
</li>
<li><p>进程切换时要保存的处理器状态信息有哪些？<br>通用寄存器、指令寄存器、程序状态寄存器、用户栈指针</p>
</li>
<li><p>引起进程创建的主要事件<br>用户登录、作业调度、提供服务、应用请求</p>
</li>
<li><p>引起进程撤销的主要事件<br>正常结束、异常结束（越界错、保护错、非法指令、特权指令错、运行超时、等待超时、算数运算错、I/O故障）、外界干扰（操作员或操作系统干预、父进程请求、因父进程终止而终止）</p>
</li>
<li><p>创建进程时所要完成的主要工作<br>申请空白PCB、为新进程分配资源、初始化PCB、插入就绪队列</p>
</li>
<li><p>引起进程阻塞或被唤醒的主要事件<br>请求共享资源失败、等待某种操作、新数据尚未到达、等待新任务</p>
</li>
<li><p>从调度性、并发性、拥有资源及系统开销方面对比进程与线程<br>调度性：线程作为调度和分派的基本单位，而进程作为资源拥有的基本单位。<br>并发性：均可并发执行。<br>拥有资源：进程是拥有资源的基本单位，线程只拥有必不可少的资源，本身不拥有系统资源，但可以访问隶属资源。<br>系统开销：在创建、撤销和切换进程的开销显著大于线程。</p>
</li>
<li><p>解释用户级线程与内核支持线程<br>用户级线程：用户级线程仅存在于用户空间中。对于这种线程的创建、撤消、线程之间的同步与通信等功能，都无须内核来实现。<br>内核支持线程：内核支持线程，是在内核的支持下运行的，即无论是用户进程中的线程，还是系统进程中的线程，他们的创建、撤消和切换等，是依靠内核实现的。</p>
</li>
</ol>
<h1 id="处理机调度与死锁"><a href="#处理机调度与死锁" class="headerlink" title="处理机调度与死锁"></a>处理机调度与死锁</h1><h2 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h2><ul>
<li>高级调度 - 又称长程调度或作业调度，将外存作业调入内存，创建PCB等，插入就绪队列。用于批处理系统。调度最慢</li>
<li>低级调度 - 又称进程调度或短程调度，决定就绪队列中的那个进程应获得处理机，并将处理机分配给选中的进程。调度最频繁</li>
<li>中级调度 - 又称内存调度，把外存上那些已经具备运行条件的就绪进程重新载入内存。从静止就绪到活动就绪。</li>
</ul>
<h2 id="处理机调度算法的目标"><a href="#处理机调度算法的目标" class="headerlink" title="处理机调度算法的目标"></a>处理机调度算法的目标</h2><h3 id="共同目标："><a href="#共同目标：" class="headerlink" title="共同目标："></a>共同目标：</h3><ul>
<li>资源利用率：使系统处理器和资源尽可能忙碌</li>
<li>公平性：为进程合理分配CPU时间，不会发生饥饿</li>
<li>平衡性：为不同类型进程平衡分配资源</li>
<li>策略强制执行：如安全策略可无条件准确执行</li>
</ul>
<h3 id="批处理系统的目标"><a href="#批处理系统的目标" class="headerlink" title="批处理系统的目标"></a>批处理系统的目标</h3><ul>
<li>平均周转时间短</li>
<li>系统吞吐量高：尽量多地选择短作业运行</li>
<li>处理机利用率高：尽量选择计算量大的作业</li>
</ul>
<h3 id="分时系统的目标"><a href="#分时系统的目标" class="headerlink" title="分时系统的目标"></a>分时系统的目标</h3><ul>
<li>响应时间快</li>
<li>均衡性：指系统响应时间的长短应与用户所请求服务的复杂性相适应。</li>
</ul>
<h3 id="实时系统的目标"><a href="#实时系统的目标" class="headerlink" title="实时系统的目标"></a>实时系统的目标</h3><ul>
<li>截至时间的保证：开始截止时间 完成截止时间 硬实时、软实时</li>
<li>可以预测性：对调度结果的可预见性</li>
</ul>
<h2 id="作业与作业调度"><a href="#作业与作业调度" class="headerlink" title="作业与作业调度"></a>作业与作业调度</h2><ul>
<li>作业 Job：用户提交给系统的一项相对独立的工作。程序+数据+作业说明书</li>
<li>作业步：在作业运行期间，每个作业都必须经过若干个相对独立，又相互关联的顺序加工步骤才能得到结果，每一个加工步骤称为一个作业步，各作业步之间存在着相互联系。</li>
<li>作业流：依次执行的作业步，作业步间非并行的。</li>
</ul>
<h3 id="作业控制块-JCB"><a href="#作业控制块-JCB" class="headerlink" title="作业控制块(JCB)"></a>作业控制块(JCB)</h3><p>作业在系统中存在的标志，保存了系统对作业进行管理和调度的全部信息。<br>通常包含：</p>
<ul>
<li>作业标识</li>
<li>用户名称</li>
<li>用户账号</li>
<li>作业类型(CPU 繁忙型、I/O 繁忙型、批量型、终端型)</li>
<li>作业状态</li>
<li>调度信息(CPU 繁忙型、I/O 繁忙型、批量型、终端型)</li>
<li>资源需求(预计运行时间、要求内存大小、要求 I/O 设备的类型和数量等)</li>
<li>资源使用情况等</li>
</ul>
<h3 id="作业运行的三个阶段和三种状态"><a href="#作业运行的三个阶段和三种状态" class="headerlink" title="作业运行的三个阶段和三种状态"></a>作业运行的三个阶段和三种状态</h3><p>收容阶段：后备状态<br>运行阶段：运行状态<br>完成阶段：完成状态</p>
<h3 id="作业调度的主要任务"><a href="#作业调度的主要任务" class="headerlink" title="作业调度的主要任务"></a>作业调度的主要任务</h3><ul>
<li>接纳多少个作业：太多会影响系统服务质量，如延长周转时间；太少会导致资源利用率和系统吞吐量太低</li>
<li>接纳哪些作业：将哪些作业从外存调入内存，取决于所采用的调度算法</li>
</ul>
<h3 id="先来先服务-FCFS-和短作业优先-SJF-调度算法"><a href="#先来先服务-FCFS-和短作业优先-SJF-调度算法" class="headerlink" title="先来先服务(FCFS)和短作业优先(SJF )调度算法"></a>先来先服务(FCFS)和短作业优先(SJF )调度算法</h3><p>在作业调度中是从后备队列调入内存运行。<br>在进程调度中则是从就绪队列中选出估计运行时间最短的进程分配处理机使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时，再重新调度。</p>
<h4 id="先来先服务："><a href="#先来先服务：" class="headerlink" title="先来先服务："></a>先来先服务：</h4><p>既可用于作业调度，也可用于进程调度。有利于长作业（进程），而不利于短作业（进程）。</p>
<h4 id="短作业-进程-优先调度算法SJ-P-F："><a href="#短作业-进程-优先调度算法SJ-P-F：" class="headerlink" title="短作业(进程)优先调度算法SJ(P)F："></a>短作业(进程)优先调度算法SJ(P)F：</h4><p>是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。<br>对长作业不利，不能保证紧迫性作业(进程)会被及时处理，根据用户所提供的估计执行时间而定不准确。</p>
<h3 id="优先级调度算法和高响应比优先调度算法"><a href="#优先级调度算法和高响应比优先调度算法" class="headerlink" title="优先级调度算法和高响应比优先调度算法"></a>优先级调度算法和高响应比优先调度算法</h3><p>优先级调度算法：<br>外部赋予作业（进程）相应的优先级，例如以作业的紧迫程度作为优先级。<br>选择优先级高的进程投入运行。既可用于作业调度算法，也可用于进程调度。</p>
<p>高响应比优先调度算法：<br>赋予作业动态优先级，优先级随作业等待时间延长而增加，从而使长作业的优先级在等待期间不断增加。<br>响应比Rp：<br><img src="/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1-3)/1647848472429.png" alt="enter description here"><br>算法既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务</p>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="主要任务"><a href="#主要任务" class="headerlink" title="主要任务"></a>主要任务</h3><ul>
<li>保存处理机的现场信息</li>
<li>按某种算法选取进程</li>
<li>把处理机分配给进程<strong>strong text</strong></li>
</ul>
<h3 id="进程调度机制"><a href="#进程调度机制" class="headerlink" title="进程调度机制"></a>进程调度机制</h3><p><img src="/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1-3)/1647853007722.png" alt="enter description here"></p>
<h3 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h3><h4 id="非抢占方式："><a href="#非抢占方式：" class="headerlink" title="非抢占方式："></a>非抢占方式：</h4><p>一旦进程投入运行，除了进程完成或者需要阻塞外，不能剥夺其处理机。<br>采用这种方式时，引起调度的原因可归结为： </p>
<ul>
<li>进程运行完毕或因发生某事件而无法继续运行</li>
<li>因I/O请求而阻塞</li>
<li>因通信或者同步而阻塞</li>
</ul>
<h4 id="抢占方式："><a href="#抢占方式：" class="headerlink" title="抢占方式："></a>抢占方式：</h4><p>允许根据某种原则，暂停正在执行的进程，重新分配处理机。<br>使用抢占式的原因： </p>
<ul>
<li>批处理：防止长进程长期占用CPU，公平</li>
<li>分时：人机交互</li>
<li>实时：紧迫任务的执行<br>主要原则</li>
<li>优先权</li>
<li>短进程优先</li>
<li>时间片原则</li>
</ul>
<h3 id="轮转调度算法-RR"><a href="#轮转调度算法-RR" class="headerlink" title="轮转调度算法(RR)"></a>轮转调度算法(RR)</h3><p>基于时间片轮转<br>原理： FCFS策略+时钟中断+时间片原则<br>时间片太小：利于短作业，但增大调度和上下文切换频率，增大系统开销； 时间片太长：退化为FCFS算法。 时间片合适：略大于一次典型的交互所需的时间，使大多数交互式进程能在一个时间片内完成。<br>当进程的时间片耗尽或运行完毕，系统将CPU分配给队首进程（或新到达紧迫进程）</p>
<h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h3><p>同样分为非抢占式和抢占式<br>对于优先级是的设立还分为静态优先权（简单，但低优先权作业可能长期不被调度）和动态优先权（长短兼顾 缺点：需计算 Rp=(等待时间＋服务时间)/服务时间 ）</p>
<h3 id="多队列调度算法"><a href="#多队列调度算法" class="headerlink" title="多队列调度算法"></a>多队列调度算法</h3><p>针对：不同用户的调度策略需求:实时/分时/批处理混合系统<br>和多CPU单就绪队列的问题:互斥访问导致效率不高<br>解决办法:<br>不同类型或者性质的进程组织在不同的队列中<br>每个CPU和一个队列，分配优化，CPU间队列均衡</p>
<h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><p>设置多个就绪队列，并为各个队列赋予不同的优先级。<br>优先级愈高的队列的进程的执行时间片就愈小。<br>新进程首先进入最高优先级的队列。每个队列采用FCFS算法。<strong>队列中的进程运行一个时间片后未结束则降级排到下一个队列的末尾</strong>。最低优先权队列中的进程则按RR方式运行。<br>按队列优先级调度。只有比队列的优先级高的队列均空时，才运行该队列中的进程。<br>特点：长、短作业兼顾，有较好的响应时间</p>
<h3 id="基于公平原则的调度算法"><a href="#基于公平原则的调度算法" class="headerlink" title="基于公平原则的调度算法"></a>基于公平原则的调度算法</h3><ol>
<li>保证调度算法 - 保证的是绝对运行时间，即启动后在某个时间段内必须获得多少运行时间。 例如N个进程平均分配时间。</li>
<li>公平分享调度算法 - 按照用户数量平均分配时间，而不是进程间平均分配。</li>
</ol>
<h2 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h2><p>实时调度必须满足实时任务对截至时间的要求</p>
<h3 id="实现实时调度的基本条件"><a href="#实现实时调度的基本条件" class="headerlink" title="实现实时调度的基本条件"></a>实现实时调度的基本条件</h3><ul>
<li>就绪时间</li>
<li>开始截止时间和完成截止时间</li>
<li>处理时间</li>
<li>资源要求</li>
<li>优先级</li>
</ul>
<p>单处理机条件下必须保证处理时间与截至时间之比小于1</p>
<h3 id="实时调度算法的分类"><a href="#实时调度算法的分类" class="headerlink" title="实时调度算法的分类"></a>实时调度算法的分类</h3><h4 id="非抢占式"><a href="#非抢占式" class="headerlink" title="非抢占式"></a>非抢占式</h4><p><img src="/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1-3)/1647855224272.png" alt="enter description here"></p>
<ol>
<li>非抢占式轮转调度</li>
<li>非抢占式优先调度</li>
</ol>
<h4 id="抢占式"><a href="#抢占式" class="headerlink" title="抢占式"></a>抢占式</h4><ol>
<li>基于时钟中断的抢占式</li>
<li>立即抢占式</li>
</ol>
<h3 id="EDF最早截至时间算法"><a href="#EDF最早截至时间算法" class="headerlink" title="EDF最早截至时间算法"></a>EDF最早截至时间算法</h3><p>就绪队列按各任务截止时间的早晚排序；具有最早截止时间的任务排在队列的最前面。</p>
<h3 id="LLF最低松弛度优先算法"><a href="#LLF最低松弛度优先算法" class="headerlink" title="LLF最低松弛度优先算法"></a>LLF最低松弛度优先算法</h3><p>松弛度=完成截至时间–剩余运行时间–当前时间<br>按松弛度排序实时任务的就绪队列，松弛度值最小的任务排在队列最前面</p>
<h3 id="优先级倒置"><a href="#优先级倒置" class="headerlink" title="优先级倒置"></a>优先级倒置</h3><p>即高优先级进程(或线程)被低优先级进程(或线程)延迟或阻塞。<br>主要原因可能是较低优先级任务占用临界资源后未释放而切换任务执行<br>解决方法：</p>
<ul>
<li>规定进入临界区后不允许抢占</li>
<li>优先级继承机制(动态优先级)，即占用同样资源的低优先级进程继承需要资源的进程的高优先级</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="资源问题"><a href="#资源问题" class="headerlink" title="资源问题"></a>资源问题</h3><ul>
<li>可重用性资源(打印机)和消耗性资源(消息)</li>
<li>不可抢占性资源(打印机)</li>
</ul>
<h3 id="计算机系统的死锁"><a href="#计算机系统的死锁" class="headerlink" title="计算机系统的死锁"></a>计算机系统的死锁</h3><p>原因：</p>
<ol>
<li>竞争可重用资源、可消耗资源</li>
<li>进程间推进顺序非法。<br><img src="/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1-3)/1647855855262.png" alt="enter description here"></li>
</ol>
<h3 id="定义、必要条件和处理方法"><a href="#定义、必要条件和处理方法" class="headerlink" title="定义、必要条件和处理方法"></a>定义、必要条件和处理方法</h3><p>定义：如果一组进程中的每一个进程<strong>都在等待仅由该组进程中的其他进程才能引发的事件</strong>，那么该组进程是死锁的</p>
<p>四个条件：</p>
<ol>
<li>互斥条件：指进程对所分配到的资源进行排它性使用 。</li>
<li>请求和保持条件：指进程已经保持了至少一个资源，但又提出了新的资源请求 。</li>
<li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链 。</li>
</ol>
<h4 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h4><p>通过<strong>设置某些限制条件</strong>，去破坏产生死锁的四个必要条件中的一个或几个条件，来预防发生死锁。<br>预防死锁使四个必要条件中的第2、3、4条件之一不能成立</p>
<h5 id="破环条件2"><a href="#破环条件2" class="headerlink" title="破环条件2"></a>破环条件2</h5><p>通过：</p>
<ul>
<li>第一种协议<strong>规定开始运行之前，必须一次性申请所需的全部资源</strong></li>
<li>第二种协议规定进程在运行过程中要逐步释放已用资源再请求新资源</li>
<li>*优点**：简单、易于实现且很安全。</li>
<li>*缺点**：资源被严重浪费，使进程延迟运行。</li>
</ul>
<h5 id="破环条件3"><a href="#破环条件3" class="headerlink" title="破环条件3"></a>破环条件3</h5><p>当一个已经保持了某些资源的进程，再提出新的资源请求而<strong>不能立即得到满足</strong>时，必须释放它已经保持了的所有资源。待以后需要时再重新申请<br><strong>缺点</strong>：因反复地申请和释放资源，致使进程执行被无限推迟，延长进程周转时间、增加系统开销、降低吞吐量</p>
<h5 id="破环条件4"><a href="#破环条件4" class="headerlink" title="破环条件4"></a>破环条件4</h5><p>将所有资源按类型进行线性排队，并赋予不同的序号。 所有进程对资源的请求必须严格按照资源序号递增的次序提出<br><strong>优点</strong>：相比前两种提高了资源利用率和系统吞吐量<br><strong>缺点</strong>：各类资源分配的序号必须相对稳定限制了新设备类型的增加；作业使用顺序与系统规定顺序不同造成资源浪费；增加了程序设计难度。</p>
<h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><p>是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。<strong>不会事先设置限制</strong><br>安全状态是指系统能按某种进程顺序，使每个进程都可顺利地完成，称系统处于安全状态。</p>
<h5 id="Dijkstra银行家算法"><a href="#Dijkstra银行家算法" class="headerlink" title="Dijkstra银行家算法"></a>Dijkstra银行家算法</h5><p>可利用资源向量Available<br>最大需求矩阵Max<br>分配矩阵Allocation<br>需求矩阵Need<br>P120</p>
<h4 id="死锁的检测与解除"><a href="#死锁的检测与解除" class="headerlink" title="死锁的检测与解除"></a>死锁的检测与解除</h4><p>检测死锁：通过系统所设置的<strong>检测机构</strong>，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源；<br>解除死锁：当<strong>检测</strong>到系统中<strong>已</strong>发生死锁时，须将进程从死锁状态中<strong>解脱出来</strong>。常用的实施方法是撤消或挂起一些进程。<br><strong>配套使用</strong></p>
<h5 id="检测："><a href="#检测：" class="headerlink" title="检测："></a>检测：</h5><p>系统必须保存有关资源的请求和分配信息，根据信息通过<strong>资源分配图</strong>或<strong>死锁定理</strong>的方法检测死锁</p>
<h5 id="解除："><a href="#解除：" class="headerlink" title="解除："></a>解除：</h5><p>两种常用方法：抢占资源(使死锁进程抢占其它进程资源以完成进程解除死锁)、终止进程(终止或撤销死锁进程)<br>其中终止方法可终止所有死锁进程，更好是按付出代价最小算法逐个解除</p>
<h6 id="付出代价最小算法"><a href="#付出代价最小算法" class="headerlink" title="付出代价最小算法"></a>付出代价最小算法</h6><ul>
<li><p>一种找到付出代价最小的终止顺序，但成本高的算法：</p>
<ol>
<li> 先从死锁进程组中取出一个，形成第一层终止，若有n个死锁进程，则有n个第一层。</li>
<li> 再从n个第一层中取一个，形成第二层终止，每个第一层又有n-1个第二层终止。</li>
<li> 如此循环，直到解除死锁，将各层的总代价计算，得到最小的终止顺序。<br>理解为从最低代价开始依次找到导致死锁的最低代价进程</li>
</ol>
</li>
<li><p>另一种比较有效的算法：</p>
<ol>
<li> 找到死锁进程组中，终止代价最小的，将其从死锁进程组中删去。</li>
<li> 再从新的死锁进程组中，找到终止代价最小的，删去。</li>
<li> 如此循环，直到解除死锁。<br>理解为一直解除最低代价进程(不判断此时死锁是否由它导致)直到解除死锁</li>
</ol>
</li>
</ul>
<h2 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h2><p>1、假设一个多级反馈队列的实现共有4级，各个队列的时间片长度是1、2、4、6秒，已知当前仅在第一级队列上有一个执行时长为10秒的进程O，在两秒后将有一个执行时长为8秒的任务A到达，请算出任务A的周转时间。<br>1:10-1=9O<br>2<br>4<br>6</p>
<p>1<br>2:9-1=8O<br>4<br>6<br>任务A到达<br>1:8-1=7A<br>2:<br>4:8O<br>6</p>
<p>1:<br>2:7A<br>4:8O-4=4O<br>6</p>
<p>1:<br>2:7A-2=5A<br>4:<br>6:4O</p>
<p>1:<br>2:<br>4:5A<br>6:4O-4=0O完成</p>
<p>1:<br>2:<br>4:5A-4=1A<br>6:</p>
<p>1:<br>2:<br>4:<br>6:1A-1=0A完成</p>
<p>所以答案等于1+4+2+4+4+1=16s</p>
<p>2、简述死锁的必要条件，以及预防死锁方法与必要条件的关系。<br>四个条件：</p>
<ol>
<li>互斥条件：指进程对所分配到的资源进行排它性使用 。</li>
<li>请求和保持条件：指进程已经保持了至少一个资源，但又提出了新的资源请求 。</li>
<li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链</li>
</ol>
<p>预防死锁通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来预防发生死锁。预防死锁使四个必要条件中的第2、3、4条件之一不能成立：</p>
<p>破环条件2通过：第一种协议规定开始运行之前，必须一次性申请所需的全部资源<br> 第二种协议规定进程在运行过程中要逐步释放已用资源再请求新资源；</p>
<p>破环条件3当一个已经保持了某些资源的进程，再提出新的资源请求而不能立即得到满足时，必须释放它已经保持了的所有资源。待以后需要时再重新申请；</p>
<p>破环条件4将所有资源按类型进行线性排队，并赋予不同的序号。 所有进程对资源的请求必须严格按照资源序号递增的次序提出。</p>
<p>3、在银行家算法中，若出现下述资源分配情况，试问：<br>| Process | Allocation | Need__  | Available |<br>|—|—|—|—|<br>| P0 | 0 0 3 2 | 0 0 1 2 | 1 6 2 2 |<br>| P1 | 1 0 0 0 | 1 7 5 0 |<br>| P2 | 1 3 5 4 | 2 3 5 6 |<br>| P3 | 0 3 3 2 | 0 6 5 2 |<br>| P4 | 0 0 1 4 | 0 6 5 6 |</p>
<p>（1）该状态是否安全？<br>安全，先执行P0后按P3、P4、P1、P2顺序即可完成全部进程<br>（2）若进程 P2 提出请求 Request（1，2，2，2）后，系统能否将资源分配<br>给它？<br>能，可按P2、P0、P3、P4、P1执行完成</p>

      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/01/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/01/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">网络概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-01 17:48:36" itemprop="dateCreated datePublished" datetime="2022-03-01T17:48:36+08:00">2022-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-09 18:51:07" itemprop="dateModified" datetime="2022-03-09T18:51:07+08:00">2022-03-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什么是计算机网络"><a href="#什么是计算机网络" class="headerlink" title="什么是计算机网络"></a>什么是计算机网络</h1><ul>
<li>从<strong>网络实体视角</strong>观察：计算机终端设备、数据转发设备、数据传输链路</li>
<li>从<strong>网络架构视角</strong>观察：网络边缘、接入网、网络核心</li>
</ul>
<h2 id="网络核心两大功能"><a href="#网络核心两大功能" class="headerlink" title="网络核心两大功能"></a>网络核心两大功能</h2><ul>
<li>路由(routing)：决定转发策略（转发路径）</li>
<li>转发(forwarding)：作出转发行为</li>
</ul>
<h1 id="计算机网络分类"><a href="#计算机网络分类" class="headerlink" title="计算机网络分类"></a>计算机网络分类</h1><h2 id="按覆盖区域"><a href="#按覆盖区域" class="headerlink" title="按覆盖区域"></a>按覆盖区域</h2><p>局域网、园区网、城域网、广域网、空天网</p>
<h2 id="按应用场景"><a href="#按应用场景" class="headerlink" title="按应用场景"></a>按应用场景</h2><p>家庭网络、公司/机构网络、无线移动网络、运营商网络、天地一体化信息网络</p>
<h1 id="什么是互联网-internet"><a href="#什么是互联网-internet" class="headerlink" title="什么是互联网(internet)"></a>什么是互联网(internet)</h1><h2 id="从服务视角"><a href="#从服务视角" class="headerlink" title="从服务视角"></a>从服务视角</h2><ul>
<li>作为基础设施为应用提供服务</li>
<li>以提供编程接口方式提供服务</li>
</ul>
<h2 id="从结构角度"><a href="#从结构角度" class="headerlink" title="从结构角度"></a>从结构角度</h2><p>互联网：网络的网络<br>即：多级ISP分层网络<br><img src="/2022/03/01/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/1646125882244.png" alt="enter description here"></p>
<h1 id="网络数据传输方式"><a href="#网络数据传输方式" class="headerlink" title="网络数据传输方式"></a>网络数据传输方式</h1><ul>
<li>电路交换</li>
<li>分组交换<br>（P15~P22）<br>共同特点：<br>  多路复用</li>
</ul>
<p>不同之处：<br>    电路交换：预留带宽、独占资源<br>    分组交换：存储 转发、数据包形式(共享带宽、竞争资源)</p>
<h1 id="网络性能评价指标"><a href="#网络性能评价指标" class="headerlink" title="网络性能评价指标"></a>网络性能评价指标</h1><p>延迟、丢包、带宽、吞吐量<br>流量强度<img src="/2022/03/01/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/1646126512221.png" alt="流量强调计算"><br>瓶颈链路（水桶短板）如：<img src="/2022/03/01/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/1646126837274.png" alt="enter description here"></p>
<h2 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h2><ul>
<li>节点处理延迟</li>
<li>排队延迟</li>
<li>传输延迟(发送延迟)</li>
<li>传播延迟<br>（P25~P27）</li>
</ul>
<h2 id="丢包"><a href="#丢包" class="headerlink" title="丢包"></a>丢包</h2><ul>
<li>排队缓冲队列溢出</li>
<li>物理链路截断</li>
</ul>
<h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p>单位bps<br>即物理链路理论上能承载的最大吞吐量</p>
<h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>单位bps/pps</p>
<ul>
<li>瞬时吞吐量(信息传输速率)</li>
<li>平均吞吐量(信息传输速度)</li>
</ul>
<h1 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h1><p>通信需要规则，协议建立规则（信息内容组织格式、信息交互顺序逻辑、信息收发处理逻辑）<br>互联网协议由Internet标准化组织定义<br>如：</p>
<ul>
<li>IEEE 电气与电子工程师协会（Institute of Electrical and Electronics Engineers）<pre><code>的IEEE 802.3(局域网标准)等
</code></pre>
</li>
<li>IETF 国际互联网工程任务组（The Internet Engineering Task Force)<pre><code>RFC 791(IP)
</code></pre>
</li>
</ul>
<h1 id="网络协议分层参考模型"><a href="#网络协议分层参考模型" class="headerlink" title="网络协议分层参考模型"></a>网络协议分层参考模型</h1><p><img src="/2022/03/01/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/1646127830631.png" alt="enter description here"></p>
<h2 id="为什么要分层"><a href="#为什么要分层" class="headerlink" title="为什么要分层"></a>为什么要分层</h2><ul>
<li>处理复杂系统明确结构关系</li>
<li>模块化便于系统维护和更新</li>
<li>网络本身具有复杂异构性</li>
<li>网络技术在高速更新迭代</li>
</ul>
<h2 id="模型的价值"><a href="#模型的价值" class="headerlink" title="模型的价值"></a>模型的价值</h2><ul>
<li>网络体系结构清晰,各个层级功能明确</li>
<li>层次之间接口明确,方便层内技术演进</li>
<li>层次内部协议统一,支持厂商互联互通</li>
</ul>
<h1 id="攻击威胁下的网络"><a href="#攻击威胁下的网络" class="headerlink" title="攻击威胁下的网络"></a>攻击威胁下的网络</h1><h2 id="常见攻击方式"><a href="#常见攻击方式" class="headerlink" title="常见攻击方式"></a>常见攻击方式</h2><ul>
<li>植入恶意软件（专门用于 损坏、破坏、窃取数据、主机或网络 或 对数据、主机或网络进行非法操作 的代码或软件，如病毒、蠕虫、特洛伊木马）</li>
<li>攻击服务器和网络基础设施</li>
<li>嗅探分组</li>
<li>伪装</li>
<li>修改或删除报文</li>
</ul>
<p>更多见第八章</p>

      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/28/%E5%A4%A7%E4%BA%8C%E4%B8%8A%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/28/%E5%A4%A7%E4%BA%8C%E4%B8%8A%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">计算机操作系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-28 16:58:28" itemprop="dateCreated datePublished" datetime="2022-02-28T16:58:28+08:00">2022-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-01 14:28:02" itemprop="dateModified" datetime="2022-03-01T14:28:02+08:00">2022-03-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="操作系统引论"><a href="#操作系统引论" class="headerlink" title="操作系统引论"></a>操作系统引论</h1><h2 id="目标和作用"><a href="#目标和作用" class="headerlink" title="目标和作用"></a>目标和作用</h2><p>目标：方便性、有效性、可扩展性、开放性<br>作用</p>
<ol>
<li>作为用户与计算机硬件系统之间的接口</li>
<li>操作系统引论作为计算机系统资源的管理者</li>
<li>实现了对计算机资源的抽象</li>
</ol>
<h2 id="发展过程"><a href="#发展过程" class="headerlink" title="发展过程"></a>发展过程</h2><p>人工操作方式、脱机输入输出方式<br>单批道处理系统<br>多批道处理系统（资源利用率高，系统吞吐量大，平均周转时间长，无交互能力）<br>分时系统（多路性、独立性、及时性、交互性）<br>实时系统（多路性、独立性、及时性、交互性、可靠性）<br>微机操作系统（单用户多用户）</p>
<h2 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h2><ul>
<li>并发<pre><code>**并发性**是指两个或多个事件在同一时间间隔内发生，而**并行性**是指两个或多个事件在同一时刻发生。
</code></pre>
</li>
<li>共享<pre><code>**资源共享**是指系统中的资源可供内存中多个并发执行的进程共同使用。一段时间内只允许一个进程访问的资源称为**临界资源**一个进程访问结束并释放系统资源后才允许另一进程对该资源访问的方式称为**互斥访问**
</code></pre>
</li>
<li>虚拟<pre><code>通过**空分复用**或**时分复用**技术将一条物理信道变为若干条逻辑信道的技术
</code></pre>
</li>
<li>异步<pre><code>进程的执行本身具有异步性（不可预知完成时间与顺序）所以要设计同步机制
</code></pre>
</li>
</ul>
<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><h3 id="处理机管理功能"><a href="#处理机管理功能" class="headerlink" title="处理机管理功能"></a>处理机管理功能</h3><ul>
<li>进程控制</li>
<li>进程同步</li>
<li>进程通信</li>
<li>调度</li>
</ul>
<h3 id="存储器管理功能"><a href="#存储器管理功能" class="headerlink" title="存储器管理功能"></a>存储器管理功能</h3><ul>
<li>内存分配</li>
<li>内存保护</li>
<li>地址映射</li>
<li>内存扩充</li>
</ul>
<h3 id="I-O-设备管理功能"><a href="#I-O-设备管理功能" class="headerlink" title="(I/O)设备管理功能"></a>(I/O)设备管理功能</h3><ul>
<li>缓冲管理</li>
<li>设备分配</li>
<li>设备处理</li>
</ul>
<h3 id="文件管理功能"><a href="#文件管理功能" class="headerlink" title="文件管理功能"></a>文件管理功能</h3><ul>
<li>文件存储空间管理</li>
<li>目录管理</li>
<li>文件读写管理与保护</li>
</ul>
<h3 id="操作系统与用户之间的接口"><a href="#操作系统与用户之间的接口" class="headerlink" title="操作系统与用户之间的接口"></a>操作系统与用户之间的接口</h3><ul>
<li>用户接口（联机用户接口、脱机用户接口、程序接口）</li>
<li>程序接口</li>
</ul>
<h2 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h2><h3 id="无结构"><a href="#无结构" class="headerlink" title="无结构"></a>无结构</h3><p>程序紧凑，高效利用内存<br>但是随着系统的不断扩大，所设计出的操作系统就会变得既庞大又杂乱。<br>一方面会使编制的程序错误很多给调试工作带来困难<br>另一方面也使程序难以阅读和理解，增加了维护负担</p>
<h3 id="模块化结构"><a href="#模块化结构" class="headerlink" title="模块化结构"></a>模块化结构</h3><p>模块化OS由程序设计的模块化设计思想演变而来<br>衡量模块化设计的两个标准：内聚性、耦合性<br>优点：</p>
<ol>
<li>提高OS设计的正确性、可理解性和可维护性。</li>
<li>增强OS的可适应性。</li>
<li>加速OS开发过程。<br>问题：</li>
<li>最初模块接口规定难以满足实际需求</li>
<li>无序设计</li>
</ol>
<h3 id="分层式结构"><a href="#分层式结构" class="headerlink" title="分层式结构"></a>分层式结构</h3><p>将模块接口法中对模块的设计顺序由无序变为有序，自底向上分层设计<br>优点：</p>
<ol>
<li>易保证系统的正确性</li>
<li>易扩充和易维护性<br>缺点：</li>
<li>系统效率降低：单向依赖的层次使得必须建立层次之间的通信机制增加通信开销<h3 id="文件管理功能-文件管理功能"><a href="#文件管理功能-文件管理功能" class="headerlink" title="文件管理功能### 文件管理功能"></a>文件管理功能### 文件管理功能</h3></li>
</ol>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>1、设计现代OS的主要目标是什么？<br>方便性、有效性、可扩展性、开放性</p>
<p>6、试说明推动分时系统形成和发展的主要动力是什么。<br>满足人机交互需求，实现共享主机</p>
<p>8、为什么要引入实时操作系统？<br>更好的满足实时控制实时信息处理领域对时间控制的需求</p>
<p>10、试从交互性、及时性以及可靠性方面将分时系统与实时系统进行比较。<br>交互性：实时系统的交互性不像分时系统为终端用户提供数据和资源共享服务，而限于特定专用服务程序<br>及时性：分时系统的响应时间间隔通常为人们所能接受的1~3秒，实时系统由截至时间所确定通常为秒级到毫秒级<br>可靠性：实时系统相比分时系统要求更高的可靠性，所以采取多级容错措施保障系统的安全性</p>
<p>11、OS有几大特征？最基本的特征是什么？<br>并发性、共享性、虚拟性、异步性；并发性最基本</p>
<p>15、处理机管理有哪些主要功能？其主要任务是什么？<br>进程控制、进程同步、进程通信、调度<br>创建进程结束进程控制正在运行的进程、使多个进程有序同步进行、交换进程任务的信息、选择作业分配资源运行的作业调度和选择进程分配处理器设置现场执行的进程调度</p>
<p>16、存储器有哪些主要功能？其主要任务是什么？<br>内存分配、内存保护、地址映射、内存扩充<br>为程序分配内存空间、确保程序运行空间不干扰、将逻辑地址映射为物理地址、实现调用置换等功能</p>
<p>17、设备管理有哪些主要功能？其主要任务是什么？<br>缓冲管理、设备分配、设备处理<br>完成用户IO请求分配所需IO设备执行IO操作、提高CPU和IO设备的利用率提高IO速度方便用户使用</p>
<p>18、文件管理有哪些主要功能？其主要任务是什么？<br>文件存储空间管理、目录管理、文件读写管理与保护<br>分配外存空间提高外存利用率、为文件建立目录加以有效组织、根据用户请求读写外存数据、防止文件被非法窃取和受到破坏保障文件安全性#</p>

      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/28/%E7%BD%91%E7%BB%9C/ITN11-13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/28/%E7%BD%91%E7%BB%9C/ITN11-13/" class="post-title-link" itemprop="url">ITN 11-13</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-28 16:54:56 / 修改时间：16:56:25" itemprop="dateCreated datePublished" datetime="2022-02-28T16:54:56+08:00">2022-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="IPv4编址"><a href="#IPv4编址" class="headerlink" title="IPv4编址"></a>IPv4编址</h1><h2 id="地址结构"><a href="#地址结构" class="headerlink" title="地址结构"></a>地址结构</h2><p>IPv4 地址为32位分层地址，由网络部分和主机部分两个部分组成。<br>IPv4 地址 - 这是主机的唯一 IPv4 地址。<br>子网掩码 - 用于标识 IPv4 地址的网络部分/主机部分。</p>
<ul>
<li>  <strong>IPv4 主机地址 (例192.168.10.10)</strong> -主机的 IPv4 地址，采用点分十进制和二进制格式。除了根据掩码的主机位全0位（这将是网络地址）或全1位（这将是广播地址）之外，主机地址在主机部分可以有任何位的组合。<strong>注</strong>IPv4 将 <strong>224.0.0.0 到 239.255.255.255</strong> 的地址保留为组播范围（不可作为主机地址）。</li>
<li>  <strong>子网掩码 (例255.255.255.0)</strong> -主机的子网掩码，采用点分十进制和二进制格式。</li>
<li>  <strong>网络地址 (例192.168.10.0)</strong> -IPv4地址和子网掩码之间的逻辑AND运算产生一个点分十进制和二进制格式的IPv4网络地址。<br>例中，主机地址 192.168.10.10 与子网掩码 255.255.255.0 (/24) 之间的 AND运算会产生 IPv4 网络地址为192.168.10.0/24。<br>子网掩码与IP地址相结合用于确定设备属于哪个子网</li>
</ul>
<h2 id="IPv4-单播、广播和组播"><a href="#IPv4-单播、广播和组播" class="headerlink" title="IPv4 单播、广播和组播"></a>IPv4 单播、广播和组播</h2><h3 id="单播"><a href="#单播" class="headerlink" title="单播"></a>单播</h3><p>单播传输是指在一对一通信中，一个设备向另一个设备发送消息。<br>IPv4 单播主机地址的地址范围是 1.1.1.1到 223.255.255.255。不过，此范围中的很多地址被留作特殊用途。这些特殊用途的地址将在本模块后续部分讨论。</p>
<h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>广播播传输是指设备在一对多通信中，向网络上的所有设备发送消息。<br>广播数据包以32个1位或主机部分全部为 1 的地址作为目的 IP地址。<br>除了 255.255.255.255 的广播地址外，每个网络还有一个广播 IPv4 地址。这个地址称为定向广播，它使用网络范围内的最大地址，即所有主机位全部为 1 的地址。例如，网络192.168.1.0/24的定向广播地址是192.168.1.255。</p>
<h3 id="组播"><a href="#组播" class="headerlink" title="组播"></a>组播</h3><p>主机通过组播传输可以向所属组播组中的选定主机组发送一个数据包，从而减少了流量。<br>组播数据包是一个目的IP地址为组播地址的数据包。IPv4 将 <strong>224.0.0.0 到 239.255.255.255</strong> 的地址保留为组播范围。<br>接收特定组播数据包的主机称为组播客户端。组播客户端使用客户端程序请求的服务来加入组播组。<br>每个组播组由一个 IPv4 组播目的地址代表。当 IPv4 主机加入组播组后，该主机既要处理目的地址为此组播地址的数据包，也要处理发往其唯一单播地址的数据包。</p>
<h2 id="IPv4-地址的分类"><a href="#IPv4-地址的分类" class="headerlink" title="IPv4 地址的分类"></a>IPv4 地址的分类</h2><p>公有 IPv4 地址是能在 ISP（互联网运营商）路由器之间全局路由的地址。但是，并非所有可用的 IPv4 地址都可用于互联网。大多数组织使用称为私有地址的地址块向内部主机分配 IPv4 地址。<br>由于 IPv4 地址空间耗尽，引入了私有 IPv4 地址。私有 IPv4 地址并不是唯一的，可以在任何网络内部使用它。<br>| <strong>网络地址和前缀</strong> | <strong>RFC 1918 私有地址范围</strong> |<br>| — | — |<br>| 10.0.0.0/8 | 10.0.0.0 - 10.255.255.255 |<br>| 172.16.0.0/12 | 172.16.0.0 - 172.31.255.255 |<br>| 192.168.0.0/16 | 192.168.0.0 - 192.168.255.255 |</p>
<h2 id="私有-IPv4-地址和网络地址转换-NAT"><a href="#私有-IPv4-地址和网络地址转换-NAT" class="headerlink" title="私有 IPv4 地址和网络地址转换 (NAT)"></a>私有 IPv4 地址和网络地址转换 (NAT)</h2><p>在 ISP（Internet Service Provider 互联网服务提供商）可以转发此数据包之前，它必须使用网络地址转换 (NAT) 将源 IPv4 地址（即私有地址）转换为公有 IPv4 地址。NAT用于转换私有和公有 IPv4 地址。这通常是在将内部网络连接到 ISP 网络的路由器上完成。在路由到互联网之前，组织内部网中的私有 IPv4 地址将被转换为公有 IPv4 地址。</p>
<h2 id="专用-IPv4-地址"><a href="#专用-IPv4-地址" class="headerlink" title="专用 IPv4 地址"></a>专用 IPv4 地址</h2><p>一些地址，比如网络地址和广播地址不能分配给主机。还有些特殊地址可以分配给主机，但这些主机在网络内的交互方式却受到限制。</p>
<h3 id="环回地址"><a href="#环回地址" class="headerlink" title="环回地址"></a>环回地址</h3><p>环回地址（127.0.0.0 /8 或 127.0.0.1 到 127.255.255.254）通常仅被标识为127.0.0.1，主机使用这些特殊地址将流量指向其自身。</p>
<h3 id="本地链路地址"><a href="#本地链路地址" class="headerlink" title="本地链路地址"></a>本地链路地址</h3><p>本地链路地址（169.254.0.0 /16 或 169.254.0.1 至 169.254.255.254）通常称为自动私有 IP 编址 (APIPA) 地址或自分配地址。 当没有可用的DHCP服务器时，Windows DHCP客户端使用它们进行自我配置。本地链路地址可以用于点对点连接，但通常不用于此目的。</p>
<h3 id="IP-地址的分配"><a href="#IP-地址的分配" class="headerlink" title="IP 地址的分配"></a>IP 地址的分配</h3><p>IPv4 和 IPv6 地址是通过互联网编号指派机构 (IANA) 管理的。IANA 管理并向地区性互联网注册机构 (RIR) 分配 IP 地址块。</p>
<ul>
<li>  <strong>AfriNIC</strong> (非洲网络信息中心) - 非洲地区</li>
<li>  <strong>APNIC</strong> (亚太网络信息中心) - 亚太地区</li>
<li>  <strong>ARIN</strong> (美洲互联网号码注册管理机构) - 北美地区</li>
<li>  <strong>LACNIC</strong> (拉丁美洲及加勒比互联网地址注册管理机构) - 拉丁美洲和部分加勒比海岛屿</li>
<li>  <strong>RIPE NCC</strong> (欧洲 IP 地址注册中心) - 欧洲、中东和中亚<br>RIR 的职责是向 ISP 分配 IP 地址，而 ISP 将向组织和更小的 ISP 提供 IPv4 地址块。根据 RIR 的政策规定，组织也可直接从 RIR 获取地址。</li>
</ul>
<h2 id="网络分段"><a href="#网络分段" class="headerlink" title="网络分段"></a>网络分段</h2><h3 id="广播域和分段"><a href="#广播域和分段" class="headerlink" title="广播域和分段"></a>广播域和分段</h3><p>在以太网局域网中，设备使用广播和地址解析协议 (ARP) 来定位其他设备。地址解析协议 (ARP)将第 2 层广播发送到本地网络上的已知 IPv4 地址，以发现相关 MAC 地址。以太网局域网上的设备还可以使用服务定位其他设备。主机通常需要使用动态主机配置协议 (DHCP) 来获取 IPv4 地址配置，这会发送本地网络上的广播来定位 DHCP 服务器。<br>交换机会将广播传播到所有接口，接收它的接口除外。<br>路由器不传播广播。<br>因此，每个路由器接口都连接了一个广播域，而广播只能在特定广播域内传播。</p>
<h3 id="大型广播域存在的问题与子网划分"><a href="#大型广播域存在的问题与子网划分" class="headerlink" title="大型广播域存在的问题与子网划分"></a>大型广播域存在的问题与子网划分</h3><p>大型广播域是连接很多主机的网络。大型广播域的一个问题是这些主机会生成太多广播，这会对网络造成不良影响。在图中，局域网1 连接了 400 个用户，可能会产生过量的广播流量。这会导致<strong>网络操作速度缓慢</strong>，因为它会导致大量的流量，而<strong>设备操作变慢</strong>是因为设备必须接受和处理每个广播数据包。</p>
<p>解决方案是使用称为<strong>子网划分</strong>的过程缩减网络的规模以创建更小的广播域。这些较小的网络空间通常称为“子网”。<br>子网划分可以降低整体网络流量并改善网络性能。它也能让管理员实施安全策略，例如哪些子网允许或不允许进行通信。另一个原因是，它减少了由于错误配置、硬件/软件问题或恶意意图而受到异常广播流量影响的设备数量。</p>
<h3 id="IPv4-网络的子网"><a href="#IPv4-网络的子网" class="headerlink" title="IPv4 网络的子网"></a>IPv4 网络的子网</h3><p>创建 IPv4 子网时会将一个或多个主机位作为网络位。具体做法是延长子网掩码，从地址的主机部分借用若干位来增加网络位。借用的主机位越多，可以定义的子网也就越多。为了增加子网数量而借用的位越多，每个子网的主机数量就越少。</p>
<h2 id="VLSM-Variable-Length-Subnetwork-Mask-可变长子网掩码"><a href="#VLSM-Variable-Length-Subnetwork-Mask-可变长子网掩码" class="headerlink" title="VLSM(Variable Length Subnetwork Mask 可变长子网掩码)"></a>VLSM(Variable Length Subnetwork Mask 可变长子网掩码)</h2><p>并不是您创建的每个子网都需要这么多主机，这会导致许多IPv4地址未被使用。也许您需要一个包含更多主机的子网。这就是开发可变长子网掩码 (VLSM) 的原因。<br><img src="/2022/02/28/%E7%BD%91%E7%BB%9C/ITN11-13/1645543803092.png"><br>所有子网都使用相同的子网掩码。这意味着每个子网有相同数量的可用主机地址。如图左边所示，传统子网划分可以创建大小相等的子网。传统方案中每个子网都使用相同的子网掩码。如图右边所示，VLSM 使网络空间能够分为大小不等的部分。使用 VLSM，子网掩码将根据特定子网所借用的位数而变化，从而成为 VLSM 的“变量”部分。<br>使用 VLSM 子网，可以为 LAN 和路由器之间网段提供地址，而不产生不必要浪费。</p>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p><img src="/2022/02/28/%E7%BD%91%E7%BB%9C/ITN11-13/1645547232646.png"><br>n=子网掩码-网络掩码<br>2^n=子网数<br>2^(32-网络掩码-n)-2=主机数<br>子网数*(主机数+2)=2^(32-网络掩码)<br>例：<br>网络管理员将 192.168.10.0/24 网络划分成带 /26 子网掩码的子网。会创建4个相同大小的子网，每个子网可有62台主机<br>2=子网掩码-网络掩码=26-24<br>2^2=子网数=4<br>2^(32-网络掩码-n)-2=2^(8-2)-2=主机数=62<br>子网数*(主机数+2)=4*(62+2)=2^(32-网络掩码)=2^(32-24)</p>
<p>减二因为最低位(后面全是0)用于表示主机号，最高位(后面全是1)用于表示广播地址</p>
<p>DMZ：Demilitarized Zone 隔离区</p>
<h1 id="IPv6编址"><a href="#IPv6编址" class="headerlink" title="IPv6编址"></a>IPv6编址</h1><p>IPv6 旨在接替 IPv4。IPv6 拥有更大的 128 位地址空间，提供 340 涧（即，340后面有36个0）个不确定地址。IETF 已经创建了各种协议和工具来协助网络管理员将网络迁移到 IPv6。迁移技术可分为三类：</p>
<ul>
<li><strong>双堆栈</strong>-双堆栈允许 IPv4 和 IPv6 在同一网段上共存。双堆栈设备同时运行 IPv4 和 IPv6 协议栈。称为原生 IPv6</li>
<li><strong>隧道</strong>-隧道是一种通过 IPv4 网络传输 IPv6 数据包的方法。</li>
<li><strong>转换</strong>-网络地址转换 64 (NAT64) 允许支持 IPv6 的设备与支持 IPv4 的设备使用类似于 IPv4 中 NAT 的转换技术进行通信。IPv6 数据包被转换为 IPv4 数据包，IPv4 数据包被转换为 IPv6 数据包。</li>
</ul>
<h2 id="IPv6-地址表示方法"><a href="#IPv6-地址表示方法" class="headerlink" title="IPv6 地址表示方法"></a>IPv6 地址表示方法</h2><p>书写 IPv6 地址的首选格式为 x:x:x:x:x:x:x:x，每个“x”均包括四个十六进制值。</p>
<ul>
<li>第一条有助于缩短 IPv6 地址记法的规则是省略十六进制数中的所有前导 0（零）</li>
<li>第二条有助于缩短 IPv6 地址记法的规则是使用双冒号 (::) 替换任何由<strong>一个或多个</strong>全由 0 组成的16 位十六进制数组成的<strong>连续</strong>字符串</li>
<li>双冒号 (::) 仅可在每个地址中<strong>使用一次</strong>，否则可能会得出一个以上的地址。</li>
</ul>
<h2 id="IPv6-地址类型"><a href="#IPv6-地址类型" class="headerlink" title="IPv6 地址类型"></a>IPv6 地址类型</h2><h3 id="IPv6-地址三大类"><a href="#IPv6-地址三大类" class="headerlink" title="IPv6 地址三大类"></a>IPv6 地址三大类</h3><ul>
<li>  <strong>单播</strong> - IPv6 单播地址用于唯一标识支持 IPv6 的设备上的接口。</li>
<li>  <strong>组播</strong> - IPv6 组播地址用于将单个 IPv6 数据包发送到多个目的地。</li>
<li>  <strong>任播</strong> -IPv6 任播地址是可分配到多个设备的 IPv6 任播地址。发送至任播地址的数据包会被路由到最近的拥有该地址的设备。<br>与 IPv4 不同，IPv6 没有广播地址。但是，IPv6 具有 IPv6 全节点组播地址，这在本质上与广播地址的效果相同。</li>
</ul>
<h3 id="IPv6-前缀长度"><a href="#IPv6-前缀长度" class="headerlink" title="IPv6 前缀长度"></a>IPv6 前缀长度</h3><p>在 IPv4 中，/24 称为前缀。在 IPv6 中，它被称为前缀长度。IPv6 不使用点分十进制子网掩码记法(如255.255.255.0)。与IPv4一样，前缀长度以斜线记法表示，用于表示 IPv6 地址的网络部分。<br>强烈建议对大多数网络使用 64 位接口 ID。这是因为无状态地址自动配置(SLAAC)使用64位作为接口ID。它还使子网划分更易于创建和管理。</p>
<h3 id="IPv6-单播地址"><a href="#IPv6-单播地址" class="headerlink" title="IPv6 单播地址"></a>IPv6 单播地址</h3><p><img src="/2022/02/28/%E7%BD%91%E7%BB%9C/ITN11-13/1645606597498.png"><br>IPv6地址通常有两个单播地址:</p>
<ul>
<li>  <strong>全局单播地址(GUA)</strong> - 这类似于公有 IPv4 地址。这些地址具有全局唯一性，是互联网可路由的地址。GUA可静态配置或动态分配</li>
<li>  <strong>链路本地地址 (LLA)</strong> -这对于每个支持ipv6的设备都是必需的。LLA用于与同一链路中的其他设备通信。在 IPv6 中，术语“链路”是指子网。LLA仅限于单个链路。它们的唯一性仅在该链路上得到保证，因为它们在该链路之外不具有可路由性。换句话说，路由器不会转发具有本地链路源地址或目的地址的数据包。</li>
</ul>
<h3 id="唯一本地地址"><a href="#唯一本地地址" class="headerlink" title="唯一本地地址"></a>唯一本地地址</h3><p>（范围 fc00:: /7 到 fdff:: /7）<br>IPv6 唯一本地地址与 IPv4 的 RFC 1918 私有地址具有相似之处，但是也有着重大差异。</p>
<ul>
<li>唯一本地地址用于一个站点内或数量有限的站点之间的本地编址。</li>
<li>唯一本地地址可用于从来不需要访问其他网络的设备。</li>
<li>唯一本地地址不会全局路由或转换为全局 IPv6 地址。</li>
</ul>
<h3 id="IPv6-全局单播地址-GUA"><a href="#IPv6-全局单播地址-GUA" class="headerlink" title="IPv6 全局单播地址 (GUA)"></a>IPv6 全局单播地址 (GUA)</h3><p>IPv6 全局单播地址 (GUA) 具有全局唯一性，可在 IPv6互联网上路由。这些地址相当于公有 IPv4 地址。互联网名称与数字地址分配机构 (ICANN)，即 IANA 的运营商，将 IPv6 地址块分配给五家 RIR。目前分配的仅是前三位为 001 或 2000::/3 的全局单播地址（GUA）<br><strong>注意</strong>: 2001:db8::/32已经留作备档之用，包括示例用途。<br>下图显示了 GUA 的结构和范围。<br><img src="/2022/02/28/%E7%BD%91%E7%BB%9C/ITN11-13/1645609454686.png"><br>带有 /48 全局路由前缀和 /64 前缀的 IPv6 地址</p>
<p><strong>GUA 有三个部分：</strong></p>
<h4 id="全局路由前缀"><a href="#全局路由前缀" class="headerlink" title="全局路由前缀"></a>全局路由前缀</h4><p>全局路由前缀为提供商（如 ISP）分配给客户或站点的地址的前缀或网络部分。例如，ISP 通常会为其客户分配 /48 全局路由前缀。<br>例如，IPv6 地址2001:db8:acad::/48 的全局路由前缀，该前缀表示ISP知道该前缀（网络）的方式是前48位（3个十六进制数）（2001:db8:acad）。/48 前缀长度后面的双冒号 (::) 表示地址的剩余部分全部为 0。全局路由前缀的大小决定子网 ID 的大小。</p>
<h4 id="子网-ID"><a href="#子网-ID" class="headerlink" title="子网 ID"></a>子网 ID</h4><p>子网ID字段是全局路由前缀和接口ID之间的区域。与IPv4不同，在IPv4中您必须从主机部分借用位来创建子网，IPv6在设计时考虑到了子网。组织使用子网 ID 确定其站点的子网。子网 ID 越大，可用子网越多。<br>使用典型的/64前缀长度，前四个十六进制数是地址的网络部分，其中第四个十六进制数表示子网 ID。剩下的四个十六进制数用于接口 ID。</p>
<h4 id="接口-ID"><a href="#接口-ID" class="headerlink" title="接口 ID"></a>接口 ID</h4><p>IPv6 接口 ID 相当于 IPv4 地址的主机部分。使用术语“接口 ID”是因为单个主机可能有多个接口，而每个接口又有一个或多个 IPv6 地址。<br>/64 子网或前缀（全局路由前缀 + 子网 ID）为接口 ID 留下 64 位。建议允许启用 SLAAC 的设备创建自己的 64 位接口 ID。它还使得 IPv6 编址计划的开发变得简单而有效。</p>
<h3 id="IPv6-链路本地地址-LLA"><a href="#IPv6-链路本地地址-LLA" class="headerlink" title="IPv6 链路本地地址 (LLA)"></a>IPv6 链路本地地址 (LLA)</h3><p>IPv6 链路本地地址(LLA)允许设备与同一链路上支持 IPv6 的其他设备通信，并且只能在该链路（子网）上通信。具有源或目的LLA的数据包不能在数据包的源链路之外进行路由。<br><strong>GUA 不是一项要求。但是，每个启用 IPv6 的网络接口都必须有 LLA。</strong><br>如果没有手动为接口配置LLA，设备会在不与 DHCP 服务器通信的情况下自动创建自己的地址。支持 IPv6 的主机会创建 IPv6 LLA，即使没有为该设备分配 IPv6 全局单播地址。这允许支持 IPv6 的设备与同一子网中的其他支持 IPv6 的设备通信。这包括与默认网关（路由器）的通信。<br>IPv6 LLAs在fe80::/10范围内。/10 表示前 10 位是 1111 1110 10xx xxxx。第一个十六进制数的范围是 1111 1110 10<strong>00 0000</strong> (fe80) 到 1111 1110 10<strong>11 1111</strong> (febf)。<br>设备可以通过两种方式获取 LLA：</p>
<ul>
<li>  <strong>静态</strong> -这意味着设备已手动配置。</li>
<li>  <strong>动态</strong> -这意味着设备通过使用随机生成的值或使用扩展唯一标识符 (EUI) 方法创建自己的接口 ID，该方法使用客户端 MAC 地址和其他位。</li>
</ul>
<p><strong>注意</strong>: 通常情况下，用作链路上其他设备的默认网关的是路由器的LLA而不是GUA。</p>
<h2 id="GUA-和-LLA-静态配置"><a href="#GUA-和-LLA-静态配置" class="headerlink" title="GUA 和 LLA 静态配置"></a>GUA 和 LLA 静态配置</h2><p>在 思科IOS 中，大多数 IPv6 的配置和验证命令与 IPv4 的相似。在多数情况下，唯一区别是命令中使用“ipv6”取代“ip”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">使用以下地址在千兆以太网 0/0/0 接口上配置并激活 IPv6：</span><br><span class="line">R1(config)#interface g0/0/0</span><br><span class="line">将 g0/0/0 作为接口名称</span><br><span class="line">R1(config-if)#ipv6 address fe80::1:1 link-local</span><br><span class="line">设置LLA为fe80::1:1注意加“link-local”</span><br><span class="line">R1(config-if)#ipv6 address 2001:db8:acad:1::1/64</span><br><span class="line">设置GUA为2001:db8:acad:1::1/64</span><br><span class="line">R1(config-if)#no shutdown</span><br><span class="line">激活接口</span><br><span class="line">%LINK-3-UPDOWN: Interface GigabitEthernet0/0/0, changed state to up</span><br><span class="line">显示已开启</span><br><span class="line">R1(config-if)#exit</span><br><span class="line">退出接口配置模式</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">使用以下地址在串行 0/1/0 接口上配置并激活 IPv6：</span><br><span class="line">R1(config)#interface s0/1/0</span><br><span class="line">将 s0/1/0 作为接口名称</span><br><span class="line">R1(config-if)#ipv6 address fe80::3:1 link-local</span><br><span class="line">设置LLA为fe80::3:1注意加“link-local”</span><br><span class="line">R1(config-if)#ipv6 address 2001:db8:acad:3::1/64</span><br><span class="line">设置GUA为2001:db8:acad:3::1/64</span><br><span class="line">R1(config-if)#no shutdown</span><br><span class="line">激活接口</span><br><span class="line">%LINK-3-UPDOWN: Interface Serial0/1/0, changed state to up</span><br><span class="line">显示已开启</span><br><span class="line">R1(config-if)#exit</span><br><span class="line">退出接口配置模式</span><br></pre></td></tr></table></figure>

<h2 id="GUA动态编址"><a href="#GUA动态编址" class="headerlink" title="GUA动态编址"></a>GUA动态编址</h2><h3 id="RS-and-RA-消息"><a href="#RS-and-RA-消息" class="headerlink" title="RS and RA 消息"></a>RS and RA 消息</h3><p>大多数设备会动态获取其 IPv6 GUA。<br>对于 GUA，设备通过 Internet 控制消息协议版本 6 (ICMPv6) 消息动态获取地址。IPv6 路由器每 200 秒定期将 ICMPv6 RA 消息发送到网络上所有支持 IPv6 的设备。在响应发送 ICMPv6 路由器请求 (RS) 消息的主机时，也会发送 RA 消息，RS消息是对RA消息的请求。</p>
<p>为路由器启用 IPv6 路由，这在默认情况下是不启用的。若要将路由器启用为 IPv6 路由器，必须使用 <code>ipv6 unicast-routing</code> 全局配置命令。<br>ICMPv6 RA 消息提示设备获取 IPv6 GUA的方式。最终决定取决于设备的操作系统。ICMPv6 RA 消息包括以下：</p>
<ul>
<li>  <strong>网络前缀和前缀长度</strong> – 这会告知设备其所属的网络。</li>
<li>  <strong>默认网关</strong> – IPv6 LLA，RA 消息的源 IPv6 地址。</li>
<li>  <strong>DNS 地址和域名</strong> – 这些是DNS 服务器的地址和域名。<br>RA 消息有三种方法：</li>
</ul>
<h4 id="方法-1：SLAAC-Stateless-address-auto-configuration，无状态地址自动配置"><a href="#方法-1：SLAAC-Stateless-address-auto-configuration，无状态地址自动配置" class="headerlink" title="方法 1：SLAAC(Stateless address auto-configuration，无状态地址自动配置)"></a>方法 1：SLAAC(Stateless address auto-configuration，无状态地址自动配置)</h4><p>SLAAC是一种允许设备在没有DHCPv6服务的情况下创建自己的GUA的方法。使用 SLAAC，设备根据本地路由器的 ICMPv6 路由器通告 (RA) 消息获取必要信息。<br>默认情况下，RA 消息会提示接收设备使用 RA 消息中的信息创建其自己的 IPv6 GUA及其他必要信息。DHCPv6 服务器的服务不是必需项。<br>SLAAC 是无状态的，也就是说没有中央服务器（例如有状态DHCPv6 服务器）来分配GUA和维持设备及其地址的清单。借助 SLAAC，客户端设备使用 RA 消息中的信息创建其自己的GUA。<br>地址的两部分生成如下：</p>
<ul>
<li>  <strong>前缀</strong> -这是在 RA 消息中通告的。</li>
<li>  <strong>接口 ID</strong> -使用 EUI-64 流程或通过生成一个随机 64 位数字产生，取决于设备的操作系统。<br><img src="/2022/02/28/%E7%BD%91%E7%BB%9C/ITN11-13/1645702011889.png" alt="enter description here"></li>
</ul>
<h4 id="方法-2：SLAAC-和无状态-DHCPv6-Dynamic-Host-Configuration-Protocol动态主机配置协议"><a href="#方法-2：SLAAC-和无状态-DHCPv6-Dynamic-Host-Configuration-Protocol动态主机配置协议" class="headerlink" title="方法 2：SLAAC 和无状态 DHCPv6(Dynamic Host Configuration Protocol动态主机配置协议)"></a>方法 2：SLAAC 和无状态 DHCPv6(Dynamic Host Configuration Protocol动态主机配置协议)</h4><p>路由器的接口可配置为使用 SLAAC 和无状态 DHCPv6 或仅使用有状态 DHCPv6 发送路由器通告。<br>如图所示，使用此方法，RA 消息建议设备使用以下内容：</p>
<ul>
<li>  SLAAC创建自己的IPv6 GUA</li>
<li>  路由器LLA，是RA源IPv6地址，作为默认网关地址</li>
<li>  使用无状态 DHCPv6 服务器获取其他信息，例如 DNS 服务器地址和域名。</li>
<li><em>注意</em>*: 使用无状态 DHCPv6 服务器分配 DNS 服务器地址和域名。它不分配 GUA。<br><img src="/2022/02/28/%E7%BD%91%E7%BB%9C/ITN11-13/1645702026814.png" alt="enter description here"></li>
</ul>
<h4 id="方法-3：有状态的DHCPv6"><a href="#方法-3：有状态的DHCPv6" class="headerlink" title="方法 3：有状态的DHCPv6"></a>方法 3：有状态的DHCPv6</h4><p>路由器接口可以配置为仅使用有状态的DHCPv6发送RA。<br>有状态 DHCPv6 与 IPv4 的 DHCP 相似。设备可以从有状态 DHCPv6 服务器自动接收编址信息，包括GUA、前缀长度和 DNS 服务器地址。<br>如图所示，使用此方法，RA 消息建议设备使用以下内容：</p>
<ul>
<li>  路由器LLA，是RA源IPv6地址，作为默认网关地址。</li>
<li>  使用有状态 DHCPv6 服务器获取GUA、DNS 服务器地址、域名和其他必要信息。<br><img src="/2022/02/28/%E7%BD%91%E7%BB%9C/ITN11-13/1645702073373.png" alt="enter description here"><br>使用有状态 DHCPv6 服务器分配并维持哪台设备接收哪个 IPv6 地址的清单。IPv4 的 DHCP 是有状态的。</li>
<li><em>注意:</em>* 默认网关地址仅可从 RA 消息中动态获取。无状态或有状态 DHCPv6 服务器均不提供默认网关地址。</li>
</ul>
<h3 id="EUI-64-流程和随机生成"><a href="#EUI-64-流程和随机生成" class="headerlink" title="EUI-64 流程和随机生成"></a>EUI-64 流程和随机生成</h3><p>当 RA 消息为 SLAAC 或 SLAAC 和无状态 DHCPv6 时，客户端必须生成自己的接口 ID。客户端从 RA 消息中获知地址的前缀部分，但必须创建自己的接口 ID。如图所示，接口 ID 可使用 EUI-64 流程或随机生成的 64 位数字创建。<br><img src="/2022/02/28/%E7%BD%91%E7%BB%9C/ITN11-13/1645702541865.png"><br>IEEE 定义了扩展唯一标识符 (Extended Unique Identifier) 或修改的 EUI-64 流程。该流程使用客户端的 48 位以太网 MAC 地址，并在该 48 位 MAC 地址的中间插入另外 16 位来创建 64 位接口 ID。<br>以太网 MAC 地址一般使用十六进制表示，由两部分组成：</p>
<ul>
<li>  **组织唯一标识符 (OUI) **- OUI 为 IEEE 分配的 24 位（6 个十六进制数字）厂商代码。</li>
<li>  <strong>设备标识符</strong> - 设备标识符是通用 OUI 内的唯一 24 位（6 个十六进制数字）值。<br>EUI-64 接口 ID 以二进制表示，共分三个部分：</li>
<li>  客户端 MAC 地址的 24 位 OUI，但是第 7 位（通用/本地 (U/L) 位）颠倒。这意味着，如果第 7 位是 0，则它会变为 1，反之亦然。U/L 位的用途和该位值的翻转原因会在 RFC 5342 中讨论。</li>
<li>  插入的 16 位值 fffe（十六进制）。</li>
<li>  客户端 MAC 地址的 24 位设备标识符。<br><img src="/2022/02/28/%E7%BD%91%E7%BB%9C/ITN11-13/1645703120047.png"><br>EUI-64 优势在于可以使用以太网 MAC 地址确定接口 ID。这也允许网络管理员使用唯一 MAC 地址轻松跟踪终端设备的 IPv6 地址。</li>
</ul>
<p>然而，这引起了许多用户的隐私担忧，他们担心自己的数据包可能会被追踪到实际的物理计算机。出于这些顾虑，可以转而使用<strong>随机生成</strong>的接口 ID。<br>根据操作系统，设备可以使用随机生成的接口 ID，而不使用 MAC 地址和 EUI-64 流程。从 Windows Vista 开始，Windows 使用随机生成的接口 ID，而不是 EUI-64 创建的接口 ID。Windows XP 和之前的 Windows 操作系统均使用 EUI-64。<br><strong>注意</strong>:为确保任何 IPv6 单播地址的唯一性，客户端可以使用重复地址检测 (DAD) 流程。这与 ARP 请求其地址的流程相似。如该请求没有响应，则地址是唯一的。</p>
<h2 id="LLA动态编址"><a href="#LLA动态编址" class="headerlink" title="LLA动态编址"></a>LLA动态编址</h2><p>所有 IPv6 设备都必须有 IPv6 LLA。与 IPv6 GUA一样，您也可以动态创建 LLA。无论您如何创建LLA(和GUA)，重要的是要验证所有IPv6地址配置。<br>使用fe80::/10 前缀和通过 EUI-64 流程或随机生成的 64 位数字创建的接口 ID 动态创建LLA。</p>
<h3 id="Windows上的动态LLA"><a href="#Windows上的动态LLA" class="headerlink" title="Windows上的动态LLA"></a>Windows上的动态LLA</h3><p>操作系统，如Windows，通常会对SLAAC创建的GUA和动态分配的LLA使用相同的方法（EUI-64 生成、随机生成）</p>
<h3 id="思科路由器上的动态LLA"><a href="#思科路由器上的动态LLA" class="headerlink" title="思科路由器上的动态LLA"></a>思科路由器上的动态LLA</h3><p>当为接口分配GUA时，思科路由器会自动创建 IPv6 LLA。默认情况下，思科 IOS 路由器使用 EUI-64 为 IPv6 接口上的所有LLA生成接口 ID。对于串行接口，路由器会使用以太网接口的 MAC 地址。回想一下，LLA在该链路或网络上必须具有唯一性。但是，使用动态分配的LLA的缺点在于其接口 ID 较长，因此很难识别并记住分配的地址。示例显示了路由器 R1 千兆以太网0/0/0 接口的 MAC 地址。该地址用于在同一接口上动态创建LLA，也用于串行0/1/0接口。<br>为了更容易在路由器上识别和记忆这些地址，通常要在路由器上静态配置 IPv6 LLA。<br><img src="/2022/02/28/%E7%BD%91%E7%BB%9C/ITN11-13/1645704177487.png"></p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p><strong>show ipv6 interface brief</strong> 命令会显示以太网接口的 MAC 地址。EUI-64 使用此 MAC 地址生成LLA的接口 ID。此外，<strong>show ipv6 interface brief</strong> 命令用于显示各个接口的缩略输出。与接口位于同一行的 [up/up] 输出指示第 1 层/第 2 层接口状态。这与等效的 IPv4 命令的状态和协议列相同。<br><strong>show ipv6 route</strong> 命令可用于检验 IPv6 网络和特定 IPv6 接口地址已添加到 IPv6 路由表中。该 <strong>show ipv6 route</strong> 命令将仅显示 IPv6 网络，而不显示 IPv4 网络。<br>IPv6 的 <strong>ping</strong> 命令和 IPv4 中这条命令的用法相同，只不过后接使用的是 IPv6 地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">输入显示 IPv6 接口状态摘要的 show 命令。</span><br><span class="line">R1#show ipv6 interface brief</span><br><span class="line">GigabitEthernet0/0/0   [up/up]</span><br><span class="line">    FE80::1:1</span><br><span class="line">    2001:DB8:ACAD:1::1</span><br><span class="line">GigabitEthernet0/0/1   [up/up]</span><br><span class="line">    FE80::2:1</span><br><span class="line">    2001:DB8:ACAD:2::1</span><br><span class="line">Serial0/1/0            [up/up]</span><br><span class="line">    FE80::3:1</span><br><span class="line">    2001:DB8:ACAD:3::1</span><br><span class="line">Serial0/1/1            [down/down]</span><br><span class="line">    unassigned</span><br><span class="line">GigabitEthernet0       [administratively down/down]</span><br><span class="line">    unassigned</span><br><span class="line">验证从R1到PC2在2001:db8:acad:1::10的连接性。</span><br><span class="line">R1#show ipv6 route</span><br><span class="line">IPv6 Routing Table - default - 7 entries</span><br><span class="line">Codes: C - Connected, L - Local, S - Static, U - Per-user Static route</span><br><span class="line">       B - BGP, HA - Home Agent, MR - Mobile Router, R - RIP</span><br><span class="line">       H - NHRP, I1 - ISIS L1, I2 - ISIS L2, IA - ISIS interarea</span><br><span class="line">       IS - ISIS summary, D - EIGRP, EX - EIGRP external, NM - NEMO</span><br><span class="line">       ND - ND Default, NDp - ND Prefix, DCE - Destination, NDr - Redirect</span><br><span class="line">       O - OSPF Intra, OI - OSPF Inter, OE1 - OSPF ext 1, OE2 - OSPF ext 2</span><br><span class="line">       ON1 - OSPF NSSA ext 1, ON2 - OSPF NSSA ext 2, la - LISP alt</span><br><span class="line">       lr - LISP site-registrations, ld - LISP dyn-eid, a - Application</span><br><span class="line">C   2001:DB8:ACAD:1::/64 [0/0]</span><br><span class="line">     via GigabitEthernet0/0, directly connected</span><br><span class="line">L   2001:DB8:ACAD:1::1/128 [0/0]</span><br><span class="line">     via GigabitEthernet0/0, receive</span><br><span class="line">C   2001:DB8:ACAD:2::/64 [0/0]</span><br><span class="line">     via GigabitEthernet0/1, directly connected</span><br><span class="line">L   2001:DB8:ACAD:2::1/128 [0/0]</span><br><span class="line">     via GigabitEthernet0/1, receive</span><br><span class="line">C   2001:DB8:ACAD:3::/64 [0/0]</span><br><span class="line">     via Serial0/0/1, directly connected</span><br><span class="line">L   2001:DB8:ACAD:3::1/128 [0/0]</span><br><span class="line">     via Serial0/0/1, receive</span><br><span class="line">L   FF00::/8 [0/0]</span><br><span class="line">     via Null0, receive</span><br><span class="line"></span><br><span class="line">R1#ping 2001:db8:acad:1::10</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 2001:DB8:ACAD:1::10, timeout is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 1/1/1 ms</span><br><span class="line">您已成功验证 IPv6 地址配置。</span><br></pre></td></tr></table></figure>

<h2 id="IPv6-组播地址"><a href="#IPv6-组播地址" class="headerlink" title="IPv6 组播地址"></a>IPv6 组播地址</h2><p>IPv6 组播地址类似于 IPv4 组播地址。回想一下，组播地址用于发送单个数据包到一个或多个目标（组播组）。IPv6 组播地址的前缀为ff00::/8。<br>IPv6 组播地址分为两种类型：</p>
<ul>
<li>  知名组播地址</li>
<li>  请求节点组播地址</li>
</ul>
<h3 id="知名组播地址"><a href="#知名组播地址" class="headerlink" title="知名组播地址"></a>知名组播地址</h3><p>已分配的知名IPv6 组播地址。分配的组播地址是为预先定义的设备组保留的组播地址。<br>这些是两种常见的 IPv6 分配组播组：</p>
<ul>
<li>  <strong>ff02::1全节点组播组</strong> -这是一个包含<strong>所有支持 IPv6 的设备的组播组</strong>。发送到该组的数据包由该链路或网络上的所有 IPv6 接口接收和处理。这与 IPv4 中的广播地址具有相同的效果。</li>
<li>  <strong>ff02::2:全路由器组播组</strong> - 这是<strong>所有IPv6路由器加入的组播组</strong>。当在IPv6路由器全局模式下启用ipv6 unicast-routing命令后，该路由器即成为该组的成员。发送到该组的数据包由该链路或网络上的所有 IPv6 路由器接收和处理。</li>
</ul>
<h3 id="请求节点组播地址"><a href="#请求节点组播地址" class="headerlink" title="请求节点组播地址"></a>请求节点组播地址</h3><p>请求节点组播地址类似于全节点组播地址(ff02)。请求节点组播地址的优势在于它被映射到特殊的以太网组播地址。这使得以太网网卡可以通过检查目的 MAC 地址过滤该帧，而不是将它发送给 IPv6 流程来判断该设备是否是 IPv6 数据包的既定目标。</p>
<h2 id="IPv6-网络的子网划分"><a href="#IPv6-网络的子网划分" class="headerlink" title="IPv6 网络的子网划分"></a>IPv6 网络的子网划分</h2><p>使用IPv4时，我们必须从主机部分借用位来创建子网。这是因为对IPv4来说，子网划分是事后才想到的。但是，IPv6 的设计考虑到了子网划分。IPv6 GUA中的一个单独的子网ID字段用于创建子网。如图所示，子网ID字段是全局路由前缀和接口ID之间的区域。<br><img src="/2022/02/28/%E7%BD%91%E7%BB%9C/ITN11-13/1645704992473.png"><br>128 位地址的好处在是，它可以为每个网络支持足够多的子网并为每个子网支持足够多的主机。地址保留不是问题。</p>
<ul>
<li>  <strong>16 位子网 ID</strong> -创建多达 65,536 个子网</li>
<li>  <strong>64 位接口 ID</strong> -每个子网支持多达 1800亿亿个主机 IPv6 地址（即 18,000,000,000,000,000,000）</li>
</ul>
<h3 id="配置命令"><a href="#配置命令" class="headerlink" title="配置命令"></a>配置命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">R1(config)# interface gigabitethernet 0/0/0</span><br><span class="line">R1(config-if)# ipv6 address 2001:db8:acad:1::1/64</span><br><span class="line">R1(config-if)# no shutdown</span><br><span class="line">R1(config-if)# exit</span><br><span class="line">R1(config)# interface gigabitethernet 0/0/1</span><br><span class="line">R1(config-if)# ipv6 address 2001:db8:acad:2::1/64</span><br><span class="line">R1(config-if)# no shutdown</span><br><span class="line">R1(config-if)# exit</span><br><span class="line">R1(config)# interface serial 0/1/0</span><br><span class="line">R1(config-if)# ipv6 address 2001:db8:acad:3::1/64</span><br><span class="line">R1(config-if)# no shutdown</span><br></pre></td></tr></table></figure>

<p>命令<strong>ping ::1</strong>用于测试IPv6主机的内部配置<br><strong>::1</strong> 是一个环回地址。成功地ping到这个地址意味着正确地安装了TCP/IP堆栈。</p>
<h1 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h1><h2 id="ICMP-消息"><a href="#ICMP-消息" class="headerlink" title="ICMP 消息"></a>ICMP 消息</h2><p>虽然 IP 只是“尽最大努力”的协议，但在与另一个IP设备通信时，TCP/IP套件确实提供了错误消息和参考消息。这些消息使用 ICMP 服务发送。其用途是就特定情况下处理 IP 数据包的相关问题提供反馈，而并非是使 IP 可靠。ICMP 消息并非必需的，而且在网络内通常出于安全原因而被禁止。<br>ICMP 可同时用于 IPv4 和 IPv6。ICMPv4 是 IPv4 的消息协议。ICMPv6 为 IPv6 提供相同的服务，此外，还包括其他功能。在本课程中，涉及 ICMPv4 和 ICMPv6 时均会使用术语 ICMP。<br>ICMP 消息的类型及其发送原因非常多。ICMPv4 和 ICMPv6 <strong>通用的</strong> ICMP 消息包括：</p>
<h3 id="主机联通性"><a href="#主机联通性" class="headerlink" title="主机联通性"></a>主机联通性</h3><p>ICMP Echo消息可用于测试 IP 网络上主机的可达性。</p>
<h3 id="目的地或服务不可达"><a href="#目的地或服务不可达" class="headerlink" title="目的地或服务不可达"></a>目的地或服务不可达</h3><p>当主机或网关收到无法传送的数据包时，它会使用 ICMP 目的地不可达消息通知源主机，目的地或服务无法到达。消息包括指示数据包为何无法传送的代码。<br>ICMPv4 的目的地不可达代码示例有：</p>
<ul>
<li>  0 - 网络不可达。</li>
<li>  1 - 主机不可达。</li>
<li>  2 - 协议不可达。</li>
<li>  3 - 端口不可达。</li>
</ul>
<p>ICMPv6 的目的地不可达代码示例有：</p>
<ul>
<li>  0-没有通往目标的路由。</li>
<li>  1-管理上禁止与目的地通信（例如防火墙）</li>
<li>  2-超出源地址的范围</li>
<li>  3-地址无法访问</li>
<li>  4-端口不可达。</li>
<li><em>注意</em>*: ICMPv6 的目的地不可达消息代码与此类似，但稍有不同。</li>
</ul>
<h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>路由器使用 ICMPv4 超时消息表明，因为数据包的生存时间 (TTL) 字段递减到 0 而不能转发该数据包。如果路由器接收数据包并且将 IPv4 数据包的 TTL 字段的值递减为零，则它会丢弃数据包并向源主机发送超时消息。<br>如果路由器因数据包过期而无法转发 IPv6 数据包，ICMPv6 也会发送超时消息。ICMPv6使用IPv6<strong>跳数限制</strong>字段来确定数据包是否已过期，而不是IPv4 TTL字段。</p>
<h3 id="ICMPv6-特有-消息"><a href="#ICMPv6-特有-消息" class="headerlink" title="ICMPv6 (特有)消息"></a>ICMPv6 (特有)消息</h3><p>在 ICMPv6 中发现的信息和错误消息非常类似于 ICMPv4 的控制和错误消息。但是，ICMPv6 拥有 ICMPv4 中所没有的新特性和功能提升。ICMPv6 消息封装在 IPv6 中。<br>ICMPv6 在邻居发现协议（ND 或 NDP）中包括四个新协议。<br>IPv6 路由器和 IPv6 设备之间的消息传递，包括动态地址分配如下所示：</p>
<ul>
<li>  <strong>路由器请求 (RS) 消息</strong>-RS消息是对RA消息的请求。一个IPv6主机启动后将发送一个RS。</li>
<li>  <strong>路由器通告 (RA) 消息</strong>-启用IPv6的路由器每200秒发送RA消息，向启用IPv6的主机提供编址信息。RA 消息中可以包含主机的编址信息，例如前缀、前缀长度、DNS 地址和域名。使用 SLAAC 的主机会将其默认网关设置为发送 RA 的路由器的本地链路地址。<br>IPv6 设备之间的消息传递，包括重复的地址检测和地址解析如下所示：</li>
<li>  <strong>邻居请求 (NS) 消息</strong>-当设备分配有全局IPv6单播或本地链路单播地址时，则建议对地址执行 重复检测（DAD） 来确保IPv6地址的唯一性。如果网络中的其他设备具有该地址，则会使用 NA 消息进行响应。此 NA 消息通知发送方设备地址已在使用。如果回应的 NA 消息未在固定的一段时间返回，则单播地址是唯一的，可以使用。</li>
<li>  <strong>邻居通告 (NA) 消息</strong>-当 LAN 上的设备知道目的 IPv6 单播地址，但不知道其以太网 MAC 地址时，会使用地址解析。要确定目的 MAC 地址，设备会将 NS 消息发送到请求节点地址。该消息包括已知（目标）IPv6 地址。具有目标 IPv6 地址的设备会使用包含其以太网 MAC 地址的 NA 消息进行回应。</li>
<li><em>注意</em>*: ICMPv6 ND 还包括重定向消息，与 ICMPv4 中使用的重定向消息功能相似。</li>
</ul>
<h2 id="Ping-和-Traceroute-测试"><a href="#Ping-和-Traceroute-测试" class="headerlink" title="Ping 和 Traceroute 测试"></a>Ping 和 Traceroute 测试</h2><h3 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h3><p>Ping 是一种测试程序，它使用 ICMP Echo请求和Echo应答消息来测试主机之间的连接。<br>为了测试与网络上的另一台主机的连接，可使用 ping 命令将回应请求发送给该主机地址。若指定地址处的主机收到回应请求，便会使用Echo应答进行响应。每收到一个Echo应答，ping都会提供发出请求与收到应答的时间反馈。这可以作为网络性能的度量。<br>Ping 对响应规定了超时值。如果在超时前没有收到应答，ping 会提供一条消息，表示未收到响应。这可能表示存在问题，但是，还可能表示在网络上启用了阻止 ping 消息的安全功能。如果在发送ICMP Echo请求之前需要执行地址解析(ARP或ND)，那么第一次ping通常会超时。<br>所有请求发送完毕后，ping实用程序会提供摘要，包括成功率和到达目的地的平均往返时间。</p>
<p>在路由器上输入 <strong>ping</strong> 命令时，最常见的指示符如下所示：</p>
<ul>
<li>  <strong>!</strong> - 表示收到一个 ICMP Echo 应答消息</li>
<li>  <strong>.</strong> - 表示超时，正在等待 ICMP Echo应答消息</li>
<li>  <strong>U</strong> - 表示收到了一个 ICMP 无法到达的消息</li>
</ul>
<p>使用<strong>ping</strong>进行的连通性测试的类型包括:</p>
<ul>
<li>  <strong>Ping 本地环回</strong>-从 127.0.0.1 接收的 IPv4 响应或从 ::1 接收的 IPv6 响应，表示主机上的 IP 安装正确。此响应来自网络层。但是，此响应并不代表地址、掩码或网关配置正确。它也不能说明有关网络协议栈下层的任何状态。它只测试 IP 网络层的 IP 连接。如果收到错误消息，则表示该主机上的 TCP/IP 无法正常运行。</li>
<li>  <strong>向默认网关发出 ping 命令</strong>-成功 ping通网关表示主机和充当网关的路由器接口在本地网络中均运行正常。</li>
<li>  <strong>Ping 远程主机</strong>-如果 ping 成功，则说明网际网络大部分运行正常。在互联网络上成功 ping通即确认本地网络上的通信正常，充当网关的路由器运行正常，且可能位于本地网络和远程主机网络之间路径上的所有其他路由器运行正常。</li>
</ul>
<h3 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute"></a>Traceroute</h3><p>Ping 用于测试两台主机之间的连接，但是不提供关于主机之间设备的详细信息。Traceroute <strong>tracert</strong>实用程序可以生成通信路径上成功到达的设备列表。此列表可以提供重要的验证和故障排除信息。如果数据到达目的地，则 Trace 就会列出主机之间的路径中每台路由器上的接口。如果数据在沿途的某一跳上失败，则回应 Trace 的最后一个路由器的地址可以提供指示，说明发现问题或有安全限制的地方。<br><strong>往返时间</strong><br>Traceroute 可提供沿路径每一跳的往返时间并指示是否有某一跳未响应。往返时间是数据包到达远程主机以及从该主机返回响应所花费的时间。星号 * 用于表示丢失的或无应答的数据包。<br>此信息可用于在路径中定位有问题的路由器，或表示路由器配置为不应答。如果显示器显示特定的某一跳响应时间长或数据丢失，这表示该路由器的资源或其连接可能压力过大。<br><strong>IPv4 TTL 和 IPv6 跳数限制</strong><br>Traceroute 使用第 3 层报头中的 IPv4 TTL 字段功能和 IPv6 跳数限制字段功能以及 ICMP 超时消息。</p>

      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/28/%E7%BD%91%E7%BB%9C/ITN8-10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/28/%E7%BD%91%E7%BB%9C/ITN8-10/" class="post-title-link" itemprop="url">ITN 8-10</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-28 16:53:18" itemprop="dateCreated datePublished" datetime="2022-02-28T16:53:18+08:00">2022-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>IP 版本 4 (IPv4) 和 IP 版本 6 (IPv6) 是主要的网络层通信协议。其他网络层协议包括路由协议，如开放式最短路径优先协议(OSPF)，和消息传递协议，如Internet控制消息协议(ICMP)。</p>
<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>为了实现跨网络边界的端到端通信，网络层协议执行四个基本操作:</p>
<ul>
<li>  <strong>终端设备编址</strong> - 必须为终端设备配置唯一的 IP 地址，以便在网络上进行识别。</li>
<li>  <strong>封装</strong> - 网络层将来自传输层的协议数据单元 (PDU) 封装到数据包中。封装过程中会添加 IP 报头信息，例如来源（发送）和目的（接收）主机的 IP 地址。封装过程由 IP 数据包的源主机执行。</li>
<li>  <strong>路由</strong> - 网络层提供服务，将数据包转发至另一网络上的目的主机。要传送到其他网络，数据包必须经过路由器的处理。路由器的作用是为数据包选择最佳路径，并将其转发至目的主机，该过程称为路由。数据包可能需要经过很多路由器才能到达目的主机。数据包在到达目的主机的过程中经过的每个路由器均称作一跳。</li>
<li>  <strong>解封</strong> - 当数据包到达目的主机的网络层时，主机会检查数据包的 IP 报头。如果在报头中的目的 IP 地址与其自身的 IP 地址匹配，IP 报头将被会从数据包中删除。网络层解封数据包后，后继的第 4 层 PDU 会向上传递到传输层的相应服务。解封过程由 IP 数据包的目的主机执行。</li>
</ul>
<h3 id="IP封装"><a href="#IP封装" class="headerlink" title="IP封装"></a>IP封装</h3><p>IP 通过添加 IP 报头将传输层数据段或其他数据进行封装。IP报头用于将数据包传送到目的主机。<br>路由器实施路由协议以在网络之间路由数据包。这些中间设备所执行的路由进程会检查数据包报头中的网络层地址。在任何情况下，数据包的数据部分，即封装的传输层 PDU或其他数据，在网络层的各个过程中都保持不变。</p>
<h3 id="IP特征"><a href="#IP特征" class="headerlink" title="IP特征"></a>IP特征</h3><p>IP 被设计为一种低开销协议只提供通过互连的网络系统从源主机向目的主机传送数据包所必需的功能。该协议并不负责跟踪和管理数据包的流动。<br>IP的基本特征：</p>
<ul>
<li>  <strong>无连接</strong> - 发送数据包前不与目的地建立连接。</li>
<li>  <strong>尽力而为</strong> - IP本质上是不可靠的，因为不保证数据包交付。</li>
<li>  <strong>介质无关性</strong> - 其工作与传输数据的介质（即铜缆、光纤或无线）无关。但是网络层会考虑介质的一个重要特征：每种介质可以传输的最大 PDU 大小。此特征称为最大传输单位 (MTU)。数据链路层为网络层指示所用介质的 MTU</li>
</ul>
<h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><p>IPv4 数据包报头是由包含重要数据包信息的字段组成。这些字段中包含的二进制数字由第 3 层进程进行检查。<br>图中所示的 IP 协议报头图标识了 IPv4 数据包中的字段。<br><img src="/2022/02/28/%E7%BD%91%E7%BB%9C/ITN8-10/1645441397036.png"><br>IPv4 <strong>报头</strong>中的重要字段包括以下：</p>
<ul>
<li>  <strong>版本 -</strong> 包含一个 4 位二进制值 0100，<strong>用于</strong>标识这是 IPv4 数据包。</li>
<li>  <strong>差分服务或区分服务 (DS) -</strong> 以前称为服务类型 (ToS) 字段，DS 字段是一个 8 位字段，<strong>用于</strong>确定每个数据包的优先级。DiffServ 字段的六个最高有效位是区分服务代码点 (DSCP)位，而后两位是显式拥塞通知 (ECN) 位。</li>
<li>  <strong>报头校验和 -</strong> 这<strong>用于</strong>检测 IPv4 报头中的损坏。</li>
<li>  <strong>生存时间 (TTL) -</strong> TTL包含一个 8 位二进制值，<strong>用于</strong>限制数据包的生命周期。IPv4 数据包的源设备设置初始 TTL 值。当数据包每被路由器处理一次，数值就减少一。如果 TTL 字段的值减为零，则路由器将丢弃该数据包并向源 IP 地址发送互联网控制消息协议 (ICMP) 超时消息。由于路由器减少每个数据包的 TTL，因此路由器也必须重新计算报头校验和。</li>
<li>  <strong>协议 -</strong> 该字段<strong>用于</strong>标识下一级协议。此 8 位二进制值表示数据包包含的数据负载类型，使网络层将数据传送到相应的上层协议。常用的值包括 ICMP (1)、TCP (6) 和 UDP (17)。</li>
<li>  <strong>源 IPv4 地址 -</strong> 包含表示数据包源 IPv4 地址的 32 位二进制值。源 IPv4 地址始终为单播地址。</li>
<li>  <strong>目的 IPv4 地址 -</strong> 包含 32 位二进制值，表示数据包的目的 IPv4 地址。目的 IPv4 地址为单播、组播或广播地址。</li>
<li>  <strong>互联网报头长度</strong> (IHL)、<strong>总长度</strong>和<strong>报头校验和</strong>字段均<strong>用于</strong>识别和验证数据包。</li>
<li>  具体而言，IPv4 数据包使用标识符、标志和片偏移量字段跟踪分段。路由器从一种介质向具有较小 MTU(最大传输单元) 的另一种介质转发IPv4数据包时必须将它分片。</li>
</ul>
<h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>IPv4 三个重要问题：</p>
<ul>
<li>  <strong>IPv4地址耗尽</strong> - IPv4 的可用唯一公有地址数量有限。尽管有大约 40 亿(32位)的 IPv4 地址，但是支持 IP 的新设备数量的不断增加，以及始终在线的连接的增加，和欠发达地区的潜在连接的增加，不断催生更多的地址需求。</li>
<li>  <strong>缺乏端到端连接</strong> - 网络地址转换 (NAT) 是 IPv4 网络中经常实施的一项技术。NAT 为多种设备共享单一的公有 IPv4 地址提供方法。但是，因为共享了公有 IPv4 地址，内部网络主机的 IPv4 地址会隐藏起来。这会给需要端到端连接的技术造成难题。</li>
<li>  <strong>增加的网络复杂性</strong> - 虽然NAT延长了IPv4的寿命，但它只是作为一种过渡到IPv6的机制。NAT在其各种实施中增加了网络的复杂性，从而造成延迟并使故障排除更加困难。<br>IPv6 的功能提升包括：</li>
<li>  <strong>更大的地址空间</strong> - IPv6 地址基于 128 位分层编址，而 IPv4 采用的是 32 位。</li>
<li>  <strong>改进数据包处理过程</strong> - IPv6 报头简化为更少的字段。</li>
<li>  <strong>消除了对 NAT 的需求</strong> - 有了数额如此巨大的公有 IPv6 地址，私有 IPv4 地址和公有 IPv4 地址之间不再需要 NAT。这可避免需要端到端连接的应用程序遇到某些由 NAT 引起的故障。</li>
</ul>
<h3 id="报头"><a href="#报头" class="headerlink" title="报头"></a>报头</h3><p><img src="/2022/02/28/%E7%BD%91%E7%BB%9C/ITN8-10/1645442014282.png"><br>IPv6 数据包报头中的字段包括以下：</p>
<ul>
<li>  <strong>版本</strong> - 此字段包含一个 4 位二进制值 0110，<strong>用于</strong>标识这是 IPv6 数据包。</li>
<li>  <strong>流量类别</strong> - 此 8 位字段<strong>相当于</strong>IPv4 区分服务 (DS)字段。</li>
<li>  <strong>流标签</strong> - 此 20 位字段建议所有含相同流标签的数据包接受相同类型的路由器处理。</li>
<li>  <strong>负载长度</strong> - 此 16 位字段<strong>表示</strong> IPv6 数据包的数据部分或负载的长度。这不包括 IPv6 报头的长度，它是固定的 40 字节报头。</li>
<li>  <strong>下一报头</strong> - 此 8 位字段<strong>相当于</strong>“IPv4 协议”字段。它表示数据包传送的数据负载类型，使网络层将数据传送到相应的上层协议。</li>
<li>  <strong>跳数限制</strong> - 此 8 位字段<strong>取代</strong> IPv4 的 TTL 字段。每个转发数据包的路由器均会使此数值减一。当跳数达到 0 时，会丢弃此数据包，并且会向发送主机转发 ICMPv6 超时消息。这表明包没有到达目的地，因为超出了跳数限制。与 IPv4 不同，IPv6 不包括 IPv6 报头校验和，因为此功能同时在下层和上层执行。这意味着校验和不需要在每个路由器降低跳数限制字段时重新计算，这也提高了网络性能。</li>
<li>  <strong>源 IPv6 地址</strong> - 此 128 位字段用于标识发送主机的 IPv6 地址。</li>
<li>  <strong>目的 IPv6 地址</strong> - 此 128 位字段用于标识接收主机的 IPv6 地址。<br>IPv6 数据包还可能包含扩展报头 (EH)，以便提供可选的网络层信息。扩展报头为可选项，位于 IPv6 报头及负载之间。EH 用于分段、安全性、移动性支持等。<br>与 IPv4 不同，路由器不会对路由的 IPv6 数据包进行分段。</li>
</ul>
<h2 id="主机路由方式"><a href="#主机路由方式" class="headerlink" title="主机路由方式"></a>主机路由方式</h2><p>对于IPv4和IPv6，数据包总是在源主机上创建，为此主机终端设备将创建自己的路由表。<br>主机可以将数据包发送至如下：</p>
<ul>
<li>  <strong>主机自己</strong> - 主机可以通过向特定的地址发送数据包来向自己发起ping测试，这个<strong>特定的地址</strong>是：IPv4地址127.0.0.1，或者IPv6地址 ::1，它被称为环回接口。对环回接口执行 ping 操作可以测试主机上的 TCP/IP 协议堆栈。</li>
<li>  <strong>本地主机</strong>- 目的主机与发送主机位于同一本地网络。源和目的主机共享同一个网络地址。</li>
<li>  <strong>远程主机</strong> - 这是位于远程网络上的目的主机。源和目的主机不共享同一个网络地址。<br>数据包是要发送到本地主机还是远程主机是由源端设备决定的。源端设备确定目的 IP 地址是否与源设备本身所在的网络相同。确定方法因 IP 版本不同而异：</li>
<li>  <strong>在 IPv4 中</strong> -源设备使用自己的子网掩码以及自己的 IPv4 地址和目的 IPv4 地址来进行此判断。</li>
<li>  <strong>在 IPv6 中</strong> -本地路由器将本地网络地址（前缀）通告给网络上的所有设备。</li>
</ul>
<h3 id="默认网关"><a href="#默认网关" class="headerlink" title="默认网关"></a>默认网关</h3><p>默认网关是可以将流量路由到其他网络的网络设备，通常是具有以下功能的路由器：</p>
<ul>
<li>  它拥有与本地网络其他主机位于相同地址范围的本地 IP 地址。</li>
<li>  它可以接受数据到本地网络，并将数据转发出本地网络。</li>
<li>  它向其他网络路由流量。<br>主机的路由表通常包括默认网关。在IPv4中，主机通过动态主机配置协议 (DHCP) 动态接收默认网关 IPv4 地址，或者通过手动配置。在 IPv6 中，路由器通告默认网关地址，或者可以在主机上手动配置。<br>配置默认网关会在 PC 的路由表中创建一个默认路由。默认路由是计算机尝试联系远程网络时所用的路由或路径。<br>PC1 和 PC2 都会使用默认路由将去往远程网络的所有流量发送到 R1。</li>
</ul>
<h3 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h3><p>路由表存储三种类型的路由条目：</p>
<ul>
<li>  <strong>直连网络-</strong> 这些网络路由条目是活动的路由器接口。当接口配置了 IP 地址并激活时，路由器会添加直连路由。每个路由器接口均连接到一个不同的网段。在图中，R1 IPv4路由表中的直连网络为192.168.10.0/24和209.165.200.224/30。</li>
<li>  <strong>远程网络</strong> - 这些网络路由条目连接到其他路由器。路由器通过由管理员明确配置或使用动态路由协议交换路由信息来学习远程网络。在图中，R1 IPv4路由表中的远程网络为10.1.1 /24。</li>
<li>  <strong>默认路由</strong> -像主机一样，大多数路由器还包含默认路由条目，即默认网关。当IP路由表中没有更好(更长)的匹配时，将使用默认路由。在图中，R1 IPv4路由表很可能包含一个将所有数据包转发到路由器R2的默认路由。<br><img src="/2022/02/28/%E7%BD%91%E7%BB%9C/ITN8-10/1645444562285.png"></li>
</ul>
<h3 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h3><p>静态路由是手动配置的路由条目。如果网络拓扑改变，静态路由不会自动更新<br>静态路由具有以下特征：</p>
<ul>
<li>  必须手动配置静态路由。</li>
<li>  如果拓扑发生变化，且静态路由不再可用，则管理员需要重新配置静态路由。</li>
<li>  静态路由适用于小型网络且当冗余链路很少或没有冗余链路的情况。</li>
<li>  静态路由通常与动态路由协议一起用于配置默认路由。<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3>动态路由协议可让路由器从其他路由器那里自动学习远程网络，包括默认路由。如果使用动态路由协议，则路由器无需网络管理员的参与，即可自动与其它路由器共享路由信息并对拓扑结构的变化作出反应。如果网络拓扑发生变化，路由器将使用动态路由协议共享此信息，并自动更新路由表。<br>动态路由协议包括<strong>OSPF</strong>和增强型内部网关路由协议 (<strong>EIGRP</strong>)。<br>动态路由协议将自动执行如下操作：</li>
<li>  发现远程网络</li>
<li>  维护最新路由信息</li>
<li>  选择通往目的网络的最佳路径</li>
<li>  当前路径无法再使用时尝试找出新的最佳路径<br>通常一些路由器会同时使用静态路由和动态路由协议。</li>
</ul>
<h3 id="路由表命令"><a href="#路由表命令" class="headerlink" title="路由表命令"></a>路由表命令</h3><p>在 Windows 主机上，使用route print或命netstat -r令可以显示主机路由表。<br>特权 EXEC 模式命令 <strong>show ip route</strong> 用于查看思科 IOS 路由器上的 IPv4 路由表。每个路由表条目的开头都有一个代码，用于标识路由的类型或路由的学习方式。常见路由源（代码）包括以下内容：</p>
<ul>
<li>  <strong>L</strong> - 直连的本地接口 IP 地址</li>
<li>  <strong>C</strong> - 直连网络</li>
<li>  <strong>S</strong> - 静态路由由管理员手动配置</li>
<li>  <strong>O</strong> - OSPF</li>
<li>  <strong>D</strong> - EIGRP</li>
</ul>
<h1 id="地址解析"><a href="#地址解析" class="headerlink" title="地址解析"></a>地址解析</h1><p>有时，主机必须发送消息，但它只知道目的设备的 IP 地址。主机需要知道该设备的MAC地址，但是如何才能发现它呢? 这就是地址解析变得至关重要的地方。</p>
<h2 id="MAC-和-IP"><a href="#MAC-和-IP" class="headerlink" title="MAC 和 IP"></a>MAC 和 IP</h2><ul>
<li>物理地址（MAC 地址） – 用于同一网络上的以太网网卡之间的通信。</li>
<li>逻辑地址（IP地址） – 用于将数据包从源设备发送到目的设备。目的IP地址可能与源地址在同一个IP网络上，也可能在远程网络上<br>数据流中 IP 数据包的 IP 地址如何与通往目的地路径中每条链路上的 MAC 地址相关联？对于IPv4数据包，这可以通过地址解析协议 (ARP) 过程来完成。对于IPv6数据包，这个过程是ICMPv6邻居发现(ND)。</li>
</ul>
<h2 id="⁪ARP"><a href="#⁪ARP" class="headerlink" title="⁪ARP"></a>⁪ARP</h2><p>设备使用地址解析协议(ARP)来确定一个已知 IPv4 地址的本地设备的目的MAC地址。当数据包发送到要封装入以太网帧的数据链路层时，设备将参照其内存中的表来查找映射至 IPv4 地址的 MAC 地址。此表临时存储在RAM内存中，称为 ARP 表或 ARP 缓存。<br>ARP 提供两个基本功能：</p>
<ul>
<li>  将 IPv4 地址解析为 MAC 地址</li>
<li>  维护IPv4到MAC地址映射表</li>
</ul>
<h3 id="ARP请求与应答"><a href="#ARP请求与应答" class="headerlink" title="ARP请求与应答"></a>ARP请求与应答</h3><p>如果设备找到 IPv4 地址，其相应的 MAC 地址将作为帧中的目的 MAC 地址。如果找不到该条目，设备会发送一个 ARP 请求。<br>ARP 请求使用以下帧头信息封装在以太网帧中：</p>
<ul>
<li>  <strong>目的 MAC 地址</strong> – 这是一种要求 LAN 上的所有以太网网卡接受并处理 ARP 请求的广播地址FF-FF-FF-FF-FF-FF。</li>
<li>  <strong>源 MAC 地址</strong> – 这是ARP请求发送方的MAC地址。</li>
<li>  <strong>类型</strong> - ARP 消息的类型字段为 0x806。该类型字段会通知接收网卡需要将帧的数据部分传递给 ARP 进程处理。<br>只有具有与ARP请求相应的目的IPv4地址的设备才会以ARP应答做出响应。ARP 应答使用以下帧头信息封装在以太网帧中：</li>
<li>  <strong>目的 MAC 地址</strong> – 这是ARP请求发送方的MAC地址。</li>
<li>  <strong>源 MAC 地址</strong> – 这是ARP应答发送方的MAC地址。</li>
<li>  <strong>类型</strong> – ARP 消息的类型字段为 0x806。该类型字段会通知接收网卡需要将帧的数据部分传递给 ARP 进程处理。<br>只有原始发送 ARP 请求的设备会收到单播 ARP 应答。收到该 ARP 应答后，设备会将 IPv4 地址及相应的 MAC 地址添加到自身的 ARP 表中。</li>
</ul>
<h3 id="ARP表的删除"><a href="#ARP表的删除" class="headerlink" title="ARP表的删除"></a>ARP表的删除</h3><p>对于每台设备，ARP 缓存定时器将会删除在指定时间内未使用的 ARP 条目。时间根据设备的操作系统不同而不同。例如，较新的 Windows 操作系统将 ARP 表条目存储 15 秒到 45 秒之间，如图所示。</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>在思科路由器上，show ip arp命令用于显示 ARP 表。<br>在 Windows 10 PC 上，arp –a命令用于显示 ARP 表。</p>
<h3 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h3><ul>
<li>广播时对性能的影响<br>作为广播帧，本地网络上的每台设备都会收到并处理 ARP 请求。在一般的商业网络中，这些广播对网络性能的影响可能微不足道。但是，如图所示，如果大量设备都已启动，并且同时开始使用网络服务，网络性能可能会有短时间的下降。在设备发出初始 ARP 广播并获取必要的 MAC 地址之后，网络受到的影响将会降至最小。</li>
<li>ARP欺骗<br>有时，使用 ARP 可能会造成潜在的安全风险。威胁发起者可以使用 ARP 欺骗来执行 ARP 毒化攻击。威胁发起者使用这种技术来应答属于另一台设备（例如默认网关）的 IPv4 地址的 ARP 请求。威胁发起者会发送一个带有自己 MAC 地址的 ARP 应答。ARP 应答的接收方会将错误的 MAC 地址添加到其 ARP 表中，并将这些数据包发送给威胁发起者。<br>企业级的交换机包含称为动态 ARP 检查 (DAI) 的缓解技术。</li>
</ul>
<h2 id="邻居发现"><a href="#邻居发现" class="headerlink" title="邻居发现"></a>邻居发现</h2><p>IPv6 使用与 IPv4 类似的 ARP 流程，称为 ICMPv6 邻居发现(ND或NDP)。与 IPv4 的 ARP 请求和 ARP 应答类似，IPv6 使用邻居请求和邻居通告消息。<br>ICMPv6 ND （在 IETF RFC 4861 中定义）使用五种 ICMPv6 消息来执行这些服务：</p>
<ul>
<li>  邻居请求消息</li>
<li>  邻居通告消息</li>
<li>  路由器请求消息</li>
<li>  路由器通告消息</li>
<li>  重定向消息<br>邻居请求和邻居通告消息用于设备到设备的消息传递，例如地址解析（类似于 IPv4 的 ARP）。设备包括主机计算机和路由器。ICMPv6邻居请求消息使用特定的以太网和IPv6组播地址发送。<br>路由器请求和路由器通告消息用于设备和路由器之间的消息传递。通常，路由器发现用于动态地址分配和<strong>无状态地址自动配置</strong> (SLAAC)。<br>重定向消息用于更好的下一跳选择。</li>
</ul>
<h1 id="路由器基本配置"><a href="#路由器基本配置" class="headerlink" title="路由器基本配置"></a>路由器基本配置</h1><h2 id="配置初始路由器设置"><a href="#配置初始路由器设置" class="headerlink" title="配置初始路由器设置"></a>配置初始路由器设置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">进入全局配置模式将路由器名称配置为“R1”。</span><br><span class="line">Router&gt;enable</span><br><span class="line">Router#configure terminal</span><br><span class="line">Enter configuration commands, one per line. End with CNTL/Z.</span><br><span class="line">Router(config)#hostname R1</span><br><span class="line">将加密密码配置为“class”。</span><br><span class="line">R1(config)#enable secret class</span><br><span class="line">将控制台线路密码配置为“cisco”并要求用户登录，然后返回全局模式。</span><br><span class="line">R1(config)#line console 0</span><br><span class="line">R1(config-line)#password cisco</span><br><span class="line">R1(config-line)#login</span><br><span class="line">R1(config-line)#exit</span><br><span class="line">对于vty线路0到4，将密码配置为“cisco”并要求用户登录，启用SSH和Telnet访问，然后返回全局模式。</span><br><span class="line">R1(config)#line vty 0 4</span><br><span class="line">R1(config-line)#password cisco</span><br><span class="line">R1(config-line)#login</span><br><span class="line">R1(config-line)#transport input ssh telnet</span><br><span class="line">R1(config-line)#exit</span><br><span class="line">加密所有明文密码</span><br><span class="line">R1(config)#service password-encryption</span><br><span class="line">输入标语“Authorized Access Only!”并使用# 作为定界符。</span><br><span class="line">R1(config)#banner motd #Authorized Access Only!#</span><br><span class="line">退出全局配置模式。</span><br><span class="line">R1(config)#exit</span><br><span class="line">R1#</span><br></pre></td></tr></table></figure>

<h2 id="配置接口"><a href="#配置接口" class="headerlink" title="配置接口"></a>配置接口</h2><p>此表总结了用于验证接口配置的更常用 <strong>show</strong> 命令。<br><img src="/2022/02/28/%E7%BD%91%E7%BB%9C/ITN8-10/1645452335823.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">进入全局配置模式。</span><br><span class="line">R1#configure terminal</span><br><span class="line">Enter configuration commands, one per line. End with CNTL/Z.</span><br><span class="line">配置接口GigabitEthernet 0/0/0。</span><br><span class="line">R1(config)#interface gigabitethernet 0/0/0</span><br><span class="line">将链路描述为“Link to LAN”。</span><br><span class="line">R1(config-if)#description Link to LAN</span><br><span class="line">使用 IPv4 地址192.168.10.1和子网掩码255.255.255.0配置接口。</span><br><span class="line">R1(config-if)#ip address 192.168.10.1 255.255.255.0</span><br><span class="line">使用 IPv6 地址 2001:db8:acad:10::1 和前缀长度/64配置接口。</span><br><span class="line">R1(config-if)#ipv6 address 2001:db8:acad:10::1/64</span><br><span class="line">启用接口并返回全局配置模式。</span><br><span class="line">R1(config-if)#no shutdown</span><br><span class="line">*Aug  1 01:43:53.435: %LINK-3-UPDOWN: Interface GigabitEthernet0/0/0, changed state to down</span><br><span class="line">*Aug  1 01:43:56.447: %LINK-3-UPDOWN: Interface GigabitEthernet0/0/0, changed state to up</span><br><span class="line">*Aug  1 01:43:57.447: %LINEPROTO-5-UPDOWN: Line protocol on Interface GigabitEthernet0/0/0, changed state to up</span><br><span class="line">R1(config-if)#exit</span><br><span class="line">R1#</span><br><span class="line">您已成功配置路由器 R1 上的初始设置。</span><br></pre></td></tr></table></figure>

<h2 id="配置默认网关"><a href="#配置默认网关" class="headerlink" title="配置默认网关"></a>配置默认网关</h2><p>要为交换机配置默认网关，请使用ip default-gateway ip-address 全局配置命令。配置的 IP 地址是连接到交换机的本地路由器接口的 IP 地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">进入全局配置模式。</span><br><span class="line">S1#configure terminal</span><br><span class="line">Enter configuration commands, one per line. End with CNTL/Z.</span><br><span class="line">将 S1 的默认网关配置为“192.168.10.1”。</span><br><span class="line">S1(config)#ip default-gateway 192.168.10.1</span><br><span class="line">S1(config)#</span><br><span class="line">您已在交换机S1上成功配置默认网关。</span><br></pre></td></tr></table></figure>
<h1 id="查漏补缺"><a href="#查漏补缺" class="headerlink" title="查漏补缺"></a>查漏补缺</h1><p>当有多个可用路由时，路由器使用哪项参数来选择到达目的网络的路径？</p>
<ul>
<li>与目的网络相关的较低度量值</li>
</ul>
<p>当有多个可用路由时，路由器使用哪项参数来选择到达目的网络的路径？</p>
<ul>
<li>流标签</li>
</ul>
<p>当在交换机 vty 线路上输入 transport input ssh 命令时会发生什么?</p>
<ul>
<li>交换机和远程用户之间的通信是加密的</li>
</ul>
<p>思科路由器启动过程分为四个主要阶段：</p>
<ol>
<li> 执行POST</li>
<li> 加载 bootstrap 程序</li>
<li> 查找并加载 Cisco IOS 软件</li>
<li> 查找并加载启动配置文件，或进入设置模式</li>
</ol>

      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/28/%E7%BD%91%E7%BB%9C/ITN14-15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/28/%E7%BD%91%E7%BB%9C/ITN14-15/" class="post-title-link" itemprop="url">ITN 14-15</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-28 14:08:11" itemprop="dateCreated datePublished" datetime="2022-02-28T14:08:11+08:00">2022-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-16 15:00:15" itemprop="dateModified" datetime="2022-03-16T15:00:15+08:00">2022-03-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>传输层负责在不同主机上运行的<strong>应用程序</strong>之间进行的逻辑通信。<br>传输层包括两个协议：</p>
<ul>
<li>  传输控制协议 (TCP Transmission Control Protocol)</li>
<li>  用户数据报协议 (UDP User Datagram Protocol)</li>
</ul>
<h2 id="传输层的职责"><a href="#传输层的职责" class="headerlink" title="传输层的职责"></a>传输层的职责</h2><ul>
<li><strong>跟踪各个会话</strong>-源应用和目的应用之间传输的每个数据集称为会话并分别进行跟踪</li>
<li><strong>数据分段和数据段重组</strong>-将应用程序数据划分为适当大小的块。根据所使用的传输层协议，传输层块称为数据段或数据报。</li>
<li><strong>添加报头信息</strong>-将包含二进制数据的报头信息添加到每个数据块中，这些数据被组织成几个字段。不同的传输层协议通过这些字段值在管理数据通信过程中执行各自的功能。</li>
<li><strong>标识应用</strong>-为了将数据流传递到适当的应用程序，传输层使用称为端口号的标识符来标识目标应用。</li>
<li><strong>会话多路复用</strong>-使不同的通信会话在同一网络上交错。</li>
</ul>
<h2 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h2><p>传输层协议指定如何在主机之间传输消息，并负责管理会话的可靠性要求。传输层包括 TCP 和 UDP 协议。<br>不同的应用有不同的传输可靠性要求。因此，TCP/IP 提供了两个传输层协议，如图所示</p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP 被认为是可靠且功能齐全的传输层协议，用于确保所有数据到达目的设备。TCP包含确保应用数据传递的字段。这些字段需要发送和接收的主机进行额外处理。<br>TCP将数据分为若干个数据段。<br>TCP 使用以下基本操作提供可靠性和流量控制：</p>
<ul>
<li>  编号并跟踪从特定应用程序发送到特定主机的数据段。</li>
<li>  确认收到数据</li>
<li>  在一定时间段后重新传输未确认的数据</li>
<li>  有顺序的数据可能以错误的顺序到达 以接收方可以接受的有效速率* 发送数据</li>
</ul>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP是一种比TCP更简单的传输层协议。它不提供可靠性和流量控制，这意味着它需要更少的报头字段。由于发送方和接收方UDP进程不需要管理可靠性和流量控制，这意味着 UDP 数据报的处理速度比 TCP 数据段快。UDP 仅提供在相应应用之间传输数据报的基本功能，需要很少的开销和数据检查。<br>UDP 将数据划分为数据报，也称为数据段。<br>UDP是一种无连接协议。由于 UDP 不提供可靠性或流量控制，因此不需要建立连接。由于 UDP 不跟踪客户端和服务器之间发送或接收的信息，因此UDP 也称为无状态协议。<br>UDP 也称为最大努力交付协议，因为在目的地接收到数据后没有确认消息。UDP 中没有通知发送方是否成功传输的传输层程。<br><img src="/2022/02/28/%E7%BD%91%E7%BB%9C/ITN14-15/1645791005727.png" alt="enter description here"><br>UDP 是一个尽最大努力传输协议，而 TCP 是一个可靠的传输协议。<br><strong>实时视频和语音应用</strong>能够容忍具有极小或没有明显影响的一些数据丢失，非常适合于 UDP。</p>
<h2 id="TCP概述"><a href="#TCP概述" class="headerlink" title="TCP概述"></a>TCP概述</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>除了支持<strong>数据分段和重组</strong>的基本功能之外，TCP 还提供以下服务：</p>
<ul>
<li>  <strong>建立会话</strong> -TCP是一种面向连接的协议，在转发任何流量之前，在源设备和目的设备之间协商并建立永久连接（或会话）。通过建立会话，设备可以协商特定时间能够转发的流量，而且两个设备之间的通信数据可得到严格管理。</li>
<li>  <strong>确保可靠的传递</strong> -由于多种原因，数据段在网络传输过程中可能会损坏或者完全丢失。TCP确保从源设备发送的每个数据段都能够到达目的地。</li>
<li>  <strong>提供相同顺序的传递</strong> -由于网络可能提供了多条路由，每条路由又有不同的传输速率，所以可能导致数据抵达的顺序错乱。通过对数据段编号和排序，TCP 确保按正确的顺序重组这些数据段。</li>
<li>  <strong>支持流量控制</strong> -网络主机的资源有限（即，内存或处理能力）。当 TCP 发现这些资源超负荷运转时，它可以请求源应用程序降低数据流速。为此，TCP 会调整源设备传输的数据量。流量控制可避免当接收主机的资源不堪重负时，数据的重新传输。</li>
</ul>
<h3 id="报头"><a href="#报头" class="headerlink" title="报头"></a>报头</h3><p>在封装应用层数据时，TCP 数据段会增加 20 个字节（即 160 位）的开销。该图显示的是 TCP 报头中的字段。(10个)<br><img src="/2022/02/28/%E7%BD%91%E7%BB%9C/ITN14-15/1646123477727.png" alt="enter description here"></p>
<h3 id="报头字段"><a href="#报头字段" class="headerlink" title="报头字段"></a>报头字段</h3><table>
<thead>
<tr>
<th><strong>TCP 报头字段</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>源端口</strong></td>
<td>一个16位字段, 用于通过端口号标识源应用程序。用于跟踪设备之间的多个会话。还用于为服务器的响应保留打开的条目</td>
</tr>
<tr>
<td><strong>目的端口</strong></td>
<td>一个16位字段, 用于通过端口号标识目的应用 程序。</td>
</tr>
<tr>
<td><strong>序列号</strong></td>
<td>一个32位字段, 用于数据重组。</td>
</tr>
<tr>
<td><strong>确认号</strong></td>
<td>一个32位的字段, 用于指示已接收到数据, 并且期望从源 接收下一个字节。</td>
</tr>
<tr>
<td><strong>报头长度</strong></td>
<td>一个4位字段, 称为“数据偏移”, 表示 TCP数据段报头的长度。</td>
</tr>
<tr>
<td><strong>保留</strong></td>
<td>一个6位字段, 保留供将来使用。</td>
</tr>
<tr>
<td><strong>控制位</strong></td>
<td>一个6位字段, 包括位代码或标志, 指示 TCP段的目的和功能。</td>
</tr>
<tr>
<td><strong>窗口大小</strong></td>
<td>一个16位字段, 用于指示一次可以接受的 字节数。</td>
</tr>
<tr>
<td><strong>校验和</strong></td>
<td>一个16位字段, 用于数据段报头和数据的错误检查。</td>
</tr>
<tr>
<td><strong>紧急</strong></td>
<td>一个 16 位字段, 用于指示包含的数据是否紧急。</td>
</tr>
</tbody></table>
<h3 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h3><p>FTP、HTTP、SMTP、SSH</p>
<h2 id="UDP概述"><a href="#UDP概述" class="headerlink" title="UDP概述"></a>UDP概述</h2><p>因此，UDP 仅仅是将接收到的数据按照先来后到的顺序转发到应用程序。如果数据顺序对应用程序很重要，应用程序必须确定正确的顺序并决定如何处理数据。因此，UDP 仅仅是将接收到的数据按照先来后到的顺序转发到应用程序。如果数据顺序对应用程序很重要，应用程序必须确定正确的顺序并决定如何处理数据。### 功能<br>UDP 是一种尽最大努力传输协议。UDP 是一种轻型传输协议，提供与 TCP 相同的<strong>数据分段和重组功能</strong>，但是<strong>没有 TCP 所提供的可靠性和流量控制</strong>。<br>UDP 协议非常简单，它通常被描述为与 TCP 比较所不提供的功能。<br>UDP的特点包括以下几种：</p>
<ul>
<li>  数据按照接收顺序重构。</li>
<li>  丢失的任何数据段都不会重新发送。</li>
<li>  不会建立会话。</li>
<li>  不会告知发送者资源可用性。</li>
</ul>
<h3 id="报头-1"><a href="#报头-1" class="headerlink" title="报头"></a>报头</h3><p>UDP 是无状态协议，这意味着客户端和服务器都不会跟踪通信会话的状态。如果使用 UDP 作为传输协议时要求可靠性，<strong>必须由应用来处理可靠性</strong>。<br>UDP 中的通信块称为数据报或数据段，这些数据报通过传输层协议尽力传送，有四个字段，需要8个字节(即64位)。该图显示的是 UDP 报头中的字段。<br><img src="/2022/02/28/%E7%BD%91%E7%BB%9C/ITN14-15/1646123863260.png" alt="enter description here"></p>
<h3 id="报头字段-1"><a href="#报头字段-1" class="headerlink" title="报头字段"></a>报头字段</h3><table>
<thead>
<tr>
<th><strong>UDP 报头字段</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>源端口</strong></td>
<td>一个16位字段,用于通过端口号标识源应用程序。</td>
</tr>
<tr>
<td><strong>目的端口</strong></td>
<td>一个16位字段,用于通过端口号标识目的应用 程序。</td>
</tr>
<tr>
<td><strong>长度</strong></td>
<td>一个16位字段,指示UDP数据报报头的长度。</td>
</tr>
<tr>
<td><strong>校验和</strong></td>
<td>一个16位字段,用于数据报报头和数据的错误检查。</td>
</tr>
</tbody></table>
<h3 id="应用程序-1"><a href="#应用程序-1" class="headerlink" title="应用程序"></a>应用程序</h3><p>最适合采用 UDP 协议的三种应用程序包括：</p>
<ul>
<li>  <strong>实时视频和多媒体应用程序</strong> - 这些应用可以容忍部分数据丢失但要求延迟极小或没有延迟的应用程序。示例包括 VoIP 和实时流传输视频。</li>
<li>  <strong>简单请求和应答应用程序</strong>- 处理简单事务的应用程序，其中主机发送请求，但不一定收到应答。示例包括 DNS 和 DHCP。</li>
<li>  <strong>处理可靠性的应用程序</strong> - 不要求进行流量控制、错误检测、确认和错误恢复，或这些功能由应用程序来执行的单向通信。示例包括 SNMP 和 TFTP。<br>即：DHCP、DNS、SNMP、TFTP、VoIP、视频会议</li>
</ul>
<h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p>TCP 和 UDP 传输层协议使用端口号来管理多个同时的对话。TCP和UDP报头字段标识源和目的<strong>应用程序</strong>端口号。</p>
<p>源端口和目的端口都被置入分段内，然后分段封装于<strong>IP 数据包</strong>内。IP 数据包中含有源 IP 地址和目的 IP 地址。<br>源 IP 地址和源端口号的组合或者目的 IP 地址和目的端口号的组合，称为<strong>套接字</strong>。</p>
<p>互联网编号指派机构 (IANA) 是负责分配各种编址标准（包括端口号）的标准组织。用于标识源端口号和目的端口号的16位二进制提供了从0到65535的端口范围。</p>
<p>三个端口组<br>| <strong>端口组</strong> | <strong>号码范围</strong> | <strong>描述</strong> |<br>| — | — | — |<br>| <strong>公认端口</strong> | <strong>0到1023</strong> | 这些端口号保留用于常见或流行的服务和应用程序, 例如 Web浏览器, 电子邮件客户端和远程访问 客户端。为常用的服务器应用程序定义的公认端口使 客户端能够轻松识别所需的关联服务。<br>|<br>| <strong>注册端口</strong> | <strong>1024到49151</strong> | IANA将这些端口号分配给请求实体, 以用于特定的进程或应用程序。这些进程主要是用户选择安装的单个 应用程序, 而不是使用公认端口号的 常见应用程序。例如, 思科已为其RADIUS服务器身份验证进程 注册了端口1812。<br>|<br>| <strong>私有</strong>和(或)<strong>动态端口</strong> | <strong>49152 到 65535</strong> | 这些端口也称为 _临时端口_。客户端的操作系统通常在 发起与服务的连接时动态分配端口号。之后即可在通信过程中使用动态端口识别客户端 应用程序。<br>|</p>
<p>该表显示了一些常用的公认端口号及其相关应用程序。<br>| <strong>端口号</strong> | <strong>协议</strong> | <strong>应用层</strong> |<br>| — | — | — |<br>| <strong>20</strong> | TCP | 文件传输协议 (FTP) - 数据 |<br>| <strong>21</strong> | TCP | 文件传输协议 (FTP) - 控制 |<br>| <strong>22</strong> | TCP | 安全 Shell (SSH) |<br>| <strong>23</strong> | TCP | Telnet |<br>| <strong>25</strong> | TCP | 简单邮件传输协议 (SMTP) |<br>| <strong>53</strong> | UDP、TCP | 域名服务 (DNS) |<br>| <strong>67</strong> | UDP | 动态主机配置协议 (DHCP)- 服务器 |<br>| <strong>68</strong> | UDP | 动态主机配置协议-客户端 |<br>| <strong>69</strong> | UDP | 简单文件传输协议 (TFTP) |<br>| <strong>80</strong> | TCP | 超文本传输协议 (HTTP) |<br>| <strong>110</strong> | TCP | 邮局协议第 3 版 (POP3) |<br>| <strong>143</strong> | TCP | 互联网消息访问协议 (IMAP) |<br>| <strong>161</strong> | UDP | 简单网络管理协议 (SNMP) |<br>| <strong>443</strong> | TCP | 安全超文本传输协议 (HTTPS) |</p>
<p>Windows中命令<code>netstat</code>可列出正在使用的协议、本地地址和端口号、外部地址和端口号以及连接的状态。<br>默认情况下，<strong>netstat</strong>命令会试图将 IP 地址解析为域名，将端口号解析为公认应用程序。使用 <strong>-n</strong> 选项能够以数字形式显示 IP 地址和端口号。</p>
<h2 id="TCP通信进程"><a href="#TCP通信进程" class="headerlink" title="TCP通信进程"></a>TCP通信进程</h2><p>在服务器上运行的每个应用程序进程都配置为使用一个端口号。端口号由系统管理员自动分配或手动配置。<br>在同一传输层服务中，单个服务器上不能同时存在具有相同端口号的两个不同服务。<br>分配有特定端口的活动服务器应用程序被认为是开放的，也就是说，传输层将接受并处理分配到该端口的数据段。所有发送到正确套接字地址的传入客户端请求都将被接受，数据将被传送到服务器应用。</p>
<h3 id="TCP-连接的建立-三次握手"><a href="#TCP-连接的建立-三次握手" class="headerlink" title="TCP 连接的建立(三次握手)"></a>TCP 连接的建立(三次握手)</h3><p>三次握手验证目标主机是否可用来通信。</p>
<ul>
<li><strong>第一步SYN</strong>：源客户端请求与服务器进行客户端-服务器通信会话。</li>
<li><strong>第二步ACK和SYN</strong>：服务器确认客户端-服务器通信会话，并请求服务器-客户端通信会话。</li>
<li><strong>第三步ACK</strong>：源客户端确认服务器-客户端通信会话。</li>
</ul>
<h3 id="会话终止"><a href="#会话终止" class="headerlink" title="会话终止"></a>会话终止</h3><p>若要关闭连接，分段报头必须设置完成 (FIN) 控制标志。为终止每个单向 TCP 会话，需采用包含 FIN 分段和确认 (ACK) 分段的二次握手。<br>因此，若要终止 TCP 支持的整个会话过程，需要实施四次交换，以<strong>终止两个双向</strong>会话。客户端或服务器都可以发起终止。</p>
<ul>
<li><strong>第一步FIN</strong>：当客户端的数据流中没有其他要发送的数据时，它将发送带 FIN 标志设置的分段。</li>
<li><strong>第二步ACK</strong>：服务器发送 ACK 信息，确认收到从客户端发出的请求终止会话的 FIN 信息。</li>
<li><strong>第三步FIN</strong>：服务器向客户端发送 FIN 信息，终止从服务器到客户端的会话。</li>
<li><strong>第四部ACK</strong>：客户端发送 ACK 响应信息，确认收到从服务器发出的 FIN 信息。</li>
</ul>
<h3 id="TCP-三次握手分析"><a href="#TCP-三次握手分析" class="headerlink" title="TCP 三次握手分析"></a>TCP 三次握手分析</h3><p>主机维护状态，跟踪会话过程中的每个分段，并使用 TCP 报头信息交换已接收数据的相关信息。TCP 是全双工协议，每个连接都代表两个单向通信会话。若要建立连接，主机应执行三次握手。如图所示，TCP 报头中的<strong>控制位</strong>指出了连接的进度和状态。<br>这些是三次握手的功能：</p>
<ul>
<li>  确认目的设备存在于网络上。</li>
<li>  确认目的设备有活动的服务，并且正在源客户端要使用的目的端口号上接受请求。</li>
<li>  通知目的设备源客户端想要在该端口号上建立通信会话。<br>通信完成后，将关闭会话并终止连接。连接和会话机制保障了 TCP 的可靠性功能。<br><img src="/2022/02/28/%E7%BD%91%E7%BB%9C/ITN14-15/1646134323200.png" alt="enter description here"><br>TCP 分段报头的控制位字段中的六位被称为标志。标志是设置为<strong>开启或关闭的位</strong>。<br>六个控制位标志如下：</li>
<li>  <strong>URG</strong> - 紧急指针字段（重要）</li>
<li>  <strong>ACK</strong> - 用于建立连接和会话终止的确认标志</li>
<li>  <strong>PSH</strong> - 推送功能</li>
<li>  <strong>RST</strong> - 在出现错误或超时时重置连接</li>
<li>  <strong>SYN</strong> - 同步建立连接中使用的序列号</li>
<li>  <strong>FIN</strong> - 没有更多来自发送方的数据，并用于会话终止</li>
</ul>
<h2 id="可靠性和流控制"><a href="#可靠性和流控制" class="headerlink" title="可靠性和流控制"></a>可靠性和流控制</h2><h3 id="TCP可靠性-保证及按序传递"><a href="#TCP可靠性-保证及按序传递" class="headerlink" title="TCP可靠性 - 保证及按序传递"></a>TCP可靠性 - 保证及按序传递</h3><p>有时可能TCP数据段没有到达目的地。有时，TCP段可能会无序到达。因此，为了让接收方理解原始消息，必须<strong>接收所有数据</strong>，<strong>并重组这些数据段</strong>，使其恢复原有顺序。每个数据包中的数据段报头中都含有序列号，便于进行数据重组。序列号代表 TCP 分段的第一个数据字节在完整数据中的位置。<br>在会话建立过程中，将设置<strong>初始序列号</strong> (ISN)。此 ISN 表示传输到接收应用的字节起始值。在会话过程中，每传送一定字节的数据，序列号就随之增加。<strong>通过这样的数据字节跟踪，可以唯一标识并确认每个分段，还可以标识丢失的分段。</strong><br>（ISN 并不是从 1 开始，而是随机的数字。这样做的目的是防止某些类型的恶意攻击。为简单起见，本章的示例中我们将使用 1 作为 ISN。）</p>
<h3 id="TCP可靠性-数据丢失和重传"><a href="#TCP可靠性-数据丢失和重传" class="headerlink" title="TCP可靠性 - 数据丢失和重传"></a>TCP可靠性 - 数据丢失和重传</h3><p>TCP 提供了管理数据段丢失的方法。其中一个方法就是重新传输未确认的数据。</p>
<ul>
<li>序列 (SEQ) 号和确认 (ACK) 号一起使用，以确认接收传输段中包含的数据字节。SEQ 编号标识正在传输的数据段中的第一个字节。TCP 使用发送回源代码的 ACK 编号来<strong>指示接收方希望接收的下一个字节</strong>。这称为<strong>期望确认</strong>。<br>在进行后续增强之前，TCP只能确认预期的下一个字节。</li>
<li>今天的主机操作系统通常采用一种称为选择性确认 (SAK) 的可选 TCP 功能，在三次握手期间协商。如果两个主机都支持SACK，则接收方可以<strong>明确地确认</strong>接收了哪些数据段(字节)，<strong>包括任何不连续的段</strong>。因此，发送主机只需要重新传输丢失的数据。</li>
</ul>
<h3 id="TCP-流量控制-窗口大小和确认"><a href="#TCP-流量控制-窗口大小和确认" class="headerlink" title="TCP 流量控制 - 窗口大小和确认"></a>TCP 流量控制 - 窗口大小和确认</h3><p>TCP 还提供了<strong>流量控制机制</strong>。</p>
<ul>
<li><p><strong>流量控制</strong>即目的主机能够可靠地接收并处理的数据量。<br>流量控制可以调整给定会话中源和目的地之间的数据流速，有助于保持 TCP 传输的可靠性。为此，TCP 报头包括一个称为“窗口大小”的 16 位字段。</p>
</li>
<li><p><strong>窗口大小</strong>用于确定在获得确认前可以发送的字节数。</p>
</li>
<li><p><strong>确认号</strong>是指下一个预期字节的编号。<br>窗口大小是 TCP 会话的目的设备一次可以接受和处理的字节数。<br>初始窗口大小在三次握手期间建立 TCP 会话时确定。源设备必须根据目的设备的窗口大小限制发送到目的设备的字节数。只有源设备收到字节数已接收的确认之后，才能继续发送更多会话数据。</p>
</li>
</ul>
<p><strong>注意</strong>：设备如今使用滑动窗口协议。接收方通常在每收到两个数据段之后发送确认。在确认之前收到的数据段的数量可能有所不同。滑动窗口的优势在于，只要接收方确认之前的数据段，就可以让发送方持续传输数据段。</p>
<h3 id="TCP-流量控制-最大段大小-MSS"><a href="#TCP-流量控制-最大段大小-MSS" class="headerlink" title="TCP 流量控制-最大段大小 (MSS)"></a>TCP 流量控制-最大段大小 (MSS)</h3><p>MSS 是 TCP 报头中选项字段的一部分，用于指定设备可以在单个 TCP数据段中接收的最大数据量（以字节为单位）。</p>
<ul>
<li>MSS 大小不包括 TCP 报头。</li>
<li>MSS 通常包括在三次握手过程中。</li>
<li>使用 IPv4 时，常见的 MSS 为 1460 字节。<br>主机会从以太网最大传输单位 (MTU) 中减去 IP 和 TCP 报头，从而确定其 MSS 字段的值。在以太网接口上，默认 MTU 为 1500 个字节。减去 20 个字节的 IPv4 报头和 20 个字节的 TCP 报头，默认 MSS 大小为 1460 个字节<br><img src="/2022/02/28/%E7%BD%91%E7%BB%9C/ITN14-15/1646137161386.png" alt="enter description here"></li>
</ul>
<h3 id="TCP-流量控制-避免拥塞"><a href="#TCP-流量控制-避免拥塞" class="headerlink" title="TCP 流量控制 - 避免拥塞"></a>TCP 流量控制 - 避免拥塞</h3><p>网络中出现拥塞会使过载的路由器丢弃数据包。当包含 TCP 数据段的数据包未到达其目的地时，它们就成为未确认的数据包。通过确定 TCP 数据段发送但未确认的速率，源设备可以假设一定程度的网络拥塞。<br>出现网络拥塞时，从源设备丢失的 TCP 数据段就会<strong>重传</strong>。如果不适当控制重传，TCP 数据段的额外重传会使拥塞的情况更糟。网络中不仅有 TCP 数据段的新数据包，而且还有重传丢失的 TCP 数据段的反馈效果，这都增加了拥塞。<br><strong>为避免和控制拥塞，TCP 使用了多个拥塞处理机制、计时器和算法。</strong><br>如果源设备确定 TCP 数据段没有被确认或没有被及时确认，它会在<strong>收到确认之前减少发送的字节数</strong>。</p>
<h2 id="UDP通信"><a href="#UDP通信" class="headerlink" title="UDP通信"></a>UDP通信</h2><p>低开销与可靠性</p>
<h3 id="UDP-数据报重组"><a href="#UDP-数据报重组" class="headerlink" title="UDP 数据报重组"></a>UDP 数据报重组</h3><p>与 TCP分段类似，当将多个 UDP 数据报发送到目的主机时，它们通常采用不同的路径，到达顺序也可能跟发送时的顺序不同。与 TCP 不同，UDP 不跟踪序列号。<br>因此，UDP 仅仅是将接收到的数据<strong>按照先来后到的顺序</strong>转发到应用程序。如果数据顺序对应用程序很重要，<strong>应用程序</strong>必须确定正确的顺序并决定如何处理数据。</p>
<h3 id="UDP-服务器进程与请求"><a href="#UDP-服务器进程与请求" class="headerlink" title="UDP 服务器进程与请求"></a>UDP 服务器进程与请求</h3><p>与基于 TCP 的应用程序相同的是，基于 UDP 的服务器应用程序也被分配了<strong>公认端口号</strong>或<strong>注册端口号</strong>。当上述应用或进程在服务器上运行时，它们就会接受与所分配端口号相匹配的数据。当 UDP 收到用于某个端口的数据报时，它就会按照应用的端口号将数据发送到相应的应用。</p>
<h3 id="UDP-客户端进程"><a href="#UDP-客户端进程" class="headerlink" title="UDP 客户端进程"></a>UDP 客户端进程</h3><p>客户端应用向服务器进程请求数据，便会发起客户端-服务器通信。<br>UDP 客户端进程则是从可用端口号中动态挑选一个端口号，用来作为会话的源端口。<br>而目的端口通常都是分配到服务器进程的公认端口号或注册端口号。</p>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="应用层、表示层和会话层"><a href="#应用层、表示层和会话层" class="headerlink" title="应用层、表示层和会话层"></a>应用层、表示层和会话层</h2><h3 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h3><p>该层为用于通信的应用程序和用于消息传输的底层网络提供接口。应用层协议用于在源主机和目的主机上运行的程序之间进行数据交换。<br>基于TCP/IP模型，OSI 模型上面三层（应用层、表示层和会话层）定义了 TCP/IP 应用层的功能。</p>
<h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><p>表示层具有三个主要功能：</p>
<ul>
<li>  将来自源设备的数据格式化或表示成兼容形式，以便目的设备接收。</li>
<li>  采用可被目的设备解压缩的方式对数据进行压缩。</li>
<li>  加密要传输的数据并在收到数据时解密数据。<br>表示层标准的示例有MKV、GIF、JPG、MOV和PNG。</li>
</ul>
<h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><p>会话层的功能就是<strong>创建并维护</strong>源应用程序和目的应用程序之间的<strong>对话</strong>。会话层用于<strong>处理信息交换</strong>，<strong>发起对话</strong>并使其处于活动状态，并在对话中断或长时间处于空闲状态时<strong>重启会话</strong>。</p>
<h3 id="TCP-IP-应用层协议"><a href="#TCP-IP-应用层协议" class="headerlink" title="TCP/IP 应用层协议"></a>TCP/IP 应用层协议</h3><h4 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h4><p>DNS - 域名系统（或服务）</p>
<ul>
<li>  TCP,UDP客户端 53</li>
<li>  将域名（例如 cisco.com）转换为 IP 地址。</li>
</ul>
<h4 id="主机配置"><a href="#主机配置" class="headerlink" title="主机配置"></a>主机配置</h4><p>BOOTP - 引导程序协议</p>
<ul>
<li>  UDP 客户端 68，服务器 67</li>
<li>  允许无盘工作站探查其 IP 地址、网络中 BOOTP 服务器的 IP 地址以及要加载到内存中以引导机器的文件</li>
<li>  BOOTP 正在被 DHCP 所取代</li>
</ul>
<p>DHCP-动态主机配置协议</p>
<ul>
<li>  UDP 客户端 68，服务器 67</li>
<li>  动态分配IP地址可以重复使用不再需要的地址</li>
</ul>
<h4 id="电子邮箱"><a href="#电子邮箱" class="headerlink" title="电子邮箱"></a>电子邮箱</h4><p>SMTP - 简单邮件传输协议</p>
<ul>
<li>  TCP 25</li>
<li>  允许客户端向邮件服务器发送电子邮件</li>
<li>  允许服务器向其他服务器发送电子邮件</li>
</ul>
<p>POP3 - 邮局协议</p>
<ul>
<li>  TCP 110</li>
<li>  允许客户端从邮件服务器检索电子邮件 将电子邮件* 下载到客户端的本地邮件应用程序</li>
</ul>
<p>IMAP - 互联网消息访问协议</p>
<ul>
<li>  TCP 143</li>
<li>  允许客户端访问存储在邮件服务器中的电子邮件</li>
<li>  在服务器上维护电子邮件</li>
</ul>
<h4 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h4><p>FTP - 文件传输协议</p>
<ul>
<li>  TCP 20至21</li>
<li>  设置规则，使得一台主机上的用户能够通过网络访问另一台主机或向其传输文件</li>
<li>  FTP是一种可靠、面向连接且进行确认的文件传输协议。<br>TFTP - 简单文件传输协议</li>
<li>  UDP 客户端 69</li>
<li>  一个简单的，无连接的文件传输协议，使用尽最大努力、不被答复的文件交付</li>
<li>  它使用的开销比FTP少</li>
</ul>
<h4 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h4><p>HTTP-超文本传输协议</p>
<ul>
<li>  TCP 80,8080</li>
<li>  有关在万维网上交换文本、图形图像、音频、视频以及其他多媒体文件的一组规则集<br>HTTPS - 安全 HTTP</li>
<li>  TCP，UDP 443</li>
<li>  浏览器使用加密技术保护 HTTP 通信</li>
<li>  验证您的浏览器连接的网站</li>
</ul>
<h2 id="客户端-服务器模式"><a href="#客户端-服务器模式" class="headerlink" title="客户端-服务器模式"></a>客户端-服务器模式</h2><p>客户端进程和服务器进程都处于应用层。客户端首先向服务器发送数据请求，服务器通过发送一个或多个数据流来响应客户端。应用层协议规定了客户端和服务器之间请求和响应的格式。除了实际数据传输外，数据交换过程还要求用户身份验证以及要传输的数据文件的标识。</p>
<h2 id="对等网络-P2P"><a href="#对等网络-P2P" class="headerlink" title="对等网络(P2P)"></a>对等网络(P2P)</h2><p>在对等 (P2P) 网络模式中，可以从对等设备访问数据，而无需使用专用服务器。</p>
<p>P2P 网络模型包含两个部分：P2P 网络和 P2P 应用程序。</p>
<h3 id="P2P-网络"><a href="#P2P-网络" class="headerlink" title="P2P 网络"></a>P2P 网络</h3><p>在 P2P 网络中，两台或多台计算机通过网络互连，它们共享资源(如打印机和文件)时可以不借助专用服务器。每台接入的终端设备（称为“对等体”）既可以作为服务器，也可以作为客户端。在某项事务中，作为服务器的计算机也可以同时成为其他服务器的客户端。于是，计算机的角色根据请求的不同在客户端和服务器之间切换。</p>
<h3 id="P2P-应用程序"><a href="#P2P-应用程序" class="headerlink" title="P2P 应用程序"></a>P2P 应用程序</h3><p>对等 (P2P) 应用程序允许设备在同一通信中同时充当客户端和服务器。在该模型中，每台客户端都是服务器，而每台服务器也同时是客户端。P2P 应用程序要求每台终端设备提供用户界面并运行后台服务。</p>
<h3 id="常见对等应用程序"><a href="#常见对等应用程序" class="headerlink" title="常见对等应用程序"></a>常见对等应用程序</h3><p>使用 P2P 应用程序时，网络中运行该应用程序的每台计算机都可以充当在网络中运行该应用程序的其他计算机的客户端或服务器。常见 P2P 网络包括:</p>
<ul>
<li>  BitTorrent</li>
<li>  Direct Connect</li>
<li>  eDonkey</li>
<li>  Freenet</li>
</ul>
<p>某些 P2P 应用程序基于 Gnutella 协议，允许每个用户与他人共享整个文件。如图所示，通过与 Gnutella 协议兼容的客户端软件，用户可以在互联网上连接 Gnutella 服务，然后定位并访问由其他 Gnutella 对等设备共享的资源。许多Gnutella客户机应用程序可用,包括μTorrent,BitComet, DC++, Deluge, 和emule。</p>
<h2 id="Web-和电子邮件协议"><a href="#Web-和电子邮件协议" class="headerlink" title="Web 和电子邮件协议"></a>Web 和电子邮件协议</h2><h3 id="超文本传输协议-HTTP-和超文本标记语言-HTML"><a href="#超文本传输协议-HTTP-和超文本标记语言-HTML" class="headerlink" title="超文本传输协议(HTTP)和超文本标记语言(HTML)"></a>超文本传输协议(HTTP)和超文本标记语言(HTML)</h3><p>URL(Uniform Resource Locator，统一资源定位符)<br>URI(Uniform Resource Identifier，统一资源标识符)</p>
<p>对于<a target="_blank" rel="noopener" href="http://www.cisco.com/index.html%EF%BC%88URL%EF%BC%89">http://www.cisco.com/index.html（URL）</a></p>
<ul>
<li>浏览器对 URL 地址的三个组成部分进行分析：http（协议或方案）、<a target="_blank" rel="noopener" href="http://www.cisco.com(服务器名称)、index.html(所请求的特定文件名)/">www.cisco.com（服务器名称）、index.html（所请求的特定文件名）</a></li>
<li>然后，浏览器将通过域名服务器将 <a target="_blank" rel="noopener" href="http://www.cisco.com/">www.cisco.com</a> 转换成数字表示的 IP 地址，用它连接到该服务器。客户端通过向服务器发送GET请求向服务器发起一个HTTP请求并请求index.html文件。</li>
<li>作为对请求的响应，服务器将此web页面的HTML代码发送到浏览器。</li>
<li>浏览器解译 HTML 代码并为浏览器窗口格式化页面。</li>
</ul>
<h3 id="HTTP-和-HTTPS"><a href="#HTTP-和-HTTPS" class="headerlink" title="HTTP 和 HTTPS"></a>HTTP 和 HTTPS</h3><p>HTTP 是一种请求/响应协议。当客户端，尤其是 Web 浏览器，发送请求到 Web 服务器时，HTTP 将指定用于该通信的消息类型。<br>常用的三种消息类型包括 GET、POST 和 PUT。</p>
<ul>
<li>  <strong>GET</strong> - 客户端请求数据。客户端（Web 浏览器）向 Web 服务器发送 GET 消息以请求 HTML 页面。</li>
<li>  <strong>POST</strong> - 上传数据文件到 Web 服务器，例如表单数据。</li>
<li>  <strong>PUT</strong> - 用于向 Web 服务器上传资源或内容，例如图像。</li>
</ul>
<p>尽管 HTTP 灵活性相当高，但它不是一个安全协议。<br>为了在互联网中进行安全通信，人们使用 HTTP 安全（HTTPS）协议。HTTPS 借助身份验证和加密来保护数据，使数据得以安全地在客户端与服务器之间传输。HTTPS 使用的客户端请求服务器响应过程与 HTTP 相同，但在数据流通过网络传输以前会使用安全套接字层 (SSL) 加密。</p>
<h3 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h3><p>邮件是通过网络发送、存储和检索电子消息的存储转发方法。邮件消息存储在邮件服务器的数据库中。<br>邮件客户端通过与邮件服务器通信来收发邮件。邮件服务器之间也会互相通信，以便将邮件从一个域发到另一个域中。也就是说，发送邮件时，邮件客户端并不会直接与另外一个邮件客户端通信。而是双方客户端均依靠邮件服务器来传输邮件。</p>
<p>电子邮件支持三种单独的协议以实现操作：简单邮件传输协议 (<strong>SMTP</strong>)、邮局协议 (<strong>POP</strong>) 和 Internet 邮件访问协议 (<strong>IMAP</strong>)。发送邮件的应用层进程会使用 SMTP。客户端会使用以下两种应用层协议之一来检索邮件：POP 或 IMAP。</p>
<h4 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h4><p>SMTP 邮件格式要求邮件具有报头和正文。虽然邮件正文没有长度限制，但邮件报头必须具有格式正确的收件人邮件地址和发件人地址。</p>
<p>当客户端发送邮件时，客户端 SMTP 进程会连接公认端口 25 上的服务器 SMTP 进程。连接建立后，客户端将尝试通过此连接<strong>发送邮件</strong>到服务器。服务器收到邮件后，如果收件人在本地，它会将邮件保存在本地账户中，或者将邮件转发给另一台邮件服务器以便传输。</p>
<p>发出邮件时，目的邮件服务器可能并不在线，或者正忙。因此，SMTP 将邮件转到后台处理，稍后再发送。服务器会定期检查邮件队列，然后尝试再次发送。经过预定义的过期时间后，如果仍然无法发送邮件，则会将其作为无法投递的邮件退回给发件人。</p>
<h4 id="POP"><a href="#POP" class="headerlink" title="POP"></a>POP</h4><p>应用程序使用 POP 从邮件服务器中<strong>检索邮件</strong>。根据 POP 的规定，邮件将从服务器下载到客户端，然后从服务器上删除。这是 POP 的默认操作。</p>
<p>服务器通过在 TCP <strong>端口 110</strong> 上被动侦听客户端连接请求来启动 POP 服务。当客户端要使用此服务时，它会发送一个请求来建立与服务器的 TCP 连接。一旦建立连接，POP 服务器即会发送问候语。然后客户端和 POP 服务器会交换命令和响应，直到连接关闭或中止。</p>
<p>根据 POP，由于电子邮件会下载到客户端并从服务器删除，因此电子邮件不会集中保存在某一特定的位置。因为 POP <strong>不存储</strong>邮件，因此不建议用于需要集中备份解决方案的小型企业。POP3 是最常用的版本。</p>
<h4 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h4><p>IMAP 是另外一种用于<strong>检索</strong>电子邮件消息的协议。与 POP 不同的是，当用户连接使用 IMAP 的服务器时，邮件的副本会下载到客户端应用程序。同时原始邮件会一直<strong>保留在服务器</strong>上，直到用户将它们手动删除。用户在自己的邮件客户端软件中查看邮件副本。</p>
<p>用户可以在服务器上创建文件层次结构来组织和保存邮件。该文件结构会照搬到邮件客户端。当用户决定删除邮件时，服务器会同步该操作，从服务器上删除对应的邮件。</p>
<h2 id="IP-编址服务"><a href="#IP-编址服务" class="headerlink" title="IP 编址服务"></a>IP 编址服务</h2><p>使用数字 IP 地址标记设备以便通过网络发送和接收数据。人们创建了可以将数字地址转换为简单易记名称的域名系统。<br>DNS (Domain Name System，域名系统)协议定义了一套自动化服务，<strong>该服务将资源名称与所需的数字网络地址匹配</strong>。协议涵盖了查询格式、响应格式及数据格式。DNS 协议通信采用单一格式，即消息格式。该格式用于所有类型的客户端查询和服务器响应、报错消息、以及服务器间的资源记录信息的传输。</p>
<h3 id="DNS-消息格式"><a href="#DNS-消息格式" class="headerlink" title="DNS 消息格式"></a>DNS 消息格式</h3><p>DNS 服务器中存储不同类型的资源记录，用来解析域名。这些记录中包含域名、地址以及记录的类型。<br>这些记录有以下类型：</p>
<ul>
<li>  <strong>A</strong> - <strong>终端</strong>设备 IPv4 地址</li>
<li>  <strong>NS</strong> - <strong>授权域名服务器</strong></li>
<li>  <strong>AAAA</strong> - <strong>终端</strong>设备 <strong>IPv6</strong> 地址（读作“四 A”）</li>
<li>  <strong>MX</strong> - <strong>邮件</strong>交换记录</li>
</ul>
<p>在客户端进行查询时，服务器 DNS 进程首先会查看<strong>自己的记录</strong>以解析名称。如果服务器不能通过自身存储的记录解析域名，它将联系<strong>其他服务器</strong>对该域名进行解析。在检索到匹配信息并将其返回到原始请求服务器后，服务器临时<strong>存储数字地址</strong>，以供再次请求同一域名时使用。</p>
<p>DNS在服务器间使用相同的消息格式，包含所有类型的客户端查询的问题、回答、授权和更多信息以及服务器响应、错误消息和服务器间的资源记录信息的传输。</p>
<p><code>ipconfig /displaydns</code>命令显示所有 DNS 缓存条目。(Windows)<br><code>nslookup</code>命令后，即显示为主机配置的默认 DNS 服务器，可以在nslookup提示符下输入主机名或域名</p>
<h4 id="DNS-层级"><a href="#DNS-层级" class="headerlink" title="DNS 层级"></a>DNS 层级</h4><p>DNS 协议采用分层系统创建数据库以提供名称解析<br><img src="/2022/02/28/%E7%BD%91%E7%BB%9C/ITN14-15/1646740214410.png"><br>不同的顶级域有不同的含义，分别代表着组织类型或起源国家/地区</p>
<h3 id="动态主机配置协议-DHCP"><a href="#动态主机配置协议-DHCP" class="headerlink" title="动态主机配置协议(DHCP)"></a>动态主机配置协议(DHCP)</h3><p>主机连入网络时，将联系 DHCP 服务器并请求地址。DHCP 服务器从已配置地址范围（也称为“地址池”）中选择一条地址，并将其分配（租赁）给主机。</p>
<p>在较大型的网络中，或者用户经常变更的网络中，地址分配优先选用 DHCP。新用户可能在到达时需要连接；其他用户可能有新计算机必须要连接。与为每个连接使用静态编址的做法相比，采用 DHCP 自动分配 IPv4 地址的方法更有效。<br>DHCP可以<strong>在一段可配置的时间内分配IP地址</strong>，这段时间称为租期。租期是一个重要的 DHCP 设置，当租期过期或 DHCP 服务器收到 DHCPRELLAME 消息时，地址将返回到 DHCP 池以便重复使用。因此，用户可以自由的移动位置，并通过DHCP随时重新连接网络。</p>
<p>很多网络都同时采用 DHCP 和静态编址。<strong>DHCP 用于</strong>一般用途主机，例如用户终端设备。<strong>静态编址用于</strong>网络设备，例如网关路由器、交换机、服务器和打印机。</p>
<h4 id="DHCP-工作原理"><a href="#DHCP-工作原理" class="headerlink" title="DHCP 工作原理"></a>DHCP 工作原理</h4><p>配置了 DHCP 的 IPv4 设备在启动或连接到网络时，<br>客户端将<strong>广播</strong>一条 DHCP <strong>1发现 (DHCPDISCOVER) 消息</strong>以确定网络上是否有可用 DHCP 服务器。<br>DHCP 服务器<strong>回复</strong> DHCP <strong>2服务 (DHCPOFFER) 消息</strong>，为客户端提供租赁服务。该服务消息包含为其分配的 IPv4 地址和子网掩码、DNS 服务器的 IPv4 地址和默认网关的 IPv4 地址。租赁服务还包括租用期限。</p>
<p>如果本地网络中有超过一台 DHCP 服务器，客户端可能会收到<strong>多条</strong> DHCPOFFER 消息。此时，客户端必须在这些服务器中进行<strong>选择</strong>，并且将包含服务器标识信息及客户端所接受的租赁服务的 DHCP <strong>3请求 (DHCPREQUEST) 消息</strong>发送出去。客户端还可选择向服务器请求分配以前分配过的地址。</p>
<p>如果客户端请求的 IPv4 地址（或者服务器提供的 IPv4 地址）<strong>仍然可用</strong>，服务器将<strong>返回</strong> DHCP <strong>4确认 (DHCPACK) 消息</strong>，向客户端确认地址租赁。如果请求的地址<strong>不再有效</strong>，则所选服务器将回复一条 DHCP <strong>否定</strong>确认 (DHCPNAK) 消息。一旦返回 DHCP NAK 消息，应<strong>重新启动</strong>选择进程，并重新发送新的 DHCP 发现消息。客户端租赁到地址后，应在租期结束前发送 DHCPREQUEST 消息进行续期。</p>
<p>DHCP 服务器确保每个 IP 地址都是唯一的（一个 IP 地址不能同时分配到不同的网络设备上）。因此，大多数ISP往往使用 DHCP 为其客户分配地址。</p>
<p><strong>DHCPv6</strong> 有一组与DHCPv4 类似的消息。DHCPv6 消息包括 SOLICIT、ADVERTISE、INFORMATION REQUEST 和 REPLY。</p>
<h2 id="文件共享服务"><a href="#文件共享服务" class="headerlink" title="文件共享服务"></a>文件共享服务</h2><h3 id="文件传输协议-FTP"><a href="#文件传输协议-FTP" class="headerlink" title="文件传输协议(FTP)"></a>文件传输协议(FTP)</h3><p>FTP 用于客户端和服务器之间的数据传输。FTP 客户端是一种在计算机上运行的应用，用于从 FTP 服务器中收发数据。</p>
<p>客户端使用 TCP 端口 21 与服务器建立第一个连接用于控制流量。流量由客户端命令和服务器应答组成。<br>客户端使用 TCP 端口 20 与服务器建立第二个连接用于实际数据传输。每当有数据需要传输时都会建立此连接。</p>
<p>数据传输可以在任何一个方向进行。客户端可以从服务器下载（取）数据，也可以向服务器上传（放）数据。</p>
<h3 id="服务器消息块-SMB"><a href="#服务器消息块-SMB" class="headerlink" title="服务器消息块(SMB)"></a>服务器消息块(SMB)</h3><p>服务器消息块 (SMB) 是一种客户端/服务器文件共享协议，用于规范共享网络资源（如目录、文件、打印机以及串行端口）结构。这是一种请求-响应协议。所有的 SMB 消息都采用一种常用格式。该格式采用固定大小的文件头，后跟可变大小的参数以及数据组件。<br>三个功能：</p>
<ul>
<li>  启动、身份验证以及终止会话</li>
<li>  控制文件和打印机的访问</li>
<li>  允许应用程序向任何设备收发消息<br>Microsoft 网络配置中主要采用 SMB 形式实现文件共享和打印服务。</li>
</ul>
<p>与 FTP 协议支持的文件共享不同，SMB 协议中的客户端要与服务器建立长期连接。一旦建立连接，客户端用户就可以访问服务器上的资源，就如同资源位于客户端主机上一样。</p>

      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dyinjin"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">dyinjin</p>
  <div class="site-description" itemprop="description">摸鱼窝</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fas fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dyinjin</span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">本博客全站共188.2k字呐~</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,120,50' opacity='0.3' zIndex='-2' count='100' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
<div class="moon-menu">
  <div class="moon-menu-items">
    
    <div id="moon-menu-item-back2bottom" class="moon-menu-item">
      <i class='fas fa-chevron-down'></i>    </div>
    
    <div id="moon-menu-item-back2top" class="moon-menu-item">
      <i class='fas fa-chevron-up'></i>    </div>
    
  </div>
  <div class="moon-menu-button">
    <svg class="moon-menu-bg">
      <circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle>
      <circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle>
    </svg>
    <div class="moon-menu-content">
      <div class="moon-menu-icon"><i class='fas fa-ellipsis-v'></i></div>
      <div class="moon-menu-text"></div>
    </div>
  </div>
</div><script src="/js/injector.js"></script>
</body>
</html>
