<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":250,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":false,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="摸鱼窝">
<meta property="og:type" content="website">
<meta property="og:title" content="岛屿尽">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="岛屿尽">
<meta property="og:description" content="摸鱼窝">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="dyinjin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<link rel="stylesheet" type="text/css" href="/css/injector/main.css" /><link rel="preload" as="style" href="/css/injector/light.css" /><link rel="preload" as="style" href="/css/injector/dark.css" />
  <title>岛屿尽</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">岛屿尽</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">dyingjin</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-cube fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-bookmark fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-cubes fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-server fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/26/MC/debugfile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/26/MC/debugfile/" class="post-title-link" itemprop="url">minecraft making log</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-26 17:02:45" itemprop="dateCreated datePublished" datetime="2021-09-26T17:02:45+08:00">2021-09-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-22 17:58:26" itemprop="dateModified" datetime="2022-04-22T17:58:26+08:00">2022-04-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MC/" itemprop="url" rel="index"><span itemprop="name">MC</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/2021/09/26/MC/debugfile/ti.png" alt="2021-12-04_16"></p>
<h1 id="模组部分"><a href="#模组部分" class="headerlink" title="模组部分"></a>模组部分</h1><p>按时间顺序【由近及远】</p>
<h2 id="【结构】大型结构Shrines-1-16-5-2-0-0-Beta8"><a href="#【结构】大型结构Shrines-1-16-5-2-0-0-Beta8" class="headerlink" title="【结构】大型结构Shrines-1.16.5-2.0.0-Beta8"></a>【结构】大型结构Shrines-1.16.5-2.0.0-Beta8</h2><p>加载闪退(毕竟BETA)<br>日志fatal报错：</p>
<figure class="highlight plaintext"><figcaption><span>apply failed mixins.shrines.json:MixinMinecraftServer -> net.minecraft.server.MinecraftServer:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">org.spongepowered.asm.mixin.injection.throwables.InvalidInjectionException Critical injection failure: @Inject annotation on onConfigurePackRepository could not find any targets matching &#x27;configurePackRepository&#x27; in net.minecraft.server.MinecraftServer. </span><br><span class="line">No refMap loaded. [PREINJECT Applicator Phase -&gt; mixins.shrines.json:MixinMinecraftServer -&gt; Prepare Injections -&gt;  -&gt; </span><br><span class="line">handler$bbi000$onConfigurePackRepository(.../mixin/injection/callback/CallbackInfoReturnable;)V -&gt; Parse]</span><br><span class="line">org.spongepowered.asm.mixin.injection.throwables.InvalidInjectionException: Critical injection failure: @Inject annotation on onConfigurePackRepository could not find any targets matching </span><br><span class="line">&#x27;configurePackRepository&#x27; in net.minecraft.server.MinecraftServer. No refMap loaded. [PREINJECT Applicator Phase -&gt; </span><br><span class="line">mixins.shrines.json:MixinMinecraftServer -&gt; Prepare Injections -&gt;  -&gt; handler$bbi000$onConfigurePackRepository(.../mixin/injection/callback/CallbackInfoReturnable;)V -&gt; Parse]</span><br></pre></td></tr></table></figure>
<p>有：<br>InvalidInjectionException严重注入失败：@onConfigurePackRepository上的injection批注在网络中找不到任何与“configurePackRepository”匹配的目标。我的世界。服务器MinecraftServer。未加载参考地图。<br>更换为BETA7版本正常</p>
<h2 id="某生物附魔模组更新后"><a href="#某生物附魔模组更新后" class="headerlink" title="某生物附魔模组更新后"></a>某生物附魔模组更新后</h2><p>更新后会生物附魔详情会以名称形式显示（很长很难看）<br>找出来了，是【生物】【前置24】地下城怪物dungeons_mobs-1.16.5-2.0.1-beta（测试版？）<br>暂时配置中关闭附魔功能（另有模组——稀有精英怪）</p>
<h2 id="变异骷髅闪退"><a href="#变异骷髅闪退" class="headerlink" title="变异骷髅闪退"></a>变异骷髅闪退</h2><ul>
<li>【生物】变异生物MutantBeasts-1.16.4-1.1.3.jar</li>
<li>生成的变异骷髅似乎在一个跳跃动作后便会使整合包闪退</li>
<li>其它生物均无此现象</li>
<li>可能与实体优化相关模组有关#待解决</li>
<li>已排除：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">【优化】实体剔除EntityCulling-1.16.5-2.1.6</span><br><span class="line">【优化】生物加载performant-1.16.2-5-3.77m</span><br><span class="line">【优化】渲染优化（针对多人） out_of_sight-1.16.4-1.0.1</span><br><span class="line">……</span><br><span class="line">所有【优化】</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="BYG草甸方块材质？"><a href="#BYG草甸方块材质？" class="headerlink" title="BYG草甸方块材质？"></a>BYG草甸方块材质？</h2><ul>
<li>现象为草甸方块放在任意草方块、泥土方块上直接变透明</li>
<li>应该是模组冲突导致，与草坪优化相关</li>
<li>【装饰】【前置30】更好的树叶BetterFoliage-2.7.1-Forge-1.16.5.jar由此模组导致此模组识别各个模组的草方块、树叶方块等再基于原本材质进行修饰(如跟丰富的树叶)，可能草甸方块不是简单的草方块换皮，所以有BUG(可通过设置改变，其提供的设置十分详细和丰富)</li>
</ul>
<h2 id="【杂项】快速树叶腐烂FastLeafDecay-v25-jar导致（这个BUG价值三天）"><a href="#【杂项】快速树叶腐烂FastLeafDecay-v25-jar导致（这个BUG价值三天）" class="headerlink" title="【杂项】快速树叶腐烂FastLeafDecay-v25.jar导致（这个BUG价值三天）"></a>【杂项】快速树叶腐烂FastLeafDecay-v25.jar导致（这个BUG价值三天）</h2><ul>
<li>整合包加入了非常的群系性结构性影响生成世界的模组，</li>
<li>在创造新的世界时约有30%的可能卡死</li>
<li>(表现为并非未响应，但加载百分比长时间不变化，任务管理器占用内存变化幅度非常小，如果打开日志的话可以观察到已经在卡死前报错fatal了，只是并没有彻底的阶数游戏进程而且也不再继续)</li>
<li>最后分析可能与树叶检测有关：在生成世界时部分模组已经生成树叶，部分还没有生成，而本模组在生成时就已经开始执行检测？造成冲突？！</li>
</ul>
<h2 id="区块预生成Chunk-Pregenerator"><a href="#区块预生成Chunk-Pregenerator" class="headerlink" title="区块预生成Chunk-Pregenerator"></a>区块预生成Chunk-Pregenerator</h2><ul>
<li>在选择世界生成类型的下方会有一个按钮</li>
<li>在其中点击start便可以预生成区块</li>
</ul>
<h2 id="优化性模组"><a href="#优化性模组" class="headerlink" title="优化性模组"></a>优化性模组</h2><p>在大型整合包中年尤为重要</p>
<h3 id="Out-Of-Sight-机翻"><a href="#Out-Of-Sight-机翻" class="headerlink" title="Out Of Sight(机翻)"></a>Out Of Sight(机翻)</h3><p>厌倦了你的邻居巨大的模板工厂基地 （你甚至看不到大部分时间） 降低你的框架？这个模组是你需要的！<br>如果磁贴实体距离远超过 24 个街区，则”视线外”只需停止它们的渲染，并且您可以在配置文件中将此范围配置到最适合您的任何范围。<br>它还支持实体，一些模组用于渲染 fps 重功能。<br>在一个完美的世界中，每个模组都经过优化和良好的测试，但与通常包含超过 100 模组的模组包，这个世界并不存在。所以我这样做， 使多人模组更可玩！<br><strong>优点：</strong></p>
<ul>
<li>在繁忙的复杂基地附近， 包含大量模板实体和实体 （如机器、灯光等） 的框架速度非常好</li>
<li>客户端仅模组</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>当你走近时， 更明显的弹出的实体和瓷砖实体</li>
</ul>
<h3 id="ferritecore-机翻"><a href="#ferritecore-机翻" class="headerlink" title="ferritecore(机翻)"></a>ferritecore(机翻)</h3><p>此模组以几种不同的方式减少了 Minecraft 的内存使用。此处提供了有关更改的高级别技术描述。<br>保存的内存量将取决于模组，在 1.16.4 Direwolf20 包的 1.2.0 版本中，它大约将标题屏幕上的内存使用量（GC 之后）从 3.1 GB 减少到 1.1-1.2 GB。</p>
<h3 id="smoothboot-机翻"><a href="#smoothboot-机翻" class="headerlink" title="smoothboot(机翻)"></a>smoothboot(机翻)</h3><p>平滑启动 - 优化 Minecraft 装载性能，使低端系统更平滑，高端系统规模更好。<br>如果您的 PC 具有较旧或低端 CPU（前 CPU 具有 8 个或更少的线程），您可能已经注意到 Minecraft 在加载到标题屏幕时占用了 CPU 的 100%，导致光标口吃，使多任务处理变得非常困难。平滑启动可以完全解决这个问题，加载应该更顺畅，而且可能更快。</p>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul>
<li>  更改用于加载的线程数量</li>
<li>  更改 Minecraft 使用的线程的优先级</li>
</ul>
<h4 id="模组的工作原理"><a href="#模组的工作原理" class="headerlink" title="模组的工作原理"></a>模组的工作原理</h4><p>Minecraft 使用执行器执行多重任务。问题是，在加载过程中运行的任务在 CPU 上相当繁重，因此它会导致 100% CPU 使用。而且，有些任务不一定受益于多阅读。平滑引导通过更改执行者的参数（包括其使用的线程数和每个线程的优先级）来修复这些问题。<br>欲了解更多信息，请阅读<a target="_blank" rel="noopener" href="https://github.com/UltimateBoomer/mc-smoothboot/wiki">平滑启动维基</a></p>
<h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><p>模组应与所有模组兼容，包括 Optifine。但是，值得注意的是，模组使用混合素覆盖用于加载游戏的某些方法。</p>
<h3 id="Entity-Culling-机翻"><a href="#Entity-Culling-机翻" class="headerlink" title="Entity Culling(机翻)"></a>Entity Culling(机翻)</h3><p><strong>实体剔除</strong>是一个相对较小的客户端性能核心模组，旨在跳过隐藏（磁贴）实体的渲染。<br>在香草中，它只呈现玩家视野中的所有（瓷砖）实体。这意味着可能有成百上千的 （瓷砖） 实体吃你的 fps， 而你甚至看不到他们， 因为他们隐藏在墙后。<br><strong>剔除隐藏实体</strong><br>此模组光线跟踪另一个线程，以检查（瓷砖实体）是否可见。因为这种方法不是100%准确的每个（瓷砖）实体，不被认为是可见的开放gl遮挡测试将作出。<br>当许多（瓷砖）实体不可见时，这可能导致大量 fps 改进。同时，当大多数（瓷砖）实体可见时，也只有最低限度的开销。<br><strong>阴影的配置选项（当使用视网膜和带阴影的阴影的阴影时）</strong><br>此模组还添加了一些配置选项，以在安装视光素和使用带阴影的阴影的阴影器时调整阴影的渲染。<br>某些阴影器可能会提供配置选项来调整阴影渲染距离。但问题是，所有被认为太远的实体、瓷砖实体和块的阴影仍将由 cpu 处理，然后由遮光板扔掉。<br>此模组允许用户指定实体、瓷砖实体和地形的最大阴影距离。<br>或者，它还允许完全跳过实体、瓷砖实体或地形阴影的渲染。</p>
<h3 id="performant-机翻"><a href="#performant-机翻" class="headerlink" title="performant(机翻)"></a>performant(机翻)</h3><p><strong>最显著的功能：</strong><br>所有功能均可配置，可在配置中调整/启用/禁用。<br><strong>减少 AI 开销</strong><br>AI 不再花费一半的时间来决定他们应该执行哪些任务<br><strong>实体碰撞和路径的多重读数</strong><br>实体更新、碰撞路径和移动的昂贵部分更快，并且发生多重阅读。<br><strong>AI/实体、磁体和事件的负载平衡</strong><br>负载平衡是一种更具侵入性的机械师，以限制滞后罪犯，它可能会影响其他模组的功能，但只有在您的游戏已经落后时才会变得活跃起来。它通过定期检查服务器的 tps 以及它是否低于配置负载平衡中的阈值而工作。然后，它开始配置 AI/实体、Tileent 和事件，以确定谁导致最多的滞后，并限制其更新与这些源导致的滞后。这主要是一个功能，以保持你的游戏可玩，而一些特定的滞后来源通常会把它带到它的膝盖。<br><strong>FPS</strong><br>用于渲染实体的 FPS 得到改进，但仅对客户端的改进很少。<br><strong>登录/播放超时</strong><br>可配置的登录超时，用于在游戏期间登录和断开连接，帮助使用较慢 PC 和连接的玩家。<br><strong>食谱缓存</strong><br>食谱查找得到快得多，帮助所有这些自动制作的模组在那里造成滞后时，通过大量的食谱。<br><strong>快速世界更新</strong><br>随机块和块滴答声整体速度更快，性能成本更低。<br><strong>可配置的公用设施</strong><br>禁用实体生成特定类型的实体。<br>显示非正常块负载的调试设置。<br>用于显示的调试设置</p>
<h2 id="【结构】【前置40】valhelsia-structures-1-16-5-0-1-6-jar"><a href="#【结构】【前置40】valhelsia-structures-1-16-5-0-1-6-jar" class="headerlink" title="【结构】【前置40】valhelsia_structures-1.16.5-0.1.6.jar"></a>【结构】【前置40】valhelsia_structures-1.16.5-0.1.6.jar</h2><ul>
<li>本身是别人整合包用的</li>
<li>但是在生成结构的时候，其特殊的代码(貌似调用结构使用方块时会用其特别标志替代，有时会不切换回方块本身)会使草方块(本应是)变为透视方块</li>
<li>貌似是JAVA版本要求比较严格-其建议JAVA8</li>
</ul>
<h2 id="【前置10】【辅助】jei-1-16-5-7-7-1-110-jar-old"><a href="#【前置10】【辅助】jei-1-16-5-7-7-1-110-jar-old" class="headerlink" title="【前置10】【辅助】jei-1.16.5-7.7.1.110.jar.old"></a>【前置10】【辅助】jei-1.16.5-7.7.1.110.jar.old</h2><ul>
<li>jei这之后的几个版本不能使用标签搜索。。</li>
<li>jei-1.16.5-7.7.1.136此版本可以了</li>
</ul>
<h2 id="【生物】-BETA-dannys-expansion1-16-5-1-0-9-1-jar"><a href="#【生物】-BETA-dannys-expansion1-16-5-1-0-9-1-jar" class="headerlink" title="【生物】[BETA]dannys_expansion1.16.5-1.0.9.1.jar"></a>【生物】[BETA]dannys_expansion1.16.5-1.0.9.1.jar</h2><ul>
<li>非常优质的生物模组</li>
<li>待更新或手动调整（生成和掉落物还有问题）</li>
</ul>
<h2 id="风铃chime模组"><a href="#风铃chime模组" class="headerlink" title="风铃chime模组"></a>风铃chime模组</h2><ul>
<li>在1.16.5中缺少与模组衔接的铜风铃合成表与紫水晶风铃合成表</li>
<li>计划通过kubejs手动添加（已添加）</li>
</ul>
<h2 id="【前置13】【生物】【前置12】mysticalworld-1-16-5-0-3-5-24"><a href="#【前置13】【生物】【前置12】mysticalworld-1-16-5-0-3-5-24" class="headerlink" title="【前置13】【生物】【前置12】mysticalworld-1.16.5-0.3.5.24"></a>【前置13】【生物】【前置12】mysticalworld-1.16.5-0.3.5.24</h2><ul>
<li>此版本银与水银物品贴图有部分混淆</li>
<li>以简单修复</li>
</ul>
<h2 id="【辅助】工具栏inventorio-1-16-forge-1-6-1-jar"><a href="#【辅助】工具栏inventorio-1-16-forge-1-6-1-jar" class="headerlink" title="【辅助】工具栏inventorio-1.16-forge-1.6.1.jar"></a>【辅助】工具栏inventorio-1.16-forge-1.6.1.jar</h2><ul>
<li>此模组提供的额外工具栏位以及自动切换系统较方便</li>
<li>但存在三叉戟等蓄力投掷物无法右击蓄力释放的问题</li>
<li>暂无解决方法</li>
</ul>
<h2 id="Forgotten-Treasures-已弃用"><a href="#Forgotten-Treasures-已弃用" class="headerlink" title="Forgotten+Treasures(已弃用)"></a>Forgotten+Treasures(已弃用)</h2><p>以下问题已查明，系此模组<code>Forgotten+Treasures</code>导致<br><img src="https://raw.githubusercontent.com/dyinjin/xiaoshujiang/main/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1635869592303.png" alt="enter description here"></p>
<ul>
<li>“耕地消失术”表现为自然村庄耕地或玩家耕地在玩家身边几秒内变为普通泥土</li>
<li>钟乳石问题<del>在更新为<code>【前置4】cavebiomeapi-1.16.5-1.4.1.jar 【群系】【前置4】cavesandcliffs-1.16.5-7.0.jar</code>后，钟乳石刷新异常：</del>bs表现为如沙子一样的下落特性，且肉眼可见的作为实体间断刷新</li>
</ul>
<h2 id="Epic-Fight-Mod"><a href="#Epic-Fight-Mod" class="headerlink" title="Epic Fight Mod"></a>Epic Fight Mod</h2><ul>
<li>本模组由于为僵尸村民也修改了动作，使用任何其它模组中的僵尸村民都将出现贴图错误。</li>
<li>本模组对生物也进行了修改，模组生物不会受到本模组的控制。</li>
<li>本模组对装备显示兼容(如旅行者背包)正在更新</li>
</ul>
<h2 id="更好的第一人称视角与地下城武器"><a href="#更好的第一人称视角与地下城武器" class="headerlink" title="更好的第一人称视角与地下城武器"></a>更好的第一人称视角与地下城武器</h2><ul>
<li>无法正常使用双持武器与弩</li>
<li>地下城武器同样与村民守卫模组不能很好兼容(村民守卫无法使用模组中的弩)</li>
</ul>
<h2 id="“弱响应？”"><a href="#“弱响应？”" class="headerlink" title="“弱响应？”"></a>“弱响应？”</h2><ul>
<li>测试时，在进入末地或末地加载千格左右时出现，表现为区块不在加载(甚至直接可以下到原本的地形中)，实体不再响应(生物、掉落物、箱子)，而方块的放置不受影响</li>
<li><DEL>查看日志，在多次排除法h后确定其报错为<code>GL ERROR 65539: invalid key -1</code></DEL></li>
<li>简单更换JAVA版本无法解决</li>
<li><del>经过去除部分模组，确认为模组原因，确定系byg1.3.5导致</del></li>
</ul>
<h2 id="Druidcraft"><a href="#Druidcraft" class="headerlink" title="Druidcraft"></a>Druidcraft</h2><ul>
<li>其0.4.53出现接骨木树花朵材质丢失问题</li>
<li>作者已在0.4.54修复，很快啊(这种bug还要我来de-?)</li>
</ul>
<h2 id="BYG与BOP"><a href="#BYG与BOP" class="headerlink" title="BYG与BOP"></a>BYG与BOP</h2><ul>
<li>两大高版本群系模组</li>
<li>其实由于BOP生成是特殊生成模式，所以冲突在所难免</li>
<li>又有”【优化】生物群系修复(争对新添加群系)biomeidfixer-1.16.5-1.0.1.s4”与”【优化】【前置15】byg群系生成修复chocolate-1.3.0-1.16.4”能够对此问题进行修复</li>
<li>但我混合正常使用只能在两百加模组的全部整合中成功，推测另有模组旁敲侧击的解决了问题</li>
<li>使用单独以上两个修复模组不能使BYG与BOP在BOP群系下正常使用</li>
</ul>
<h2 id="【群系】【前置4】CavesAndCliffsBackport-1-16-5-6-3-jar"><a href="#【群系】【前置4】CavesAndCliffsBackport-1-16-5-6-3-jar" class="headerlink" title="【群系】【前置4】CavesAndCliffsBackport-1.16.5-6.3.jar"></a>【群系】【前置4】CavesAndCliffsBackport-1.16.5-6.3.jar</h2><ul>
<li>目前此模组及其前置共添加了三种地下群系（cavesandcliffs:lush_caves/cavebiomeapi:caves/cavesandcliffs:dripstone_caves）鉴于普通模组没有特别涉及地下生成设置会致使以上群系生物过于单一，故特别添加生成设置</li>
<li>此模组【前置4】系”【前置4】cavebiomeapi-1.16.5-1.3.7.jar”存在一定的特殊性（鉴于在1.17以下还原三维群系此前置模组特加入了三维群系），具观察加入三维群系方式过于暴力（指定一定深度以下为洞穴群系），可能兼容性较差</li>
<li>此模组的创建世界卡死为间歇性，有待进一步确定</li>
<li>关于此模组受特定世界类型影响导致的：地下全是繁茂洞穴、滴水洞穴的问题，或地下完全不存在此模组添加的以上两种群系的问题。目前推断为旧版本问题</li>
</ul>
<h2 id="【音效】动态环绕4-26DynamicSurroundings-1-16-4-4-0-4-2-jar"><a href="#【音效】动态环绕4-26DynamicSurroundings-1-16-4-4-0-4-2-jar" class="headerlink" title="【音效】动态环绕4.26DynamicSurroundings-1.16.4-4.0.4.2.jar"></a>【音效】动态环绕4.26DynamicSurroundings-1.16.4-4.0.4.2.jar</h2><ul>
<li>此模组添加了真实的音效系统，较好的解决了隔墙听声问题</li>
<li>此模组目前以确认可能导致已创建世界无法加载进入问题，日志报错”SoundControl Sound Processor is lagging”，暂停使用后即可成功进入</li>
<li>以上问题目前推测为角色生处方块内部物理声效无法计算所导致（例如处在观察者模式在地下退出世界后重新加入时）</li>
</ul>
<h2 id="【优化】储物抽屉优化drawerfps-2-1-jar"><a href="#【优化】储物抽屉优化drawerfps-2-1-jar" class="headerlink" title="【优化】储物抽屉优化drawerfps-2.1.jar"></a>【优化】储物抽屉优化drawerfps-2.1.jar</h2><ul>
<li>此模组系解决”【杂项】储物抽屉StorageDrawers-1.16.3-8.2.2”所导致的间歇性掉帧问题，效果良好<br><del>* 但此观察此模组系通过在一定范围外不加载“抽屉”单元贴图来解决问题，这常常间歇性导致正常地形方块成片贴图不加载（同种类或不同种类，多数情况下为树干贴图消失、岩壁贴图消失等）同时系统直接报错”OpenGL Error 1281: Invalid Value”（此报错可能原因多样，经多次尝试发现系此模组导致）</del></li>
<li>见下OpenGL</li>
</ul>
<h2 id="Error-adding-element-Base-value-out-of-range-256-10-128"><a href="#Error-adding-element-Base-value-out-of-range-256-10-128" class="headerlink" title="Error adding element: Base value out of range: 256 [-10-128]"></a>Error adding element: Base value out of range: 256 [-10-128]</h2><p>Adding onto the list: betterdefaultbiomes gives warnings whenever this mod (2.2.0) is introduced, the same lag spike as faeldray mentioned happens every 5mins</p>
<ul>
<li>【群系拓展】更好的群系BetterDefaultBiomes-1.16.4+-Alpha 2.6.1 导致？不是</li>
<li>好像无伤大雅？</li>
</ul>
<h2 id="varint-too-big"><a href="#varint-too-big" class="headerlink" title="varint too big"></a>varint too big</h2><p>在连接自己的模组服的时候发生<br><img src="/2021/09/26/MC/debugfile/1647423239616.png" alt="enter description here"><br>好像是Terrain模组导致<code>【风味拓展】【自然】【装饰】装饰性环境植物terraincognita-1.16.3-1.7.1.1.jar</code></p>
<h1 id="生成调整-待记录"><a href="#生成调整-待记录" class="headerlink" title="生成调整(待记录)"></a>生成调整(待记录)</h1><h2 id="矿石"><a href="#矿石" class="headerlink" title="矿石"></a>矿石</h2><ul>
<li>生成铜的模组有三个，太多了，关闭两个（一个设为1）</li>
<li>wyrmroost中生成的铂矿太多了，且不可调控，通过强制修改掉落物，使其掉落NNOW中提供的兼容铂粒(好蠢后面发现拿kube可以直接改)</li>
<li>锡也有两个模组在生成，降低了比例</li>
<li>铅也调整了在mysticalworld中配置的生成高度等</li>
</ul>
<h2 id="生物"><a href="#生物" class="headerlink" title="生物"></a>生物</h2><p>其实之前通过“【辅助】生物生成管理SpawnBalanceUtility-1.36.0.11.jar”改过很多，当时没有做记录，现在可能也忘了<br>原版生物<br>各种水生物<br>三洞穴群系<br>BOSS(特指有屏幕血条的生物)</p>
<p>以下正式记录</p>
<h3 id="减少"><a href="#减少" class="headerlink" title="减少"></a>减少</h3><ul>
<li>‘minecraft_earth_mod:系列<br>虽然只有10的weight但有各种牛<br>故将其中的牛下调为5<br>(除 minecraft_earth_mod:wooly_cow在寒带将15下调为10)<br>其中又给viler女巫下调为5，并减少群系</li>
</ul>
<h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><ul>
<li>河流、湖泊、沼泽、洞穴的鱼类<br>河流<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">minecraft:river</span><br><span class="line">mysticalbiomes:petrified_river</span><br><span class="line">mysticalbiomes:sprout_river</span><br><span class="line">mysticalbiomes:uncanny_river</span><br><span class="line">minecraft:frozen_river</span><br></pre></td></tr></table></figure>
湖泊<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">betterendforge:megalake（the_end</span><br><span class="line">betterendforge:megalake_grove（the_end</span><br><span class="line">biomesoplenty:coniferous_lakes</span><br><span class="line">biomesoplenty:grove_lakes</span><br><span class="line">byg:fresh_water_lake</span><br><span class="line">byg:frozen_lake</span><br><span class="line">byg:great_lake_isles</span><br><span class="line">byg:great_lakes</span><br><span class="line">byg:polluted_lake</span><br><span class="line">genericeco:cold_lake</span><br><span class="line">genericeco:frozen_lake</span><br><span class="line">genericeco:great_lakes</span><br><span class="line">genericeco:lake</span><br><span class="line">genericeco:lukewarm_lake</span><br><span class="line">genericeco:red_desert_lakes</span><br><span class="line">genericeco:warm_lake</span><br><span class="line">minecraft:desert_lakes</span><br><span class="line">projectvibrantjourneys:crystal_lakes</span><br></pre></td></tr></table></figure>
沼泽<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">byg:cold_swamplands</span><br><span class="line">byg:cypress_swamplands</span><br><span class="line">byg:vibrant_swamplands</span><br><span class="line">byg:mangrove_marshes</span><br><span class="line">byg:marshlands</span><br><span class="line">environmental:marsh</span><br><span class="line">environmental:mushroom_marsh</span><br><span class="line">genericeco:dark_swampland</span><br><span class="line">genericeco:dark_swampland_marshes</span><br><span class="line">genericeco:dense_marsh</span><br><span class="line">genericeco:lush_swamp</span><br><span class="line">genericeco:lush_swamp_marshes</span><br><span class="line">genericeco:marsh</span><br><span class="line">genericeco:swamp_marshes</span><br><span class="line">minecraft:swamp</span><br><span class="line">projectvibrantjourneys:mangrove_marsh</span><br></pre></td></tr></table></figure>
洞穴<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cavebiomeapi:caves</span><br><span class="line">cavesandcliffs:dripstone_caves</span><br><span class="line">cavesandcliffs:lush_caves</span><br><span class="line">darkerdepths:crystal_cave</span><br><span class="line">darkerdepths:glowshroom_caves</span><br></pre></td></tr></table></figure>
byg:dead_sea</li>
</ul>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="Better-Minecraft-FORGE-v34"><a href="#Better-Minecraft-FORGE-v34" class="headerlink" title="Better Minecraft [FORGE] v34"></a>Better Minecraft [FORGE] v34</h2><p>在此版本后，项目组不再使用Global Data- &amp; Resourcepacks (by JTK222)模组</p>
<h2 id="data-get-entity-p-SelectedItem"><a href="#data-get-entity-p-SelectedItem" class="headerlink" title="/data get entity @p SelectedItem"></a><code>/data get entity @p SelectedItem</code></h2><p>查看手持物品详细数据<br>非常有用</p>
<h2 id="OpenGL-Error-1281-Invalid-Value"><a href="#OpenGL-Error-1281-Invalid-Value" class="headerlink" title="OpenGL Error 1281: Invalid Value"></a><code>OpenGL Error 1281: Invalid Value</code></h2><p><del>老问题，不只是“【优化】储物抽屉优化drawerfps-2.1.jar”的原因，这次表现为水体透明<br>好家伙不查不知道，首先看看OpenGL是个啥吧：<br><code>OpenGL（英语：Open Graphics Library，译名：开放图形库或者“开放式图形库”）是用于渲染2D、3D矢量图形的跨语言、跨平台的应用程序编程接口（API）。这个接口由近350个不同的函数调用组成，用来绘制从简单的图形比特到复杂的三维景象。而另一种程序接口系统是仅用于Microsoft Windows上的Direct3D。OpenGL常用于CAD、虚拟现实、科学可视化程序和电子游戏开发。</code><br>总之不只是我的世界高清修复在用<br>那么看了一下日志，发现和一个叫VBO的东西相关，一查：<br><code>顶点缓存对象（VBO）准许顶点数组数据存放在服务端的高性能显卡内存中，且提供高效数据传输。</code><br>又有知乎大佬说和做水效相关，那么找对问题了，但怎么解决。。。</del></p>
<ul>
<li>与JAVA版本有关</li>
<li>尝试关闭Optifine提供的性能设置中的区域渲染</li>
</ul>

      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/02/%E5%B5%8C%E5%85%A5%E5%BC%8F/ARM%E7%9F%A5%E8%AF%86%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/02/%E5%B5%8C%E5%85%A5%E5%BC%8F/ARM%E7%9F%A5%E8%AF%86%E7%82%B9/" class="post-title-link" itemprop="url">ARM知识点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-02 15:59:33" itemprop="dateCreated datePublished" datetime="2022-06-02T15:59:33+08:00">2022-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-04 20:08:36" itemprop="dateModified" datetime="2022-06-04T20:08:36+08:00">2022-06-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="多少位"><a href="#多少位" class="headerlink" title="多少位"></a>多少位</h1><p>ARM是32bit处理器，所以它的<br><strong>字是32bit</strong>的。0x0000 0000<br><strong>半字</strong>自然就是<strong>16bit</strong>；0x0000<br><strong>字节</strong>不论在哪个CPU上都是<strong>8bit</strong>。0x00</p>
<h1 id="NZCV"><a href="#NZCV" class="headerlink" title="NZCV"></a>NZCV</h1><h2 id="N-1为负-0为正"><a href="#N-1为负-0为正" class="headerlink" title="N 1为负 0为正"></a>N 1为负 0为正</h2><p>本位设置成当前指令执行结果的第31位。当两个由补码<br>表示的有符号整数运算时，N=1 表示结果为负数；否则结果<br>为正数或零</p>
<h2 id="Z-1为零-0为非零"><a href="#Z-1为零-0为非零" class="headerlink" title="Z 1为零 0为非零"></a>Z 1为零 0为非零</h2><p>Z=1 表示运算的结果为零，否则结果不为零</p>
<h2 id="C-加进1-减借0"><a href="#C-加进1-减借0" class="headerlink" title="C 加进1 减借0"></a>C 加进1 减借0</h2><p>分 4 种情况： </p>
<ol>
<li>在加法指令中（包括比较指令CMN），当结果产生了进位，则C=1，表示无符号数运算发生上溢出，其它 情况下C=0</li>
<li>在减法指令中（包括比较指令CMP），当运算中发生了借位，则C=0，其它情况下C=1</li>
<li>对于在操作数中包含移位操作的运算指令（非加/减指令），C被设置成被移位寄存器最后移出去的位</li>
<li>对于其它非加/减法运算指令，C的值通常不受影响</li>
</ol>
<h2 id="V-溢出1"><a href="#V-溢出1" class="headerlink" title="V 溢出1"></a>V 溢出1</h2><p>分两种情况：</p>
<ol>
<li>对于加/减运算指令，当操作数和运算结果都是以二进制的补码表示的带符号的数时，且运算结果超出了有符号运算的范围时溢出。V=1 表示符号位溢出</li>
<li>对于非加/减法指令，通常不改变标志位 V 的值</li>
</ol>
<h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><p><img src="/2022/06/02/%E5%B5%8C%E5%85%A5%E5%BC%8F/ARM%E7%9F%A5%E8%AF%86%E7%82%B9/1654160831657.png" alt="enter description here"></p>
<h2 id="ARM-指令有几种寻址方式"><a href="#ARM-指令有几种寻址方式" class="headerlink" title="ARM 指令有几种寻址方式"></a>ARM 指令有几种寻址方式</h2><p>ARM 指令有 8 种寻址方式。分别是：<br>立即数寻址、寄存器寻址、寄存器移位寻址、寄存器间接寻址、基址变址寻址、多寄存器寻址、堆栈寻址、相对寻址</p>
<h2 id="LDM-STM"><a href="#LDM-STM" class="headerlink" title="LDM/STM"></a>LDM/STM</h2><table>
<thead>
<tr>
<th>寻址方式</th>
<th>说明</th>
<th>pop</th>
<th>=LDM</th>
<th>push</th>
<th>=STM</th>
</tr>
</thead>
<tbody><tr>
<td>FA</td>
<td>递增满</td>
<td>LDM<strong>FA</strong></td>
<td>LDMDA</td>
<td>STM<strong>FA</strong></td>
<td>STMIB</td>
</tr>
<tr>
<td>FD</td>
<td>递减满</td>
<td>LDM<strong>FD</strong></td>
<td>LDMIA</td>
<td>STM<strong>FD</strong></td>
<td>STMDB</td>
</tr>
<tr>
<td>EA</td>
<td>递增空</td>
<td>LDM<strong>EA</strong></td>
<td>LDMDB</td>
<td>STM<strong>EA</strong></td>
<td>STMIA</td>
</tr>
<tr>
<td>ED</td>
<td>递减空</td>
<td>LDM<strong>ED</strong></td>
<td>LDMIB</td>
<td>STM<strong>ED</strong></td>
<td>STMDA</td>
</tr>
</tbody></table>
<h3 id="多寄存器"><a href="#多寄存器" class="headerlink" title="多寄存器"></a>多寄存器</h3><table>
<thead>
<tr>
<th>类型</th>
<th>每次基址寄存器操作</th>
<th>传送起始地址</th>
<th>Rn序号变化</th>
</tr>
</thead>
<tbody><tr>
<td>IA</td>
<td>先传数据，后基址加4</td>
<td>(Rn)</td>
<td>+</td>
</tr>
<tr>
<td>IB</td>
<td>先基址加4，后传数据</td>
<td>(Rn)+4</td>
<td>+</td>
</tr>
<tr>
<td>DA</td>
<td>先传数据，后基址减4</td>
<td>(Rn)</td>
<td>-</td>
</tr>
<tr>
<td>DB</td>
<td>先基址减4，后传数据</td>
<td>(Rn)-4</td>
<td>-</td>
</tr>
<tr>
<td>无论如何高寄存器高地址</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><table>
<thead>
<tr>
<th>类型</th>
<th>堆栈类型</th>
<th>pop</th>
<th>push</th>
</tr>
</thead>
<tbody><tr>
<td>FA</td>
<td>递增满</td>
<td>LDMFA</td>
<td>STMFA</td>
</tr>
<tr>
<td>FD</td>
<td>递减满</td>
<td>LDMFD</td>
<td>STMFD</td>
</tr>
<tr>
<td>EA</td>
<td>递增空</td>
<td>LDMEA</td>
<td>STMEA</td>
</tr>
<tr>
<td>ED</td>
<td>递减空</td>
<td>LDMED</td>
<td>STMED</td>
</tr>
<tr>
<td>常用现场保与恢复</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>STMFD SP!，{R0 - R7，LR}；现场保存，将R0～R7、LR入栈，SP值更新 。</li>
<li>LDMFD SP!，{R0 - R7，PC}^；恢复现场，包括CPSR，异常处理返回，SP值更新。</li>
</ul>
<h1 id><a href="#" class="headerlink" title="^"></a>^</h1><p>后缀“^”说明</p>
<ul>
<li>寄存器列表不包含PC：使用后缀“^”进行数据传送时，加载／存储的是用户模式的寄存器，而不是当前模式的寄存器。</li>
<li>寄存器列表包含有PC：除了正常的多寄存器传送外，还要将SPSR拷贝到CPSR中。该用法可用于异常处理返回。</li>
<li>禁用情况：后缀“^”不允许在用户模式或系统模式下使用。 因为它们没有SPSR</li>
</ul>
<h1 id="ARM是小端-高位高地址"><a href="#ARM是小端-高位高地址" class="headerlink" title="ARM是小端 高位高地址"></a>ARM是小端 高位高地址</h1><h1 id="ARM-体系结构支持-7-种运行模式"><a href="#ARM-体系结构支持-7-种运行模式" class="headerlink" title="ARM 体系结构支持 7 种运行模式"></a>ARM 体系结构支持 7 种运行模式</h1><p>用户模式、系统模式、快速中断模式、一般中断模式、管理模式、终止模式、未定义模式</p>
<h1 id="伪指令、宏指令"><a href="#伪指令、宏指令" class="headerlink" title="伪指令、宏指令"></a>伪指令、宏指令</h1><p>伪指令的作用</p>
<ol>
<li>程序定位的作用；</li>
<li>为非指令代码进行定义；</li>
<li>为程序完整性做标注；</li>
<li>有条件的引导程序段。</li>
</ol>
<h2 id="声明全局变量伪指令"><a href="#声明全局变量伪指令" class="headerlink" title="声明全局变量伪指令"></a>声明全局变量伪指令</h2><ul>
<li>GBLA 定义一个 全局数字变量，其默认初值为 0 ；GBLA Test1</li>
<li>GBLL 定义一个 全局逻辑变量 ，其默认初值为 FALSE；GBLL Test2</li>
<li> GBLS 定义一个 全局字符串变量，其默认初值为空 ；GBLS Test3</li>
</ul>
<h2 id="声明局部变量伪指令"><a href="#声明局部变量伪指令" class="headerlink" title="声明局部变量伪指令"></a>声明局部变量伪指令</h2><p>定义一个ARM程序中的局部变量，并将其初始化。与全局变量同理</p>
<ul>
<li>LCLA</li>
<li>LCLL</li>
<li>LCLS</li>
</ul>
<h2 id="数据定义伪指令"><a href="#数据定义伪指令" class="headerlink" title="数据定义伪指令"></a>数据定义伪指令</h2><ul>
<li>SETA伪指令用于给一个数字变量赋值；</li>
<li>SETL伪指令用于给一个逻辑变量赋值；</li>
<li>SETS伪指令用于给一个字符串变量赋值；</li>
</ul>
<h2 id="其他伪指令"><a href="#其他伪指令" class="headerlink" title="其他伪指令"></a>其他伪指令</h2><ul>
<li>LTORG用于声明一个数据缓冲池（文字池）的开始。</li>
<li>MAP^ FIELD#  SPACE% DCB= DCD&amp;</li>
</ul>
<h1 id="32位到16位指令"><a href="#32位到16位指令" class="headerlink" title="32位到16位指令"></a>32位到16位指令</h1><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">		   <span class="meta">CODE32</span> ；<span class="number">32</span> 位编码 </span><br><span class="line"><span class="symbol">INPro</span> <span class="keyword">LDR</span> <span class="built_in">R0</span>， = SubPro +<span class="number">#1</span> </span><br><span class="line">		    <span class="keyword">MOV</span> <span class="built_in">LR</span> , <span class="built_in">PC</span></span><br><span class="line">		    <span class="keyword">BX</span> <span class="built_in">R0</span> ；</span><br><span class="line">		    <span class="keyword">SUB</span> <span class="built_in">R1</span>,<span class="built_in">R2</span>,<span class="number">#2</span></span><br><span class="line">			 …</span><br><span class="line">		    <span class="meta">CODE16</span> </span><br><span class="line"><span class="symbol">SubPro</span> <span class="keyword">ADD</span> <span class="built_in">R1</span>，<span class="built_in">R3</span>,<span class="number">#1</span> </span><br><span class="line">			 …</span><br><span class="line">			<span class="keyword">BX</span> <span class="built_in">LR</span></span><br></pre></td></tr></table></figure>

<h1 id="CPSR-SPSR"><a href="#CPSR-SPSR" class="headerlink" title="CPSR/SPSR"></a>CPSR/SPSR</h1><p><img src="/2022/06/02/%E5%B5%8C%E5%85%A5%E5%BC%8F/ARM%E7%9F%A5%E8%AF%86%E7%82%B9/1654344515186.png" alt="enter description here"></p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MRS</span> <span class="built_in">R0</span>, <span class="keyword">CPSR</span></span><br><span class="line"><span class="keyword">BIC</span> <span class="built_in">R0</span>, <span class="built_in">R0</span>, <span class="number">#0x40</span></span><br><span class="line"><span class="keyword">MSR</span> <span class="built_in">CPSR_c</span>, <span class="built_in">R0</span> </span><br></pre></td></tr></table></figure>

<h1 id="异常与中断PC值"><a href="#异常与中断PC值" class="headerlink" title="异常与中断PC值"></a>异常与中断PC值</h1><p><img src="/2022/06/02/%E5%B5%8C%E5%85%A5%E5%BC%8F/ARM%E7%9F%A5%E8%AF%86%E7%82%B9/1654324975008.png" alt="enter description here"></p>
<h1 id="汇编语言程序段的基本结构"><a href="#汇编语言程序段的基本结构" class="headerlink" title="汇编语言程序段的基本结构"></a>汇编语言程序段的基本结构</h1><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">			<span class="meta">AREA</span> Init, <span class="meta">CODE</span>, <span class="meta">READONLY</span> ；只读的代码段名叫Init</span><br><span class="line">			<span class="meta">ENTRY</span> ；程序入口点</span><br><span class="line"><span class="symbol">start</span>  </span><br><span class="line">			<span class="keyword">LDR</span> <span class="built_in">R0</span>,<span class="number">=0X3FF5000</span></span><br><span class="line">			<span class="keyword">LDR</span> <span class="built_in">R1</span>,<span class="number">=0XFF</span> ；或<span class="keyword">MOV</span> <span class="built_in">R1</span>，<span class="number">#0XFF</span></span><br><span class="line">			<span class="keyword">STR</span> <span class="built_in">R1</span>,[<span class="built_in">R0</span>]</span><br><span class="line">			<span class="keyword">LDR</span> <span class="built_in">R0</span>,<span class="number">=0X3FF5008</span></span><br><span class="line">			<span class="keyword">LDR</span> <span class="built_in">R1</span>,<span class="number">=0X01</span> ；或<span class="keyword">MOV</span> <span class="built_in">R1</span>，<span class="number">#0X01</span></span><br><span class="line">			<span class="keyword">STR</span> <span class="built_in">R1</span>,[<span class="built_in">R0</span>]</span><br><span class="line">			…….</span><br><span class="line">			<span class="meta">END</span> ；段结束</span><br></pre></td></tr></table></figure>

<h1 id="ARM与C混合编程"><a href="#ARM与C混合编程" class="headerlink" title="ARM与C混合编程"></a>ARM与C混合编程</h1><h2 id="ATPCS"><a href="#ATPCS" class="headerlink" title="ATPCS"></a>ATPCS</h2><p>ATPCS规定，ARM的数据堆栈为FD型堆栈，即递减满堆栈。<br>还有对于参数个数不多于4的函数，编译器必须按参数在列表中的顺序，自左向右为它们分配寄存器R0~R3。<br>如果函数的参数多于4个，那么多余的参数则按自右向左的顺序压入数据堆栈，即参数入栈顺序与参数顺序相反。</p>
<h2 id="C调用ARM"><a href="#C调用ARM" class="headerlink" title="C调用ARM"></a>C调用ARM</h2><h2 id="ARM调用C"><a href="#ARM调用C" class="headerlink" title="ARM调用C"></a>ARM调用C</h2><h2 id="混合编程"><a href="#混合编程" class="headerlink" title="混合编程"></a>混合编程</h2><h3 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h3><h3 id="嵌入式汇编"><a href="#嵌入式汇编" class="headerlink" title="嵌入式汇编"></a>嵌入式汇编</h3>
      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/30/%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B%206%E3%80%817/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/30/%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B%206%E3%80%817/" class="post-title-link" itemprop="url">数据库应用编程 6、7</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-30 12:49:55" itemprop="dateCreated datePublished" datetime="2022-05-30T12:49:55+08:00">2022-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-02 15:56:24" itemprop="dateModified" datetime="2022-06-02T15:56:24+08:00">2022-06-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据库应用编程"><a href="#数据库应用编程" class="headerlink" title="数据库应用编程"></a>数据库应用编程</h1><p><img src="/2022/05/30/%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B%206%E3%80%817/1653894245119.png" alt="enter description here"></p>
<h2 id="数据库连接技术"><a href="#数据库连接技术" class="headerlink" title="数据库连接技术"></a>数据库连接技术</h2><p>数据库接口中间件：</p>
<h3 id="ODBC-开放式数据库连接服务"><a href="#ODBC-开放式数据库连接服务" class="headerlink" title="ODBC 开放式数据库连接服务"></a>ODBC 开放式数据库连接服务</h3><p>由微软公司开发，ODBC建立了一组规范，为多种数据库的开发提供统一的API接口<br>ODBC技术为应用程序提供了一套CLI(调用层接口)函数库和基于DLL(动态链接库)的运行支持环境。<br><a href="./images/1653894655693.png">层次结构及访问步骤</a><br>ODBC体系结构由四个部分组成：</p>
<ul>
<li>ODBC数据库应用程序</li>
<li>启动程序管理器 - 最重要的部件</li>
<li>DBMS驱动程序</li>
<li>数据源</li>
</ul>
<h3 id="JDBC-Java数据库连接服务"><a href="#JDBC-Java数据库连接服务" class="headerlink" title="JDBC Java数据库连接服务"></a>JDBC Java数据库连接服务</h3><p>由SUN(Oracle)开发<br>JDBC包括一组用JAVA语言书写的接口和类，独立于特定的DBMS统一对数据库的操作。<br>接口封装位于java.sql、Javax.sql两个包<br><img src="/2022/05/30/%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B%206%E3%80%817/1653895577720.png" alt="enter description here"></p>
<h4 id="数据库访问步骤"><a href="#数据库访问步骤" class="headerlink" title="数据库访问步骤"></a>数据库访问步骤</h4><ul>
<li>java程序加载java包java.sql.*中的核心类和接口，然后加载驱动程序</li>
<li>创建数据库connection连接对象</li>
<li>创建statement对象</li>
<li>调用statement对象的相关方法执行对应的SQL语句</li>
<li>处理数据库返回结果</li>
<li>关闭连接<br><img src="/2022/05/30/%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B%206%E3%80%817/1653895844283.png" alt="enter description here"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JDBCtest;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;\</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCdemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">		Connection conn=<span class="keyword">null</span>;</span><br><span class="line">		Statement stmt=<span class="keyword">null</span>;</span><br><span class="line">		String URL=<span class="string">&quot;jdbc:postgresql://localhost:5432/testDB&quot;</span>;</span><br><span class="line">		String userName=<span class="string">&quot;name&quot;</span>;</span><br><span class="line">		String passWord=<span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			Class.forName(<span class="string">&quot;org.postgresql.Driver&quot;</span>);</span><br><span class="line">			conn=DriverManager.getConnection(URL,userName,passWord);<span class="comment">//建立连接</span></span><br><span class="line">			String sql =<span class="string">&quot;select * from test&quot;</span>;</span><br><span class="line">			stmt=(Statement)conn.createStatement();<span class="comment">//创建statement对象</span></span><br><span class="line">			ResultSet rs=stmt.executeQuery(sql);<span class="comment">//executeQuery用于select返回结果集；executeUpdate用于update、delete、insert返回受影响的行数</span></span><br><span class="line">			<span class="keyword">while</span>(rs.next())&#123;<span class="comment">//rs中即保存了返回的结果集</span></span><br><span class="line">				System.out.println(rs.getString(<span class="string">&quot;id&quot;</span>)+<span class="string">&quot; &quot;</span>+rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">			&#125;</span><br><span class="line">			rs.close();</span><br><span class="line">			stmt.close();</span><br><span class="line">			conn.close();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">			System.err.println(e.getClass().getName()+<span class="string">&quot;:&quot;</span>+e.getMessage());</span><br><span class="line">			System.exit(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="储存过程编程"><a href="#储存过程编程" class="headerlink" title="储存过程编程"></a>储存过程编程</h2><p>是数据库的一种对象，由一组完成特定数据处理功能的SQL语句和过程语句组成的程序，<br>编译后储存在数据库中<br>外部程序可以直接调用储存过程执行，不用再次编译</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [ <span class="keyword">OR</span> REPLACE ] <span class="keyword">FUNCTION</span> name</span><br><span class="line">( [ [ argmode ] [ argname ] argtype [ &#123; <span class="keyword">DEFAULT</span> <span class="operator">|</span> <span class="operator">=</span> &#125; default_expr ] [, ...] ] )</span><br><span class="line">[ <span class="keyword">RETURNS</span> retype <span class="operator">|</span> <span class="keyword">RETURNS</span> <span class="keyword">TABLE</span> ( column_name column_type [, ...] ) ]</span><br><span class="line"><span class="keyword">AS</span> $$    <span class="operator">/</span><span class="operator">/</span>实际代码的开始</span><br><span class="line"> </span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line"><span class="comment">-- 声明段</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">--函数体语句</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> lang_name; <span class="operator">/</span><span class="operator">/</span>结束并指明所用的编程语言</span><br></pre></td></tr></table></figure>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>减少网络通信量</li>
<li>执行速度更快</li>
<li>更强的适应性</li>
<li>降低了业务实现与应用程序的耦合</li>
<li>降低了开发的复杂性</li>
<li>保护数据库元信息</li>
<li>增强了数据库的安全性</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>SQL本身是一种结构化查询语言，而存储过程本质上是过程化的程序；面对复杂的业务逻辑，过程化处理逻辑相对比较复杂；而SQL语言的优势是面向数据查询而<strong>非业务逻辑的处理</strong>。</li>
<li>如果存储过程的参数或返回数据发生变化，一般需要修改存储过程的代码，同时<strong>还需要更新</strong>主程序调用存储过程的代码。</li>
<li><strong>开发调试复杂</strong>，由于缺乏支持存储过程的集成开发环境，存储过程的开发调试要比一般程序困难。</li>
<li><strong>可移植性差</strong>。</li>
</ol>
<h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><p><img src="/2022/05/30/%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B%206%E3%80%817/1653898669891.png" alt="enter description here"><br>此例创建过程函数Out_Record()<br>将查询的学生ID与姓名成对输出</p>
<h2 id="触发器编程"><a href="#触发器编程" class="headerlink" title="触发器编程"></a>触发器编程</h2><p>由事件触发启动而不是运行启动，所以不能有参数<br>可用于定义逻辑比较复杂的完整性约束或业务规则约束</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="按执行次数"><a href="#按执行次数" class="headerlink" title="按执行次数"></a>按执行次数</h4><ul>
<li>语句级触发器 - FOR EACH STATEMENT</li>
<li>行级触发器 - FOR EACH ROW 指定表数据每变化一行就执行一次触发器</li>
</ul>
<h4 id="按执行时间"><a href="#按执行时间" class="headerlink" title="按执行时间"></a>按执行时间</h4><ul>
<li>BEFORE触发器</li>
<li>AFTER触发器</li>
<li>INSTEAD OF触发器</li>
</ul>
<h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3><ul>
<li>NEW - RECORD类型，对于行级触发，它保存INSERT/UPADTE操作产生的新行数据</li>
<li>OLD - RECORD类型，对于行级触发，它保存INSERT/DELETE操作前的旧行数据</li>
<li>TG_OP - text类型，获取触发器是由INSERT/UPDATE/DELETE哪类操作引发</li>
</ul>
<h3 id="规则触发器"><a href="#规则触发器" class="headerlink" title="规则触发器"></a>规则触发器</h3><p>附加到一个表，只捕获DML事件<br>将function安装为触发器的格式<br><img src="/2022/05/30/%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B%206%E3%80%817/1653900292279.png" alt="enter description here"><br>例<br><img src="/2022/05/30/%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B%206%E3%80%817/1653900309441.png" alt="enter description here"><br>此例在Audit_score中进行delete|update|insert的记录</p>
<h3 id="事件触发器"><a href="#事件触发器" class="headerlink" title="事件触发器"></a>事件触发器</h3><p>针对一个数据库DDL操作的触发器，在数据库级别上捕获DDL事件<br>类型</p>
<ul>
<li>ddl_command_start</li>
<li>ddl_command_end</li>
<li>sql_drop删除一个数据库前触发</li>
</ul>
<p>安装格式<br><img src="/2022/05/30/%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B%206%E3%80%817/1653900685572.png" alt="enter description here"></p>
<h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><ol>
<li>游标（Cursor）是一种临时的数据库对象；</li>
<li>用来存放从数据库表中查询返回的数据记录；</li>
<li>提供了从结果集中提取并分别处理每一条记录的机制；</li>
<li>游标总是与一条SQL查询语句相关联；</li>
<li>游标包括：SQL语言的查询结果，指向特定记录的指针。</li>
</ol>
<h1 id="NoSQL数据库技术"><a href="#NoSQL数据库技术" class="headerlink" title="NoSQL数据库技术"></a>NoSQL数据库技术</h1><p><img src="/2022/05/30/%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B%206%E3%80%817/1653902429382.png" alt="enter description here"></p>

      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/29/%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E4%B8%8E%E8%AE%BE%E8%AE%A13%E3%80%814/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/29/%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E4%B8%8E%E8%AE%BE%E8%AE%A13%E3%80%814/" class="post-title-link" itemprop="url">数据库SQL、数据库设计与管理 3、4、5</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-29 15:51:13" itemprop="dateCreated datePublished" datetime="2022-05-29T15:51:13+08:00">2022-05-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-31 15:52:44" itemprop="dateModified" datetime="2022-05-31T15:52:44+08:00">2022-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p>结构化查询语言是一种对关系数据库进行访问的数据操作语言</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>一体化、使用方式灵活、非过程化、语言语法简单</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="DDL数据定义语言"><a href="#DDL数据定义语言" class="headerlink" title="DDL数据定义语言"></a>DDL数据定义语言</h3><ul>
<li>CREATE DATABASE/TABLE/INDEX</li>
<li>DROP DATABASE/TABLE/INDEX</li>
<li>ALTER DATABASE/TABLE</li>
</ul>
<h3 id="DML数据操控语言"><a href="#DML数据操控语言" class="headerlink" title="DML数据操控语言"></a>DML数据操控语言</h3><ul>
<li>INSERT</li>
<li>UPDATE</li>
<li>DELETE<br>需要commit</li>
</ul>
<h3 id="DQL数据查询语言"><a href="#DQL数据查询语言" class="headerlink" title="DQL数据查询语言"></a>DQL数据查询语言</h3><ul>
<li>SELECT</li>
</ul>
<h3 id="DCL数据控制语言"><a href="#DCL数据控制语言" class="headerlink" title="DCL数据控制语言"></a>DCL数据控制语言</h3><ul>
<li>GRANT</li>
<li>DENY</li>
<li>REVOKE 权限收回</li>
</ul>
<h3 id="TPL事务处理语言"><a href="#TPL事务处理语言" class="headerlink" title="TPL事务处理语言"></a>TPL事务处理语言</h3><ul>
<li>BEGIN/START TRANSACTION 开始事务</li>
<li>COMMIT 提交事务</li>
<li>ROLLBACK 回滚事务</li>
</ul>
<h3 id="CCL游标控制语言"><a href="#CCL游标控制语言" class="headerlink" title="CCL游标控制语言"></a>CCL游标控制语言</h3><ul>
<li>DECLEAR CURSOR 定义游标</li>
<li>FETCH INTO 提交游标数据</li>
<li>CLOSE CURSOR 关闭游标</li>
</ul>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>SELECT查询结果集的虚拟表，使用储存在基础表的数据</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>简化复杂SQL查询操作</li>
<li>提高数据访问安全性</li>
<li>提供一定程序的数据逻辑独立性</li>
<li>集中展示用户感兴趣的特定信息</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>一种按照关系表中<strong>指定</strong>列的取值顺序<strong>组织</strong>元组数据存储的数据结构<br>以支持快速查找</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>提高关系表数据检索速度</li>
<li>可快速连接关联表</li>
<li>减少分组和排序的时间</li>
</ul>
<h3 id="开销"><a href="#开销" class="headerlink" title="开销"></a>开销</h3><ul>
<li>创建和维护索引需要开销</li>
<li>占据额外存储空间</li>
<li>数据操纵会因为维护索引而带来开销</li>
</ul>
<h1 id="数据库设计与实现"><a href="#数据库设计与实现" class="headerlink" title="数据库设计与实现"></a>数据库设计与实现</h1><h2 id="数据库设计概述"><a href="#数据库设计概述" class="headerlink" title="数据库设计概述"></a>数据库设计概述</h2><h3 id="数据库设计方案"><a href="#数据库设计方案" class="headerlink" title="数据库设计方案"></a>数据库设计方案</h3><ul>
<li>概念数据模型 - 现实世界的抽象，由数据库设计人员和用户共同完成</li>
<li>逻辑数据模型 - 由概念模型抽象，由数据库设计人员完成</li>
<li>物理数据模型 - 由逻辑模型抽象，并可转化为数据定义语句</li>
</ul>
<p>(标识符是逻辑概念，主键是物理概念)</p>
<h3 id="数据库设计过程与策略"><a href="#数据库设计过程与策略" class="headerlink" title="数据库设计过程与策略"></a>数据库设计过程与策略</h3><p>过程<br><img src="/2022/05/29/%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E4%B8%8E%E8%AE%BE%E8%AE%A13%E3%80%814/1653816325419.png" alt="enter description here"><br>策略：<br>自底向上、自顶向下、由内至外、混合</p>
<h2 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E-R模型"></a>E-R模型</h2><p>即实体-关系模型，是设计系统概念模型、逻辑数据模型的有效方法</p>
<h3 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h3><p><strong>实体、属性、联系</strong>(关系)</p>
<h3 id="联系的类型"><a href="#联系的类型" class="headerlink" title="联系的类型"></a>联系的类型</h3><h4 id="多重性"><a href="#多重性" class="headerlink" title="多重性"></a>多重性</h4><p>联系数量称为联系度数<br>1:1<br>1:N<br>M:N</p>
<h4 id="参与性"><a href="#参与性" class="headerlink" title="参与性"></a>参与性</h4><p>即可选/强制<br>则有如下符号<br><img src="/2022/05/29/%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E4%B8%8E%E8%AE%BE%E8%AE%A13%E3%80%814/1653816956350.png" alt="enter description here"></p>
<h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><p>分为非互斥继承联系、互斥继承联系、完整继承联系、非完整继承联系<br><img src="/2022/05/29/%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E4%B8%8E%E8%AE%BE%E8%AE%A13%E3%80%814/1653817005421.png" alt="enter description here"></p>
<h3 id="依赖性"><a href="#依赖性" class="headerlink" title="依赖性"></a>依赖性</h3><p>标识符依赖弱实体<br>非标识符依赖弱实体</p>
<h2 id="数据库建模设计"><a href="#数据库建模设计" class="headerlink" title="数据库建模设计"></a>数据库建模设计</h2><h3 id="概念模型设计"><a href="#概念模型设计" class="headerlink" title="概念模型设计"></a>概念模型设计</h3><ul>
<li>抽取与标识实体</li>
<li>分析与标识实体联系：连接与联系符号选择、命名</li>
<li>定义实体属性与标识符：选择标识符</li>
<li>检查与完善</li>
</ul>
<h3 id="逻辑模型设计"><a href="#逻辑模型设计" class="headerlink" title="逻辑模型设计"></a>逻辑模型设计</h3><ul>
<li>CDM/LDM转换 - 在业务实体的基础上，增加数据实体；多对多实体联系通过关联实体转换为一对多实体联系；区分主键标识符、外键标识符</li>
<li>规范化与完善 - 满足3NF范式</li>
</ul>
<h3 id="物理模型设计"><a href="#物理模型设计" class="headerlink" title="物理模型设计"></a>物理模型设计</h3><ul>
<li>实体到关系表的转换：实体属性对应表的列、实体标识符转换为对应表主键(或设置为代理键)</li>
<li>实体联系的转换：关系表之间的主，外键设置<br>（弱实体到关系表的转换：若弱实体依赖于一个强实体时，加入强实体标识符作为外键值）<br>在逻辑模型转换成物理模型时， 需要先确定将使用的DBMS。<br><img src="/2022/05/29/%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E4%B8%8E%E8%AE%BE%E8%AE%A13%E3%80%814/1653819747415.png" alt="enter description here"></li>
</ul>
<h2 id="数据库规范化设计"><a href="#数据库规范化设计" class="headerlink" title="数据库规范化设计"></a>数据库规范化设计</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul>
<li>减少数据库中冗余数据，降低维护一致性的工作量</li>
<li>合理设计关系表之间的依赖关系和约束关系，便于实现一致性</li>
<li>合理设计数据库结构，便于对数据高效访问</li>
</ul>
<h3 id="非规范化的问题"><a href="#非规范化的问题" class="headerlink" title="非规范化的问题"></a>非规范化的问题</h3><p>插入，删除，修改出现异常</p>
<h3 id="函数依赖理论"><a href="#函数依赖理论" class="headerlink" title="函数依赖理论"></a>函数依赖理论</h3><p>X-&gt;Y，Y依赖于X·<br>X为决定因子，Y为函数依赖</p>
<h4 id="完全-部分函数依赖"><a href="#完全-部分函数依赖" class="headerlink" title="完全/部分函数依赖"></a>完全/部分函数依赖</h4><p><strong>定义</strong>：设X、Y是某关系的不同属性集，如X-&gt;Y，且不存在X的真子集A使A-&gt;Y，则为完全函数依赖，否则为部分函数依赖<br><img src="/2022/05/29/%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E4%B8%8E%E8%AE%BE%E8%AE%A13%E3%80%814/1653821127251.png" alt="enter description here"></p>
<h4 id="函数传递依赖"><a href="#函数传递依赖" class="headerlink" title="函数传递依赖"></a>函数传递依赖</h4><p><strong>定义</strong>：有X-&gt;Y,Y-/-&gt;X,Y-&gt;Z则称Z对X存在函数传递依赖<br><img src="/2022/05/29/%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E4%B8%8E%E8%AE%BE%E8%AE%A13%E3%80%814/1653821145287.png" alt="enter description here"></p>
<h4 id="多值函数依赖"><a href="#多值函数依赖" class="headerlink" title="多值函数依赖"></a>多值函数依赖</h4><p><strong>定义</strong>：对于 R(U,X,Y)中存在(x,y1,z1)和(x,y2,z2)时，也存在(x,y1,z2)和(x,y2,z1)<br><img src="/2022/05/29/%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E4%B8%8E%E8%AE%BE%E8%AE%A13%E3%80%814/1653821198087.png" alt="enter description here"></p>
<h3 id="关系规范化范式"><a href="#关系规范化范式" class="headerlink" title="关系规范化范式"></a>关系规范化范式</h3><p>关系规范化程度利弊：</p>
<ul>
<li>利：冗余数据减少；可消除数据访问异常增加</li>
<li>弊：分解出来的关系表增加；实现数据查询访问时需要关联多表效率低<br>逆规范化处理<br><img src="/2022/05/29/%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E4%B8%8E%E8%AE%BE%E8%AE%A13%E3%80%814/1653822192537.png" alt="enter description here"></li>
</ul>
<h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><p>如果关系表中的属性不可再细分，则满足第一范式</p>
<h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><p>如果关系满足第一范式，并且消除了关系中属性<strong>部分</strong>函数依赖，则满足第二范式<br>即要求属性完全函数依赖</p>
<h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><p>如果关系满足第二范式，并且切断了关系中的属性<strong>传递</strong>函数依赖，则满足第三范式</p>
<h4 id="巴斯科德范式BCNF"><a href="#巴斯科德范式BCNF" class="headerlink" title="巴斯科德范式BCNF"></a>巴斯科德范式BCNF</h4><p>在关系中所有函数依赖的决定因子都是候选键<br><img src="/2022/05/29/%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E4%B8%8E%E8%AE%BE%E8%AE%A13%E3%80%814/1653821906076.png" alt="enter description here"></p>
<h4 id="第四范式"><a href="#第四范式" class="headerlink" title="第四范式"></a>第四范式</h4><p>如果关系满足BCNF，并消除了<strong>多值</strong>函数依赖，该关系满足第四范式<br><img src="/2022/05/29/%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E4%B8%8E%E8%AE%BE%E8%AE%A13%E3%80%814/1653822004187.png" alt="enter description here"></p>
<h4 id="第五范式"><a href="#第五范式" class="headerlink" title="第五范式"></a>第五范式</h4><p>如果关系满足第四范式，并消除了<strong>连接</strong>依赖，则满足第五范式</p>
<h1 id="数据库管理"><a href="#数据库管理" class="headerlink" title="数据库管理"></a>数据库管理</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>数据库管理是<strong>指</strong>为保证数据库系统的正常运行和服务质量必须进行的系统管理工作。</p>
<h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h3><p><strong>为什么需要</strong>数据库管理？<br>因为数据库规模复杂，访问权限，安全隐私，损坏丢失<br>所以数据库管理<strong>目标</strong>有：</p>
<ul>
<li>保障数据库系统<strong>正常稳定运行</strong></li>
<li>充分发挥数据库系统的<strong>软硬件处理能力</strong></li>
<li>确保数据库系统安全和用户<strong>数据隐私</strong>性</li>
<li>有效管理数据库用户及其角色<strong>权限</strong></li>
<li>解决数据库系统<strong>性能优化、系统故障与数据损坏</strong>等问题</li>
<li>最大程度地发挥数据库对其所属机构的作用</li>
</ul>
<h3 id="数据库管理内容"><a href="#数据库管理内容" class="headerlink" title="数据库管理内容"></a>数据库管理内容</h3><p>① DBMS系统<strong>运行管理</strong><br>② 数据库<strong>性能监控</strong><br>③ 数据库<strong>索引</strong>管理<br>④ 数据库<strong>查询优化</strong><br>⑤ 数据库事务<strong>并发控制</strong><br>⑥ 数据库<strong>角色</strong>管理<br>⑦ 数据库<strong>用户</strong>管理<br>⑧ 数据库<strong>对象权限</strong>管理<br>⑨ 数据<strong>安全</strong>管理<br>⑩ 数据库<strong>备份</strong><br>⑪ 数据库<strong>恢复</strong></p>
<h3 id="DBMS管理功能结构"><a href="#DBMS管理功能结构" class="headerlink" title="DBMS管理功能结构"></a>DBMS管理功能结构</h3><p><img src="/2022/05/29/%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E4%B8%8E%E8%AE%BE%E8%AE%A13%E3%80%814/1653823224326.png" alt="enter description here"></p>
<h3 id="DBMS结构"><a href="#DBMS结构" class="headerlink" title="DBMS结构"></a>DBMS结构</h3><p><img src="/2022/05/29/%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E4%B8%8E%E8%AE%BE%E8%AE%A13%E3%80%814/1653823344827.png" alt="enter description here"></p>
<h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><h3 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h3><p>是一个数据库操作序列(一连串操作的集合)，是数据库应用程序的基本逻辑单元<br>这些操作要么都做，要么都不做，是一个不可分割的执行单位。<br>事务是DBMS执行的最小任务单元，是最小故障恢复单元，是最小并发控制单元<br>每个事务都具有ACID特性。</p>
<h3 id="事务的生命周期状态"><a href="#事务的生命周期状态" class="headerlink" title="事务的生命周期状态"></a>事务的生命周期状态</h3><p><img src="/2022/05/29/%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E4%B8%8E%E8%AE%BE%E8%AE%A13%E3%80%814/1653823686233.png" alt="enter description here"></p>
<h3 id="事务的特性ACID"><a href="#事务的特性ACID" class="headerlink" title="事务的特性ACID"></a>事务的特性ACID</h3><p>原子、一致、隔离、持久</p>
<ul>
<li><strong>原子性（Atomicity）</strong>：事物要不做完要不回退，如原子一样不可分割，不能半途而废</li>
<li><strong>一致性（Consistency）</strong>：例如银行转账，收发方金额总数一致</li>
<li><strong>隔离性（Isolation）</strong>：多事务并发执行，不能相互干扰、双回滚 </li>
<li><strong>持续性（Durability）</strong>： 一旦提交，结果不变</li>
</ul>
<p>如果在DBMS中各个事务按串行执行很容易满足ACID但是考虑：<strong>改善系统的资源利用率，减少事务执行的平均等待时间</strong>还是要支持并发</p>
<h3 id="事务的SQL语句"><a href="#事务的SQL语句" class="headerlink" title="事务的SQL语句"></a>事务的SQL语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">SQL...;</span><br><span class="line"><span class="keyword">COMMIT</span>;(<span class="keyword">ROLLBACK</span>;)</span><br></pre></td></tr></table></figure>
<p>还有SAVEPOINT用于设立事务保存点</p>
<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><h3 id="并发控制问题"><a href="#并发控制问题" class="headerlink" title="并发控制问题"></a>并发控制问题</h3><ul>
<li>脏读 - 指多个事务同时发生时，一个事务读取了被另一个事务所修改后的共享数据</li>
<li>不可重复读 - 指一个事务对同一个共享数据先后读取数据不一致</li>
<li>幻像读 - 指一个事务对同一共享数据读取两次但第二次比第一次新增数据</li>
<li>丢失更新 - 指一个事务对共享数据进行更新后查询发现该数据与更新值不一致</li>
</ul>
<h3 id="并发事务调度"><a href="#并发事务调度" class="headerlink" title="并发事务调度"></a>并发事务调度</h3><ul>
<li>由于并发控制调度器将各个事务的SQL数据操作请求按照一定顺序进行调度执行</li>
<li>对共享数据的任意顺序访问操作是导致数据库可能产生数据异常的根本原因</li>
<li>所以只有当事务调度顺序的执行结构与事务串行执行的数据结果一样时，才得以保证一致性，即并发事务调度目标</li>
</ul>
<h3 id="数据库锁机制"><a href="#数据库锁机制" class="headerlink" title="数据库锁机制"></a>数据库锁机制</h3><h4 id="数据库锁机制-1"><a href="#数据库锁机制-1" class="headerlink" title="数据库锁机制"></a>数据库锁机制</h4><ul>
<li>排他锁，不允许加任何锁，禁止对数据的修改删除及读取</li>
<li>共享锁，只允许加共享锁，即允许读取，禁止修改删除</li>
</ul>
<p>锁定粒度越大，DBMS管理就越容易，但并发能力就越差；粒度越小，管理越复杂，并发能力越强。</p>
<h4 id="并发控制协议"><a href="#并发控制协议" class="headerlink" title="并发控制协议"></a>并发控制协议</h4><ul>
<li>一级加锁协议 - 任何事务在修改共享数据对象前，必须对该数据单元排他锁定，直到事务完成。以避免<strong>丢失更新</strong></li>
<li>二级加锁协议 - 在<strong>一级</strong>加锁协议的基础上，针对事务读取共享数据时，必须进行共享锁定，只需直到<strong>读取完成</strong>。以避免<strong>丢失更新、脏读</strong></li>
<li>三级加锁协议 - 在<strong>一级</strong>加锁协议的基础上，针对事务读取共享数据时，必须进行共享锁定，直到<strong>事务完成</strong>。以避免<strong>丢失更新、脏读、不可重复读取</strong></li>
</ul>
<h5 id="两阶段锁定协议"><a href="#两阶段锁定协议" class="headerlink" title="两阶段锁定协议"></a>两阶段锁定协议</h5><p>分为增长阶段和缩减阶段<br>增长阶段：事务只能加锁，不能释放锁<br>缩减阶段：事务只能释放锁，不能加锁<br>以保证并发事务调度<strong>可串行化</strong></p>
<h4 id="并发事务死锁解决"><a href="#并发事务死锁解决" class="headerlink" title="并发事务死锁解决"></a>并发事务死锁解决</h4><h5 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h5><ul>
<li>互斥条件</li>
<li>请求和保持条件</li>
<li>不剥夺条件</li>
<li>环路等待条件</li>
</ul>
<h5 id="防范和解决"><a href="#防范和解决" class="headerlink" title="防范和解决"></a>防范和解决</h5><p>防范死锁问题的两大策略</p>
<ul>
<li>一次锁定所有资源</li>
<li>所以事务锁定资源的顺序必须相同</li>
</ul>
<p>解决方法即选择一个处理代价最小的事务进行回滚撤销</p>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>丢失更新</th>
</tr>
</thead>
<tbody><tr>
<td>读取未提交</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>读取已提交</td>
<td>不可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>可重复读</td>
<td>不可能</td>
<td>不可能</td>
<td>可能</td>
</tr>
<tr>
<td>可串行化不可能</td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
</tr>
</tbody></table>
<h2 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h2><h3 id="安全模型"><a href="#安全模型" class="headerlink" title="安全模型"></a>安全模型</h3><p>多层安全模型<br>|层面|安全控制与管理|<br>|-|-|<br>|身份认证系统|用户身份鉴别|<br>|DBMS|用户存取权限控制|<br>|OS|操作系统安全保护|<br>|数据库|数据加密储存|</p>
<h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>用户创建</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> name <span class="keyword">WITH</span></span><br><span class="line">	SUPERUSER</span><br><span class="line">	CREATEDB</span><br><span class="line">	CREATEROLE</span><br><span class="line">	INHERIT#继承角色权限</span><br><span class="line">	LOGIN</span><br><span class="line">	REPLICATION#复制权限</span><br><span class="line">	BYPASSRLS#绕过安全策略权限</span><br><span class="line">	CONNECTION LIMIT <span class="number">-1</span>#用户最大连接数</span><br><span class="line">	[ ENCRYPTED <span class="operator">|</span> UNENCRYPTED ] PASSWORD <span class="number">123456</span>;</span><br></pre></td></tr></table></figure>
<p>用户修改</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> name <span class="keyword">WITH</span> </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> name RENAME <span class="keyword">TO</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> name <span class="keyword">SET</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> name RESET</span><br></pre></td></tr></table></figure>
<p>用户删除</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> name</span><br></pre></td></tr></table></figure>
<h4 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> 权限 <span class="keyword">ON</span> 对象 <span class="keyword">TO</span> 名字</span><br><span class="line"><span class="keyword">REVOKE</span> 权限 <span class="keyword">ON</span> 对象 <span class="keyword">FROM</span> 名字</span><br><span class="line">DENY 权限 <span class="keyword">ON</span> 对象 <span class="keyword">TO</span> 名字</span><br></pre></td></tr></table></figure>

<h4 id="角色管理"><a href="#角色管理" class="headerlink" title="角色管理"></a>角色管理</h4><p>将一组具有相同权限的用户定义为角色ROLE</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> name <span class="keyword">IN</span> ROLE name</span><br></pre></td></tr></table></figure>

<h2 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h2><h3 id="数据库备份"><a href="#数据库备份" class="headerlink" title="数据库备份"></a>数据库备份</h3><ul>
<li>备份内容：用户数据库、系统数据库</li>
<li>备份方式：完整数据库备份、差异数据库备份、事务日志备份、文件备份；还分为冷备份、热备份</li>
<li>备份设备：磁盘阵列、磁带库、光盘库</li>
</ul>
<h3 id="PgSQL备份方法"><a href="#PgSQL备份方法" class="headerlink" title="PgSQL备份方法"></a>PgSQL备份方法</h3><p>一般的</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pg_dump <span class="operator">-</span>f 输出文件名 数据库名称</span><br><span class="line">psql <span class="operator">-</span>d 数据库名称 <span class="operator">-</span>f 导入文件名</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/08/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(5-6)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/08/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(5-6)/" class="post-title-link" itemprop="url">计算机操作系统(5-6)文件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-08 13:32:15 / 修改时间：20:11:29" itemprop="dateCreated datePublished" datetime="2022-05-08T13:32:15+08:00">2022-05-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="文件系统概述"><a href="#文件系统概述" class="headerlink" title="文件系统概述"></a>文件系统概述</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>操作系统中的各类文件、管理文件的软件，以及管理文件所涉及到的数据结构等信息的集合。</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li>有效地管理文件的存储空间</li>
<li>管理文件目录</li>
<li>完成文件的读/写操作</li>
<li>实现文件共享与保护</li>
<li>为用户提供交互式命令接口和程序调用接口</li>
</ul>
<h2 id="文件、记录和数据项"><a href="#文件、记录和数据项" class="headerlink" title="文件、记录和数据项"></a>文件、记录和数据项</h2><p><strong>数据项</strong>：最低级的数据组织形式，其中：</p>
<ul>
<li>基本数据项 - 描述一个对象的某种属性的字符集，是数据组织中可以命名的最小逻辑数据单位， 即原子数据，数据元素或字段。</li>
<li>组合数据项 - 若干个基本数据项组成的，简称组项。</li>
</ul>
<p><strong>记录</strong>：一组相关数据项的集合，描述一个对象在某方面的属性。</p>
<p><strong>文件</strong>：由创建者所定义的、 具有文件名的一组相关元素的集合。其中<br>有结构的文件，文件由若干个相关记录组成； 而无结构文件则被看成是一个字符流。<br>文件在文件系统中是一个<strong>最大</strong>的数据单位，它描述了一个对象集。<br>文件的属性包括：<br>文件类型、文件长度、文件的物理位置、文件的建立时间等</p>
<h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><h3 id="按用途分类"><a href="#按用途分类" class="headerlink" title="按用途分类"></a>按用途分类</h3><ul>
<li><strong>系统文件</strong> - 系统软件构成的文件。大多数的系统文件只允许用户调用，但不允许用户去读，更不允许修改；有的系统文件不直接对用户开放。</li>
<li><strong>用户文件</strong> - 用户的源代码、目标文件、可执行文件或数据等所构成的文件。</li>
<li><strong>库文件</strong> - 标准子例程及常用的例程等所构成的文件。允许用户调用，但不允许修改。</li>
</ul>
<h3 id="按数据形式"><a href="#按数据形式" class="headerlink" title="按数据形式"></a>按数据形式</h3><ul>
<li><strong>源文件</strong> - 指由源程序和数据构成的文件。</li>
<li><strong>目标文件</strong> - 把源程序经过相应语言的编译程序编译，未链接的目标代码所构成的文件。它属于二进制文件。</li>
<li><strong>可执行文件</strong> - 编译后所产生的目标代码再经过链接程序链接后所形成的文件。</li>
</ul>
<h3 id="按存取控制属性（权限）"><a href="#按存取控制属性（权限）" class="headerlink" title="按存取控制属性（权限）"></a>按存取控制属性（权限）</h3><p>读、写、执行<br>（PPT写分三类：只执行文件、只读文件、读写文件）</p>
<h3 id="按组织形式和处理方式"><a href="#按组织形式和处理方式" class="headerlink" title="按组织形式和处理方式"></a>按组织形式和处理方式</h3><ul>
<li><strong>普通文件</strong> - 由ASCII码或二进制码组成的字符文件。用户建立的源程序文件、数据文件、目标代码文件及操作系统自身代码文件、库文件、实用程序文件等都是普通文件，它们通常存储在外存储设备上。</li>
<li><strong>目录文件</strong> - 由文件目录组成的，管理和实现文件系统功能的系统文件，目录文件可以对其它文件的信息进行检索。由字符序列构成，与普通文件一样操作。</li>
<li><strong>特殊文件</strong> - 特指系统中的各类I/O 设备。统一管理，系统将所有的输入/输出设备都视为文件，按文件方式提供给用户使用。</li>
</ul>
<h2 id="文件系统模型"><a href="#文件系统模型" class="headerlink" title="文件系统模型"></a>文件系统模型</h2><p><img src="/2022/05/08/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(5-6)/1651992658313.png" alt="enter description here"></p>
<ol>
<li><strong>对象及其属性</strong> - 对象即文件、目录、磁盘存储空间</li>
<li><strong>对对象操纵和管理的软件集合</strong> - 包括对文件存储空间的管理、对文件目录的管理、逻辑地址转换为物理地址、对文件读和写的管理、文件的共享与保护</li>
<li><strong>文件系统的接口</strong> - 命令接口：用户与文件系统交互的接口，通过终端键入命令取得服务。程序接口：用户程序与文件系统的接口，通过系统调用来取得服务。</li>
</ol>
<h1 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h1><p>文件存在两种形式的结构：</p>
<ol>
<li>文件的逻辑结构 从用户观点出发所观察到的文件组织形式 。从逻辑组织的角度看，文件由若干记录构成</li>
<li>文件的物理结构 文件在外存上的存储组织形式 。从物理组织的角度看，文件由若干数据块组成</li>
</ol>
<h2 id="存储空间的管理"><a href="#存储空间的管理" class="headerlink" title="存储空间的管理"></a>存储空间的管理</h2><p>文件分配外存空间考虑的问题是：怎样才能<strong>有效地利用</strong>外存空间和如何提高对文件的<strong>访问速度</strong>。<br>（外存的组织方式）<br>分配方法：连续、链接、引索</p>
<h3 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h3><p>为每一个文件分配一组相邻接的盘块。<br>即把<strong>逻辑文件</strong>中的数据顺序地存储到物理上邻接的各个数据块中，形成的<strong>物理文件</strong>进行顺序存取。<br>对应文件目录中为每个文件建立一个表项，只用记载文件的第一个数据块地址及文件长度</p>
<ul>
<li><strong>优点</strong> - 顺序访问（检索）容易、顺序访问速度快</li>
<li><strong>问题</strong> - 要求有连续的存储空间导致磁盘空间碎片化（要使用紧凑技术）、必须事先知道文件的长度不利于动态增长的文件存储</li>
</ul>
<h3 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h3><p>链接文件：采用链接分配方式时，可通过在每个盘块上的链接指针，将同属于一个文件的多个<strong>离散的盘块链接成一个链表</strong>，把这样形成的物理文件称为链接文件。</p>
<h4 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h4><p>即在文件目录的每个<strong>目录项中</strong>，含有指向链接文件第一个盘块和最后一个盘块的指针。 每个<strong>盘块中</strong>都含有一个指向下一个盘块的指针。<br><img src="/2022/05/08/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(5-6)/1651993944461.png" alt="enter description here"></p>
<p><strong>问题</strong><br>适合顺序访问，随机访问是极其低效的（如找访问文件的第i个盘块必须顺序读取前i-1个盘块）</p>
<p>为了提高检索速度和减小指针所占用的存储空间，可以将几个盘块组成一个<strong>簇</strong><br>（按几个盘块拼在一起的簇为单位分配、链接）<br><strong>簇</strong>减少了查找时间和指针所占空间，但增大了内部碎片</p>
<h4 id="显式链接"><a href="#显式链接" class="headerlink" title="显式链接"></a>显式链接</h4><p>即将用于链接文件各物理块的指针，显式地存放在内存的一张链接表中。<br>如FAT表<br><img src="/2022/05/08/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(5-6)/1651994193809.png" alt="enter description here"></p>
<p>属于某一文件的第一个盘块号，作为文件地址被填入相应文件的FCB的“物理地址”字段中。<br>由于分配给文件的所有盘块号都放在该表中，故把该表称为文件分配表FAT (File Allocation Table)。<br>查找记录的过程是在内存中进行的，显著地提高检索速度，减少了访问磁盘的次数。<br><img src="/2022/05/08/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(5-6)/1651994542717.png" alt="enter description here"><br>即FCB表记录文件的第一个盘块号，再通过FAT表查得所有文件盘块</p>
<p><strong>问题</strong><br>不能支持<strong>高效的直接存取</strong>。要对一个较大的文件进行直接存取，须首先在FAT中顺序地查找许多盘块号。<br>FAT需占用<strong>较大的内存空间</strong>。由于一个文件所占用盘块的盘块号是随机地分布在FAT中的，因而只有将整个FAT 调入内存，才能保证在FAT 中找到一个文件的所有盘块号。</p>
<h4 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h4><p>单级索引分配：解决连续分配和链接分配存在的诸多问题。<br><strong>原理</strong>：为每个文件分配一个索引块(表)，再把分配给该文件的<strong>所有盘块号</strong>都记录在该索引块中，索引块就是一个含有许多盘块号的数组。<br>而在建立一个文件时，只需在为之建立的目录项中填上指向该索引块的指针。</p>
<ul>
<li><strong>优点</strong> - 索引分配方式支持直接访问（直接找第i个）、基于数据块的分区能消除外部碎片</li>
<li><strong>缺点</strong> - 索引本身空间大小问题：大文件索引项较多，可能使一个数据块容纳不了一个文件的所有分区的索引。索引块可能要花费较多的外存空间。每当建立一个文件时，便须为之分配一个专门的索引块，将分配给该文件的所有盘块号记录于其中。对于小文件如果采用这种方式，索引块的利用率将是极低的。</li>
</ul>
<h5 id="两级索引分配"><a href="#两级索引分配" class="headerlink" title="两级索引分配"></a>两级索引分配</h5><p>当文件太大，其一级索引块太多时，这种方法是低效的。<br>此时，应为这些索引块再建立一级索引，形成两级索引分配方式。<br>即系统再分配一个索引块，作为第一级索引的索引块，将第一块、第二块……等索引块的盘块号填入到此索引表中、<br><img src="/2022/05/08/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(5-6)/1651995442272.png" alt="enter description here"></p>
<h1 id="文件存储空间的管理"><a href="#文件存储空间的管理" class="headerlink" title="文件存储空间的管理"></a>文件存储空间的管理</h1><p>文件存储空间的管理方法：空闲分区表、空闲链表法、位示图、成组链接法</p>
<h2 id="空闲分区表"><a href="#空闲分区表" class="headerlink" title="空闲分区表"></a>空闲分区表</h2><p>空闲表法属于<strong>连续分配</strong>方式，它为每个文件分配一块<strong>连续的存储空间</strong>，即系统也为外存上的所有空闲区建立一张空闲表，每个空闲区对应于一个空闲表项，其中包括表项序号、该空闲区的第一个盘块号、该区的空闲盘块数等信息。</p>
<p>其可用于可变大小分区的连续分配<br>为文件分配存储空间时，首先顺序查找空闲分区表中的各个表项，直至找到第一个大小适合的空闲分区。可以采用<strong>首次适应分配算法</strong>、<strong>最佳适应分配算法</strong>等。</p>
<ul>
<li><strong>优点</strong> - 实现简单。最佳适应分配算法，将各空闲分区按照（长度）从小到大的顺序进行排列，再利用有效的查找算法，能很快找到需要大小的空闲分区。</li>
<li><strong>缺点</strong> - 空闲分区分布较分散且数量较多时，空闲分区表将会很大。需要很大的内存空间，会降低空闲分区表的检索速度。</li>
</ul>
<p>一般文件系统当文件较小时采用连续分配而较大则需要采用离散分配</p>
<h2 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h2><p>如上用专门的空闲分区表登记空闲分区信息会浪费一定的存储空间，而且<strong>不适合</strong>登记分散且数目很多的空闲分区，<strong>不利于</strong>基于存储块的链接文件和索引文件的存储空间分配。</p>
<p>空闲链表法是将所有空闲盘区拉成一条空闲链。根据构成链所用基本元素的不同，可把链表分为空闲盘块链、空闲盘区链两种形式。</p>
<h3 id="空闲盘块链"><a href="#空闲盘块链" class="headerlink" title="空闲盘块链"></a>空闲盘块链</h3><p>将磁盘上的所有空闲空间，以盘块为单位拉成一条链，优点：简单</p>
<h3 id="空闲盘区链"><a href="#空闲盘区链" class="headerlink" title="空闲盘区链"></a>空闲盘区链</h3><p>将磁盘上的所有空闲盘区(每个盘区可包含若干个盘块)连成一条链，<br>而每个盘区上含有用于指示下一个空闲盘区的指针和能指明本盘区大小(盘块数)的信息。<br>分配盘区的方法与内存的动态分区分配类似，通常采用<strong>首次适应算法</strong>。<br><strong>问题</strong>：<br>一段时间以后，可能会使空闲分区链表中包含太多小分区，使文件分配到的存储空间过分离散。</p>
<h2 id="位示图"><a href="#位示图" class="headerlink" title="位示图"></a>位示图</h2><p>利用二进制位0、1表示存储空间中存储块的使用状态。空闲分区:0，已分配分区:1（或者相反）<br>通常可用m × n 个位数来构成位示图，并使m × n等于磁盘的总块数。</p>
<p>根据位示图进行盘块<strong>分配</strong>时，可分三步进行： </p>
<ol>
<li>顺序扫描位示图，从中找出一个或一组其值为“0”的二进制位(“0”表示空闲时)。</li>
<li> 将所找到的一个或一组二进制位转换成与之相应的盘块号。 假定找到的其值为“0”的二进制位位于位示图的第i 行、第j列，则其相应的盘块号应按下式计算： b = n(i- 1) + j</li>
<li> 修改位示图，令map[i,j]=1。</li>
</ol>
<p>盘块的<strong>回收</strong>分两步： </p>
<ol>
<li>将回收盘块的盘块号转换成位示图中的行号和列号。转换公式为： i = (b - 1)DIV n + 1 j = (b - 1)MOD n + 1</li>
<li>修改位示图。令map[i,j] =0。</li>
</ol>
<ul>
<li><strong>优点</strong> - 可以容易地找到一个或一组连续的空闲分区、小磁盘位示图空间小</li>
<li><strong>缺点</strong> - 大磁盘空间大、则很难将位示图装入内存</li>
</ul>
<h1 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h1><p>目录管理的要求： </p>
<ol>
<li>实现“按名存取”。 </li>
<li>提高对目录的检索速度。</li>
<li>文件共享。 </li>
<li>允许文件重名。</li>
</ol>
<p>文件控制块(FCB)：用于描述和控制文件的数据结构<br>文件目录：文件控制块的有序集合</p>
<h2 id="文件控制块FCB"><a href="#文件控制块FCB" class="headerlink" title="文件控制块FCB"></a>文件控制块FCB</h2><p><strong>内容</strong>：</p>
<ul>
<li>基本信息：文件名、文件类型等</li>
<li>地址信息：卷（存储文件的设备）、起始地址（起始物理地址）、文件长度（以字节、字或块为单位）等。</li>
<li>访问控制信息：文件所有者、访问信息（用户名和口令等）、合法操作等</li>
<li>使用信息：创建时间、创建者身份、当前状态、最近修改时间、最近访问时间等。</li>
</ul>
<h2 id="目录内容的组织方式及分析"><a href="#目录内容的组织方式及分析" class="headerlink" title="目录内容的组织方式及分析"></a>目录内容的组织方式及分析</h2><p>目录项的两种组织方式：</p>
<ol>
<li>FCB存储全部目录内容</li>
<li>存储部分目录信息，如文件名、索引节点指针等，其余部分保存在索引节。打开文件时将索引节点从磁盘读到内存中。</li>
</ol>
<h2 id="目录文件及操作"><a href="#目录文件及操作" class="headerlink" title="目录文件及操作"></a>目录文件及操作</h2><p>目录文件：<br>一个文件目录也被看做是一个文件，即目录文件。是多个文件的目录项构成的一种特殊文件。<br>目录的操作：<br>搜索目录、创建目录、删除目录、显示目录、修改目录</p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>单级目录结构，两级目录结构，层次目录结构 ：树型目录、无循环图</p>
<h3 id="单级目录结构分析"><a href="#单级目录结构分析" class="headerlink" title="单级目录结构分析"></a>单级目录结构分析</h3><p>所有用户的全部文件目录保存在一张目录表中，每个文件的目录项占用一个表项。<br><strong>优点</strong>简单且能实现目录管理的基本功能：按名存取<br><strong>缺点</strong> (1) 查找速度慢 (2) 不允许重名 (3) 不便于实现文件共享</p>
<h3 id="两级目录结构"><a href="#两级目录结构" class="headerlink" title="两级目录结构"></a>两级目录结构</h3><p>可分为主文件目录MFD、用户文件目录UFD</p>
<p>其一定程度<strong>解决</strong>了重名问题，提高了文件目录检索效率，也实现了简单的文件共享<br><strong>问题</strong>：不便用户文件的逻辑分类；进一步解决重名、共享、检索效率等问题</p>
<h3 id="多级目录结构"><a href="#多级目录结构" class="headerlink" title="多级目录结构"></a>多级目录结构</h3><p><strong>目录结构</strong>：多级目录结构又称为树型目录结构，主目录在这里被称为根目录，把数据文件称为树叶，其它的目录均作为树的结点。<br><strong>路径名</strong>：从树的根（即主目录）开始，把全部目录文件名与数据文件名，依次地用“/”连接起来，即构成该数据文件的路径名。<br><strong>当前目录</strong>：为每个进程设置一个“当前目录”，又称为“工作目录”进程对各文件的访问都相对于“当前目录”而进行。</p>
<h2 id="目录查询技术"><a href="#目录查询技术" class="headerlink" title="目录查询技术"></a>目录查询技术</h2><h3 id="线性检索法"><a href="#线性检索法" class="headerlink" title="线性检索法"></a>线性检索法</h3><p>又称为顺序检索法。<br>①在单级目录中，利用文件名，用顺序查找法直接从文件目录中找到指名文件的目录项。<br>②在树型目录中，用户提供的文件名是由多个文件分量名组成的路径名，此时须对多级目录进行查找。</p>
<h3 id="Hash方法"><a href="#Hash方法" class="headerlink" title="Hash方法"></a>Hash方法</h3><p>建立了一张Hash索引文件目录，用户提供的文件名并将它变换为文件目录的索引值，再利用该索引值到目录中去查找。<br>其显著提高了检索速度</p>
<h1 id="文件共享和访问控制"><a href="#文件共享和访问控制" class="headerlink" title="文件共享和访问控制"></a>文件共享和访问控制</h1><p>文件共享的有效控制涉及两个方面： 同时存取、存取权限</p>
<h2 id="控制同时存取"><a href="#控制同时存取" class="headerlink" title="控制同时存取"></a>控制同时存取</h2><p><strong>允许多个用户同时读文件内容，但不允许同时修改，或同时读且修改文件内容。</strong><br>共享用户之一修改文件内容时，将整个文件作为临界资源，锁定整个文件，不允许其他共享用户同时读或写文件。<br>仅仅锁定指定的一条记录，允许其他共享用户读/写该文件的其它记录。后者的并发性能更好。<br>控制对文件的同时存取涉及进程的同步与互斥问题。</p>
<h2 id="控制存取权限"><a href="#控制存取权限" class="headerlink" title="控制存取权限"></a>控制存取权限</h2><p>即控制授权用户以合法的方式访问文件<br>包括：<br>执行（Execution）<br>读（Reading）允许用户读文件内容，包括拷贝和执行文件<br>追加（Appending）<br>更新（Updating）即允许用户修改、删除、增加文件内容<br>更改权限 (Changing protection)<br>删除 (Deletion) </p>
<h2 id="文件共享的实现"><a href="#文件共享的实现" class="headerlink" title="文件共享的实现"></a>文件共享的实现</h2><p>从不同地方打开同一个文件，首要步骤就是找到文件的目录项，读取文件在外存的起始地址。<br>实现文件共享的方式：<br>利用链接目录项实现法、利用索引节点实现法、利用符号链实现法</p>
<h3 id="链接目录项实现"><a href="#链接目录项实现" class="headerlink" title="链接目录项实现"></a>链接目录项实现</h3><p>文件<strong>目录项中设置一个链接指针</strong>，用于指向共享文件的目录项。访问文件时，根据链接指针内容找到共享文件的目录项，读取该目录项中文件起始位置等信息，操作该文件。</p>
<h3 id="利用索引节点实现"><a href="#利用索引节点实现" class="headerlink" title="利用索引节点实现"></a>利用索引节点实现</h3><p>文件的物理地址及其它的文件属性等信息，<strong>不再是放在目录项中，而是放在索引结点中</strong>。在文件目录中只设置文件名及指向相应索引结点的指针。<br>文件目录项中只包含文件名和指向索引节点的指针，文件的物理地址及其它说明信息保存在索引节点中</p>
<h3 id="利用符号链实现"><a href="#利用符号链实现" class="headerlink" title="利用符号链实现"></a>利用符号链实现</h3><p>在利用符号链方式实现文件共享时，只是文件主才拥有指向其索引结点的指针,而共享该文件的其它用户，则只有该文件的路径名，并不拥有指向其索引结点的指针。<br>优点：能连接任何机器上的文件<br>缺点：备份可能会产生多个拷贝</p>
<h3 id="利用URL实现"><a href="#利用URL实现" class="headerlink" title="利用URL实现"></a>利用URL实现</h3><p>统一资源定位器URL (Uniform Resource Locator)是Internet上用来链接超文本文件的一种方法。它可以链接同一台计算机中的本地文件，也可链接Internet中任何主机上的远程文件。</p>
<h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><h2 id="P266"><a href="#P266" class="headerlink" title="P266"></a>P266</h2><ul>
<li>2、文件系统模型每层的基本内容<br><img src="/2022/05/08/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(5-6)/1652009244891.png"></li>
</ul>
<ol>
<li><strong>对象及其属性</strong> - 对象即文件、目录、磁盘存储空间</li>
<li><strong>对对象操纵和管理的软件集合</strong> - 包括对文件存储空间的管理、对文件目录的管理、逻辑地址转换为物理地址、对文件读和写的管理、文件的共享与保护</li>
<li><strong>文件系统的接口</strong> - 命令接口：用户与文件系统交互的接口，通过终端键入命令取得服务。程序接口：用户程序与文件系统的接口，通过系统调用来取得服务。</li>
</ol>
<ul>
<li><p>4、用户可以对文件施加的主要操作<br>创建文件、删除文件、读文件、写文件、打开、关闭。</p>
</li>
<li><p>5、为什么引入“打开”，打开的含义<br>所谓“打开”，是指系统将指名文件的属性（包括该文件在外存上的物理位置）从外存拷贝到内存打开文件表的一个表目中，并将该表目的编号（或称为索引）返回给用户。<br>通过打开建立的连接，用户可以直接获取文件信息而避免了再次检索</p>
</li>
<li><p>6、解释文件的逻辑结构和物理结构</p>
</li>
</ul>
<ol>
<li>文件的逻辑结构 从用户观点出发所观察到的文件组织形式 。从逻辑组织的角度看，文件由若干记录构成</li>
<li>文件的物理结构 文件在外存上的存储组织形式 。从物理组织的角度看，文件由若干数据块组成</li>
</ol>
<ul>
<li>7、按文件的组织方式可将文件分了哪几类</li>
</ul>
<ol>
<li>普通文件：由ASCII码或二进制码组成的字符文件。用户建立的源程序文件、数据文件、目标代码文件及操作系统自身代码文件、库文件、实用程序文件等都是普通文件，它们通常存储在外存储设备上。</li>
<li>目录文件：由文件目录组成的，管理和实现文件系统功能的系统文件，目录文件可以对其它文件的信息进行检索。由字符序列构成，与普通文件一样操作。</li>
<li>特殊文件：特指系统中的各类I/O 设备。统一管理，系统将所有的输入/输出设备都视为文件，按文件方式提供给用户使用</li>
</ol>
<ul>
<li><p>8、如何提高对变长记录文件的检索速度<br>建立索引表<br>为每个文件分配一个索引块(表)，再把分配给该文件的<strong>所有盘块号</strong>都记录在该索引块中，索引块就是一个含有许多盘块号的数组。也可通过多级索引进一步提升检索速度</p>
</li>
<li><p>9、通过哪两种方法对固定长度记录随机访问<br>通过文件中记录的位置 据第一条记录的首地址和记录长度，可计算第i条记录的地址。<br>利用关键字 通过关键字值顺序查找记录。</p>
</li>
<li><p>12、对索引文件和索引文件顺序的检索方式<br>对索引文件：根据关键字利用某种算法检索索引表，找到对应表项通过记录指针访问记录<br>对索引顺序：首先根据用户关键字在索引表中查找第一条记录指针，然后通过指针再在记录组内顺序查找</p>
</li>
<li><p>14、对目录管理的主要要求是什么</p>
</li>
</ul>
<ol>
<li>实现“按名存取”。 </li>
<li>提高对目录的检索速度。</li>
<li>文件共享。 </li>
<li>允许文件重名。</li>
</ol>
<ul>
<li><p>15、采用单级目录能否满足目录管理要求<br>单级目录的优点是简单且能实现目录管理的基本功能——按名存取<br>但存在下述一些缺点： (1) 查找速度慢 (2) 不允许重名 (3) 不便于实现文件共享</p>
</li>
<li><p>16、目前广泛采用的目录结构是什么，有什么优点<br>树形目录<br>优点：提高对目录的检索速度和文件系统性能、便于分用户管理</p>
</li>
<li><p>19、Hash检索法中如何解决冲突<br>将其Hash值再加上一个常数（该常数应与目录的长度值互质），形成新的索引值，再返回到第一步重新开始查找。</p>
</li>
<li><p>23、基于符号链的文件共享的优点<br>能连接任何机器上的文件。 每增加一个连接，就增加一个文件名，各用户使用自己的名字去共享文件。</p>
</li>
<li><p>24、什么是保护域、进程和保护域的动态联系是什么<br>进程对一组对象访问权的集合，进程只能在指定区域内执行操作，域也就规定了进程所能访问的对象和能执行的操作。<br>进程和域之间，可以是一对多的关系，即一个进程可以联系着多个域。在此情况下，可将进程的运行分为若干个阶段，其每个阶段联系着一个域，这样便可根据运行的实际需要来规定在进程运行的每个阶段中所能访问的对象。</p>
</li>
<li><p>25、举例说明具有域切换权的访问控制矩阵<br><img src="/2022/05/08/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(5-6)/IMG_20220508_195344_edit_703369545537463.jpg" alt="IMG_20220508_195344_edit_703369545537463"><br>如图，由于域D1和D2所对应的项目中有一个S代表switch故允许域D1中的进程切换到D2中。</p>
</li>
</ul>
<h2 id="P296"><a href="#P296" class="headerlink" title="P296"></a>P296</h2><ul>
<li><p>1、目前常用的外存组织方式<br>连续组织方式：为文件在物理上分配连续的磁盘空间<br>链接组织方式：文件可以存在不连续的盘块中而通过链接记录链接在一起<br>索引组织方式：建立索引记录文件组织</p>
</li>
<li><p>2、连续组织方式的顺序文件的优缺点及适用场合<br>为每一个文件分配一组相邻接的盘块。<br>即把<strong>逻辑文件</strong>中的数据顺序地存储到物理上邻接的各个数据块中，形成的<strong>物理文件</strong>进行顺序存取。<br>对应文件目录中为每个文件建立一个表项，只用记载文件的第一个数据块地址及文件长度</p>
</li>
<li><p><strong>优点</strong> - 顺序访问（检索）容易、顺序访问速度快</p>
</li>
<li><p><strong>问题</strong> - 要求有连续的存储空间导致磁盘空间碎片化（要使用紧凑技术）、必须事先知道文件的长度不利于动态增长的文件存储<br>连续组织方式所形成的顺序文件是一种最简单、最常用的文件组织方法，它适用于许多资料处理的场合，如磁带文件，打印文件都是常用的顺序文件</p>
</li>
<li><p>3、链接式文件中常采用什么方式<br>空闲盘块链：将磁盘上的所有空闲空间，以盘块为单位拉成一条链；空闲盘区链：将磁盘上的所有空闲盘区(每个盘区可包含若干个盘块)连成一条链， 而每个盘区上含有用于指示下一个空闲盘区的指针和能指明本盘区大小(盘块数)的信息。</p>
</li>
<li><p>13、说明增量式索引组织方式<br>增量式索引组织方式的基本思想：为了能较全面地照顾到小、中、大及特大型作业，可以采取多种组织方式来构成文件的物理结构。如果盘块的大小为1 B或4 B，对于小文件而言，最多只会占用10个盘块，为了能提高对数量众多的小型作业的访问速度，最好能将它们的每一个盘块地址都直接放入文件控制块FCB(或索引结点)中，这样就可以直接从FCB中获得该文件的盘块地址。</p>
</li>
<li><p>16、对空闲磁盘空间的管理常采用的分配方式、UNIX采用什么方式<br>文件存储空间的管理方法：空闲分区表、空闲链表法、位示图、成组链接法，UNIX系统采用的是成组链接法。</p>
</li>
</ul>

      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/07/Git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/07/Git/" class="post-title-link" itemprop="url">Git</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-07 20:00:30 / 修改时间：20:00:31" itemprop="dateCreated datePublished" datetime="2022-05-07T20:00:30+08:00">2022-05-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/" class="post-title-link" itemprop="url">计算机操作系统(4)存储器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-20 14:51:07" itemprop="dateCreated datePublished" datetime="2022-04-20T14:51:07+08:00">2022-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-08 13:33:14" itemprop="dateModified" datetime="2022-05-08T13:33:14+08:00">2022-05-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h1><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><p><img src="/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/1650529219846.png" alt="enter description here"><br>速度从高到低、容量从小到大</p>
<h3 id="存储器管理的目的和功能"><a href="#存储器管理的目的和功能" class="headerlink" title="存储器管理的目的和功能"></a>存储器管理的目的和功能</h3><ul>
<li>主存储器的分配和管理</li>
<li>提高主存储器的利用率</li>
<li>“扩充”主存容量</li>
<li>存储保护</li>
</ul>
<h3 id="存储分配的三种方式"><a href="#存储分配的三种方式" class="headerlink" title="存储分配的三种方式"></a>存储分配的三种方式</h3><ul>
<li>直接指定方式（汇编地址写入）</li>
<li>静态分配方式（程序装入时确定位置）</li>
<li>动态分配方式</li>
</ul>
<h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><p>将用户源程序变为可在内存中执行的程序：</p>
<ul>
<li> 编译 翻译成机器级代码</li>
<li> 链接 使目标模块链接（引用的其它模块）成装入模块的过程</li>
<li> 装入 由装入程序将装入模块装入内存并执行</li>
</ul>
<h3 id="程序的装入"><a href="#程序的装入" class="headerlink" title="程序的装入"></a>程序的装入</h3><ul>
<li>绝对装入方式</li>
<li>可重定位装入方式（静态、动态）</li>
<li>动态运行时装入方式</li>
</ul>
<h3 id="程序的链接"><a href="#程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h3><ul>
<li>静态链接</li>
<li>装入时动态链接</li>
<li>运行时动态链接</li>
</ul>
<h2 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h2><p>程序空间本来就是连续的用连续的内存装入连续的程序，减少管理工作的难度</p>
<ul>
<li><p>单一连续分配方式（一个进程在内存）</p>
<ul>
<li>优点：易于管理</li>
<li>缺点：对要求内存空间少的程序，造成内存浪费；程序全部装入，很少使用的程序部分也占用内存。</li>
</ul>
</li>
<li><p>分区式分配方式（一个进程占据一个分区）</p>
<ul>
<li>固定分区分配<ul>
<li>易于实现，开销小</li>
<li>内碎片造成浪费；分区总数固定，限制了并发执行的程序数目；存储空间的利用率太低</li>
</ul>
</li>
<li>动态分区分配——分区分配算法</li>
</ul>
</li>
</ul>
<ul>
<li>可重定位分区分配 定时把存储空间中的空白区合并为一个大的连续区 之前的可变式分区分配根据其要求量为其划定相应的区域。消除了 “内零头”，但造成“外零头”</li>
</ul>
<h3 id="分区分配算法"><a href="#分区分配算法" class="headerlink" title="分区分配算法"></a>分区分配算法</h3><p><img src="/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/1650532050974.png" alt="enter description here"></p>
<ul>
<li>内零头(Internal Fragment)：分配给用户但用户没有使用的空间 “多分配的空间”</li>
<li>外零头(External Fragment )：没有分配但无法分配的空间，太小而无法分配，“分不出去的空间”</li>
</ul>
<h4 id="最佳适应算法BF"><a href="#最佳适应算法BF" class="headerlink" title="最佳适应算法BF"></a>最佳适应算法BF</h4><p>选择分区时总是寻找其大小最接近作业所要求的存储区域</p>
<ul>
<li>优点：遇到大作业到来时，比较容易得到满足</li>
<li>缺点： 留下许多无法使用的空白区；回收时，把它插入空白区链也颇为费时</li>
</ul>
<h4 id="最坏适应算法WF"><a href="#最坏适应算法WF" class="headerlink" title="最坏适应算法WF"></a>最坏适应算法WF</h4><p>寻找最大的空白区</p>
<ul>
<li>缺点：将大空间分给了小作业后大作业来到无法满足申请</li>
</ul>
<h4 id="首次适应算法FF"><a href="#首次适应算法FF" class="headerlink" title="首次适应算法FF"></a>首次适应算法FF</h4><p>空白区链的始端开始查找，选择第一个足以满足请求的空白块<br>分配后空白区被分成两部分一部分分配给作业；剩下的部分留在原空白区链中</p>
<ul>
<li>优点：简单，查找速度快</li>
<li>缺点：存储空间利用率不高；找到合适空白区的速度降低。</li>
</ul>
<h4 id="循环首次适应算法NF"><a href="#循环首次适应算法NF" class="headerlink" title="循环首次适应算法NF"></a>循环首次适应算法NF</h4><p>（下次适应算法）从上次查找结束的地方开始，找到一个足够大的空白区，就分配</p>
<ul>
<li>优点：存储空间的利用更加均衡</li>
<li>缺点：需要获得相当大的空白区时，很难满足</li>
</ul>
<h4 id="快速适应算法QF"><a href="#快速适应算法QF" class="headerlink" title="快速适应算法QF"></a>快速适应算法QF</h4><p>每一类具有<strong>相同容量</strong>的空闲分区，单独设立一个空闲分区链表<br>在内存中设立一张<strong>索引表</strong>，每一个表项记录空闲分区链表表头的指针<br>分配过程：根据进程的长度，寻找到能容纳它的最小空闲分区链表，并取下第一块进行分配即可</p>
<ul>
<li>优点：查找效率高；满足对大空间的需求，也不会产生内存碎片</li>
<li>缺点：分区归还算法复杂，系统开销较大；以进程为单位，存在一定的浪费</li>
</ul>
<h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h4><p>固定分区分配：并发执行的进程数量受到限制；内部碎片影响内存利用率<br>动态分区分配：算法复杂，回收分区时系统开销大</p>
<p>在伙伴系统中，可用内存块的大小为 2^k (1≤k≤m) </p>
<ul>
<li>2^1表示分配的最小块的尺寸；</li>
<li>2^m表示分配的最大块的尺寸，通常是可供分配的整个内存空间的大小。</li>
</ul>
<p>对空闲区按照大小分类，相同大小的分区链接为一个双向空闲链表；最多可形成 k（0 ≤k≤m ）个链表。</p>
<h2 id="分页存储管理方式"><a href="#分页存储管理方式" class="headerlink" title="分页存储管理方式"></a>分页存储管理方式</h2><h3 id="引入分页"><a href="#引入分页" class="headerlink" title="引入分页"></a>引入分页</h3><ul>
<li>离散分配方式的引入：<br>  连续分配方式会产生内/外零头<br>  为解决零头问题又要进行紧凑等高开销活动 </li>
<li>什么是离散分配：程序在内存中不一定连续存放 </li>
<li>根据离散时的基本单位不同，可分为三种：<br>  分页存储管理<br>  分段存储管理<br>  段页式存储管理</li>
</ul>
<h4 id="分页存储管理基本思想"><a href="#分页存储管理基本思想" class="headerlink" title="分页存储管理基本思想"></a>分页存储管理基本思想</h4><ul>
<li>离散的基础<pre><code>分页(Pages)：将程序地址空间分页
分块(Frames)：将内存空间分块
</code></pre>
</li>
<li>离散分配的体现<ul>
<li>内存一块可以装入程序一页</li>
<li>连续的多个页不一定装入连续的多个块中</li>
<li>注：系统中页块的大小是不变的。</li>
</ul>
</li>
</ul>
<p>离散分配没有外零头，且内零头肯定少于一个页面</p>
<h4 id="分页存储管理的基本方法"><a href="#分页存储管理的基本方法" class="headerlink" title="分页存储管理的基本方法"></a>分页存储管理的基本方法</h4><p>如何建立程序空间与主存空间的映射——页表<br>如何进行地址变换——从程序逻辑地址到内存物理地址</p>
<h4 id="页面和物理块"><a href="#页面和物理块" class="headerlink" title="页面和物理块"></a>页面和物理块</h4><ul>
<li>页面或页(Page)：把每个进程的逻辑地址空间分成一些大小相等的片。</li>
<li>物理块或页框(Page Frame)：内存空间也分成与页相同大小的若干存储块。在为进程分配存储空间时，总是以页框为单位。</li>
</ul>
<p>页面大小由机器的地址结构决定通常在1KB~8KB之间。</p>
<h4 id="实现分页存储管理的数据结构"><a href="#实现分页存储管理的数据结构" class="headerlink" title="实现分页存储管理的数据结构"></a>实现分页存储管理的数据结构</h4><ul>
<li>页表：进程，描述该进程的各页面在内存中对应的物理块号。页表中包括页号、物理块号。</li>
<li>作业表：系统，记录作业的页表情况。</li>
<li>空闲块表：系统，记录主存当前空闲块。</li>
</ul>
<h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><p>使用寄存器：速度快，成本高<br>一般将页表存在内存进程的PCB中，运行时再装入页表寄存器PTR</p>
<p>分页系统中的地址变换过程如下：</p>
<ol>
<li>根据逻辑地址,<strong>计算出页号和页内偏移量</strong>；</li>
<li>从PTR中得到页表首址，然后<strong>检索页表</strong>，查找指定页面对应的<strong>页框号</strong>；</li>
<li>用页框号乘以页面大小获得其对应的<strong>起始地址</strong>，并将其送入物理地址的<strong>高端</strong>。</li>
<li>将<strong>页内偏移量</strong>送入物理地址低端，<strong>形成完整的物理地址</strong>。</li>
</ol>
<h3 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h3><p>快表TLB为了提高地址变换速度，为进程页表设置一个<strong>专用的高速缓冲存储器</strong>其中专门保存<strong>当前进程最近访问过</strong>的一组页表项。<br>根据逻辑地址中的页号，会先查找快表中是否存在对应的页表项。<br>若快表中存在该表项，称为<strong>命中</strong>，取出其中的页框号加上页内偏移量计算出物理地址。<br>若快表中不存在该页表项，称为<strong>命中失败</strong>，则再查找页表，找到逻辑地址中指定页号对应的页框号。<br>同时，更新快表，将该表项插入快表中。</p>
<h4 id="访问内存的有效时间-EAT"><a href="#访问内存的有效时间-EAT" class="headerlink" title="访问内存的有效时间 EAT"></a>访问内存的有效时间 EAT</h4><p>命中率a、查找快表时间b、访问内存时间c<br>有效访问时间EAT=a ✖ （b+c）+ (1- a) ✖ (b+2c)</p>
<h3 id="两级和多级页表"><a href="#两级和多级页表" class="headerlink" title="两级和多级页表"></a>两级和多级页表</h3><p>引入两级页表采用离散分配方式，来解决难以找到一块连续的大内存空间的问题</p>
<p>利用离散分配方法实现的两级页表只是解决了大页表无需大片<strong>连续</strong>存储空间问题，但并未减少<strong>用较少内存去存放大页表</strong>问题，有关此类问题的成功解决方案在虚拟存储器管理中。</p>
<h3 id="反置页表IPT"><a href="#反置页表IPT" class="headerlink" title="反置页表IPT"></a>反置页表IPT</h3><p>为了解决大页表问题占内存多现象，减少内存开销，避免一个进程一个页表。</p>
<p>IPT采用为主存中的每一个物理块建立一个页表项并按照块号排序，该表每个表项包含正在访问该物理块的进程标识、页号及特征位，用来完成主存物理块到访问进程的页号的转换。</p>
<p><strong>即反过来查，原来是进程查物理现在是物理地址记录进程</strong></p>
<h2 id="对换"><a href="#对换" class="headerlink" title="对换"></a>对换</h2><p>对换就是把内存中暂时不用的程序和数据换到外存，或把需要的程序和数据换入内存。<br>分为：</p>
<ul>
<li>整体对换 以进程为单位</li>
<li>页面/分段对换：以页或段为单位</li>
</ul>
<h2 id="分段存储管理方式"><a href="#分段存储管理方式" class="headerlink" title="分段存储管理方式"></a>分段存储管理方式</h2><p>根据程序模块化设计时会将程序分段（如主程序段、子程序段、数据段等）而分段管理便是按程序模块化设计思想分段存储。</p>
<ul>
<li>作业地址空间按逻辑信息的完整性被划分为若干个段；</li>
<li>段内的地址空间是连续的；</li>
<li>许多编译程序支持分段方式，自动根据源程序的情况产生若干个段。</li>
</ul>
<p>分段较分页易于实现段的共享和段的保护。</p>
<h2 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h2><ul>
<li>分页管理内存管理效率高<ul>
<li>没有外零头</li>
<li>内零头小</li>
</ul>
</li>
<li>分段管理符合模块化思想<ul>
<li>每个分段都具备完整的功能</li>
<li>方便代码共享、保护</li>
<li>没有内零头，存在外零头</li>
</ul>
</li>
</ul>
<p>段页式管理结合：先将用户程序分段，每段内再划分成若干页，每段有段号，每段内部的页有一连续的页号。</p>
<p>但在段页式存储管理方式中，每访问一次数据，需访问三次内存。 访问段表、访问页表、访问相应数据，大大降低了访问速度。<br>可以设置快表，表项应包括段号、页号、物理块号。</p>
<p>总结：</p>
<ul>
<li>综合了分段和分页技术的优点，既能有效地利用存储空间，又能方便用户进行程序设计</li>
<li>但是，实现段页式存储管理系统需要增加硬件成本，系统的复杂度和管理开销也大大增加</li>
<li>因此，段页式存储管理技术适合于大、中型计算机系统，不太适合小型、微型计算机系统</li>
</ul>
<h1 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h1><h2 id="虚拟存储器概述"><a href="#虚拟存储器概述" class="headerlink" title="虚拟存储器概述"></a>虚拟存储器概述</h2><p>传统内存管理的一次性和驻留性严重降低内存利用率，减少系统吞吐量<br>当一个程序要求的存储容量超过内存，或大量作业需要内存空间时<br>从物理上增加内存容量，增加系统成本，并且增加是有限的。<br>所以从逻辑上增加内存容量，是虚拟存储技术所要解决的主要问题。</p>
<p>当进程运行时，先将当前<strong>要运行的部分程序装入内存</strong>，其他部分暂留外存；<br>当要执行的指令不在内存时，处理器发生中断，通知操作系统将所缺部分从外存调入内存，保证程序继续执行；<br>当内存不足时，允许程序部分换入、换出。<br><img src="/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/1650616504120.png" alt="enter description here"></p>
<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>程序的执行总是呈现局部性。即在一个较短的时间段内，程序的执行仅限于某个部分。因此只要保证进程<strong>执行所需</strong>的部分程序和数据<strong>驻留在内存</strong>，一段时间内进程都能顺利执行。</p>
<p>具体表现为</p>
<ul>
<li>时间局限性 被访问过的数据可能再次被访问</li>
<li>空间局限性 被访问过的存储单元其附近也可能被访问</li>
</ul>
<h3 id="虚拟存储器的定义"><a href="#虚拟存储器的定义" class="headerlink" title="虚拟存储器的定义"></a>虚拟存储器的定义</h3><p><strong>虚拟存储器</strong>：是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。<br>是一种性能非常优越的存储器管理技术，故被广泛地应用于大、中、小型机器和微型机中。</p>
<h3 id="虚拟存储器的特征"><a href="#虚拟存储器的特征" class="headerlink" title="虚拟存储器的特征"></a>虚拟存储器的特征</h3><ul>
<li><strong>多次性</strong> 多次性是指一个作业被分成多次调入内存运行。相对传统储存管理的<strong>一次性</strong></li>
<li><strong>对换性</strong> 对换性是指作业的运行过程中进行换进、换出。换进和换出能有效地提高内存利用率。相对传统储存管理的常驻性</li>
<li><strong>虚拟性</strong> 虚拟性是指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。</li>
</ul>
<h2 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h2><p><strong>工作原理</strong>：作业运行时，只将当前的一部分装入内存其余的放在辅存，一旦发现访问的页不在主存中，则发出缺页中断，由OS将其从辅存调入主存，如果内存无空块，则根据某种算法选择一个页淘汰以便装入新的页面。</p>
<p>利用这种方法，可使更多的作业处于就绪状态，且能支持比主存容量大的作业在系统中运行。从而提高存储空间利用率。</p>
<p>为了实现请求调页、页面置换两大功能，系统必须提供如下的硬件支持：</p>
<ol>
<li>请求分页的页表机制。</li>
<li>缺页中断机构。</li>
<li>地址变换机构。</li>
</ol>
<h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><ul>
<li>固定分配局部置换 但是难以确定进程合适的分配大小</li>
<li>可变分配全局置换（常用方式）预先分配用完再加</li>
<li>可变分配局部置换 发现缺页后要换出再自行换入，不干涉其它区域</li>
</ul>
<h3 id="物理块分配算法"><a href="#物理块分配算法" class="headerlink" title="物理块分配算法"></a>物理块分配算法</h3><ul>
<li>平均分配算法</li>
<li>按比例分配算法 根据进程的大小</li>
<li>考虑优先权的分配算法</li>
</ul>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><h3 id="最佳-优-置换算法OPT"><a href="#最佳-优-置换算法OPT" class="headerlink" title="最佳(优)置换算法OPT"></a>最佳(优)置换算法OPT</h3><p>理论上最理想的页面置换策略是：从主存中移出永远不再需要的页面；如无这样的页面存在，则应选择最长时间不需要访问的页面。</p>
<h3 id="先进先出（FIFO）页面置换算法"><a href="#先进先出（FIFO）页面置换算法" class="headerlink" title="先进先出（FIFO）页面置换算法"></a>先进先出（FIFO）页面置换算法</h3><p>实质是：总是选择作业中驻留时间最长(即最老)的一页淘汰。即：先进入主存的页面先退出主存。</p>
<h3 id="最近最久未使用（LRU）置换算法"><a href="#最近最久未使用（LRU）置换算法" class="headerlink" title="最近最久未使用（LRU）置换算法"></a>最近最久未使用（LRU）置换算法</h3><p>实质是：当需要置换一页面时，选择在最近一段时间内最久不用的页面予以淘汰。<br>特别的LRU需要硬件支持记录每个页面的最近使用情况</p>
<p>另有最少使用置换算法LFU：选择到当前时间为止被访问次数最少的页面被置换</p>
<h3 id="简单Clock置换算法"><a href="#简单Clock置换算法" class="headerlink" title="简单Clock置换算法"></a>简单Clock置换算法</h3><p>此算法为每页设置一位访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列。<br>具体操作：</p>
<ul>
<li>当某页被访问时，其访问位被置1。</li>
<li>置换程序从上次停止位置开始检查页面的访问位。<ul>
<li>如果是0，就选择该页换出；</li>
<li>若为1，则重新将它置0，给该页驻留内存的机会暂不换出。</li>
</ul>
</li>
</ul>
<p>例：<br><img src="/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/1650618210434.png" alt="enter description here"><br><img src="/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/1650618215534.png" alt="enter description here"></p>
<h3 id="改进Clock置换算法"><a href="#改进Clock置换算法" class="headerlink" title="改进Clock置换算法"></a>改进Clock置换算法</h3><p>如果该页面驻留内存期间没有被修改过，那么不必把它写回辅存，否则系统必须把它写回辅存。<br><strong>即相对简单CLOCK添加修改位</strong></p>
<p>由访问位A和修改位M组合四种类型页面：</p>
<ol>
<li>类（A=0，M=0：既未彼访问，又未被修改，是最佳淘汰页。</li>
<li>类（A=0，M=1）：最近未被访问，但已被修改，并不是很好的淘汰页。</li>
<li>类（A=1，M=0）：最近已被访问，但未被修改：该页有可能再被访问。</li>
<li>类（A=1，M=1）：最近已被访问且被修改，该页可能再被访问。</li>
</ol>
<h2 id="缺页率对有效访问时间的影响"><a href="#缺页率对有效访问时间的影响" class="headerlink" title="缺页率对有效访问时间的影响"></a>缺页率对有效访问时间的影响</h2><p>设内存读写周期为t，查找快表时间为λ，缺页中断处理时间为ɛ</p>
<ul>
<li>页面在内存且页表项在快表中,只需一次访问内存<br>  EAT= λ + t</li>
<li>页面在内存但页表项不在快表中,需两次访问内存，一次读取页表，一次读取数据，另外还需更新快表。<br>  EAT= λ + t + t + λ=2(λ + t)</li>
<li>页面不在内存：考虑查找快表时间、查找页表时间、缺页中断处理时间、更新快表时间、访问实际物理地址时间<br>  EAT= λ + t +ɛ + λ + t = ɛ + 2(λ + t)<br>综上：</li>
<li>则<strong>引入快表命中率为α</strong>，<strong>缺页中断率为f</strong>，则有效访问内存时间为<br>  EAT= λ + α t + (1- α)[t + f(t +ɛ +λ) + (1-f)(t +λ)]</li>
</ul>
<h2 id="抖动和工作集"><a href="#抖动和工作集" class="headerlink" title="抖动和工作集"></a>抖动和工作集</h2><p><strong>抖动</strong>：如果运行进程的大部分时间都用于页面的换入/换出，而几乎不能完成任何有效的工作，则称此进程处于抖动状态。<br>抖动产生的原因有：</p>
<ul>
<li>进程分配的物理块太少</li>
<li>置换算法选择不当</li>
<li>全局置换使抖动传播</li>
</ul>
<p>可利用抖动发生前出现的征兆发现抖动并加以防范。<br>这些技术有：</p>
<ul>
<li>采取局部置换策略</li>
<li>引入工作集的算法</li>
<li>L=S准则 - L缺页之间的平均时间，S平均缺页服务时间</li>
<li>选择暂停的进程</li>
</ul>
<h2 id="请求分段存储管理方式"><a href="#请求分段存储管理方式" class="headerlink" title="请求分段存储管理方式"></a>请求分段存储管理方式</h2><p>工作原理：<br>请求分段系统中，程序运行之前，只需先调入若部分分段，便可启动运行。<br>当所访问的段不在内存中时，可请求OS将所缺的段调入内存。<br>硬件支持：</p>
<ul>
<li>请求分段的段表机制。</li>
<li>缺段中断机构。</li>
<li>地址变换机构。</li>
</ul>
<h3 id="段表机制"><a href="#段表机制" class="headerlink" title="段表机制"></a>段表机制</h3><p><img src="/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/1650619179190.png" alt="enter description here"></p>
<h3 id="环保护"><a href="#环保护" class="headerlink" title="环保护"></a>环保护</h3><p>环保护的基本原则是：<br>一个程序可以<strong>访问</strong>驻留在相同环或<strong>较低</strong>特权环中的数据<br>一个程序可以<strong>调用</strong>驻留在相同环或<strong>较高</strong>特权环中的服务。</p>
<h1 id="习题4"><a href="#习题4" class="headerlink" title="习题4"></a>习题4</h1><h2 id="P162"><a href="#P162" class="headerlink" title="P162"></a>P162</h2><ol start="2">
<li>可采用哪几种方式将程序装入内存？它们分别适合何种场合</li>
</ol>
<ul>
<li>绝对装入方式，适于单道程序环境</li>
<li>可重定位装入方式，适于多道程序环境，静态存储分配</li>
<li>动态运行时装入方式，适于多道程序环境，动态存储分配</li>
</ul>
<ol start="3">
<li>何谓静态链接？静态链接需要解决两个什么问题</li>
</ol>
<ul>
<li>静态链接：在程序运行之前，先将各目标模块及它们所需的库函数，链接成一个完整的装入模块（又称执行模块），以后不再拆开</li>
<li>需要解决：将相对地址进行修改；变换外部调用符号</li>
</ul>
<ol start="5">
<li>何谓运行时动态链接？运行时动态链接有何优点</li>
</ol>
<ul>
<li>运行时动态链接：将某些目标模块的链接推迟到执行时才进行。</li>
<li>优点：节省内存空间</li>
</ul>
<ol start="6">
<li>在动态分区分配方式中，应如何将各空闲分区链接成空闲分区链</li>
</ol>
<ul>
<li><strong>按照地址递增的顺序链接分区</strong>：首次适应、循环首次适应</li>
<li><strong>按照分区大小顺序链接分区</strong>：最佳适应、最坏适应算法</li>
<li><strong>按分区的大小和分类链接成多条分区链</strong>：快速适应、伙伴系统、哈希算法</li>
</ul>
<ol start="8">
<li><p>什么是基于顺序搜索的动态分区分配算法？分为哪几种<br> 它将空闲分区链接成空闲分区链，以此在分配时搜索链上分区，找到满足算法要求的分区<br> 分为首次适应算法、循环首次适应算法、最佳适应算法、最坏适应算法</p>
</li>
<li><p>在采用首次适应算法回收内存时，可能出现哪几种情况？应怎么处理</p>
</li>
</ol>
<ul>
<li>回收区与<strong>上面</strong>的空闲分区邻接，合并，首地址仍是前一空闲分区的，不必为回收分区分配新表项，只需修改前一分区大小</li>
<li>回收区与<strong>下面</strong>的空白区邻接，合并，重新使用新空闲区首址，修改大小</li>
<li>回收区与<strong>上、下面</strong>的空白区邻接，合并，直接将后面空白区取消，修改大小，首地址仍是前一空闲分区的</li>
<li>回收区与<strong>上、下面</strong>的空白区均不邻接，建立新表项</li>
</ul>
<ol start="13">
<li><p>为什么要引入对换？对换可分为哪几种类型<br>为了提高系统的吞吐量，提高内存的利用率和处理机的利用率；<br>全局对换、局部对换。</p>
</li>
<li><p>为实现对换，系统应具备哪几方面的功能<br>对对换空间的管理<br>进程的换入、换出</p>
</li>
<li><p>基于离散分配时所用的基本单位不同，可将离散分配分为哪几种？<br>分页存储管理方式、分段存储管理方式、段页式存储管理方式</p>
</li>
<li><p>什么是页表？页表的作用是什么？<br>每个进程对应 1 个页表，描述该进程的所需各页面在内存中对应的物理块号。</p>
</li>
<li><p>为实现分页存储管理。需要哪些硬件支持?<br>页表寄存器、物理地址寄存器和快表寄存器。<br>地址变换机构。</p>
</li>
<li><p>在分页系统中是如何实现地址变换的?<br>（1）根据逻辑地址,计算出页号和页内偏移量；<br>（2）从PTR中得到页表首址，然后检索页表，查找指定页面对应的页框号；<br>（3）用页框号乘以页面大小获得其对应的起始地址，并将其送入物理地址的高端。<br>（4）将页内偏移量送入物理地址低端，形成完整的物理地址。</p>
</li>
<li><p>在具有快表的段页式存储管理方式中，如何实现地址变换?<br>根据逻辑地址中的页号，查找快表中是否存在对应的页表项。<br>若快表中存在该表项，称为命中（hit），取出其中的页框号，加上页内偏移量，计算出物理地址。<br>若快表中不存在该页表项，称为命中失败，则再查找页表，找到逻辑地址中指定页号对应的页框号。同时，更新快表，将该表项插入快表中。并计算物理地址</p>
</li>
<li><p>分页和分段存储管理有何区别?<br>页是信息的物理单位，而段是信息的逻辑单位。<br>页的大小固定而且由系统决定，段的大小不固定，通常由编译程序划分。<br>分页用户程序地址空间是一维的，分段用户程序地址空间是二维的。</p>
</li>
<li><p>试全面比较连续分配和离散分配方式。<br><strong>连续分配</strong>程序空间本来就是连续的，用连续的内存装入连续的程序，减少管理工作的难度<br><strong>离散分配</strong>方式需要额外的硬件支持，且实现的算法相对比较复杂<br>没有外零头 不受连续空间限制，每块都能分出去，仅有小于一个页面的内零头 程序大小一般不是页大小的整数倍。</p>
</li>
</ol>
<h2 id="P189"><a href="#P189" class="headerlink" title="P189"></a>P189</h2><ol start="2">
<li><p>什么是程序运行时的时间局限性和空间局限性?</p>
<ul>
<li>时间局限性 被访问过的数据可能再次被访问</li>
<li>空间局限性 被访问过的存储单元其附近也可能被访问</li>
</ul>
</li>
<li><p>实现虚拟存储器需要哪些硬件支持?<br> 请求分页/段的页/段表机制<br> 缺页/段中断机构<br> 地址变换机构</p>
</li>
<li><p>实现虚拟存储器需要哪些关键技术？<br> 请求调页/段功能、页面置换功能</p>
</li>
<li><p>请详细说明请求分页系统的地址变换过程。</p>
<ol>
<li>取逻辑地址分解为页号和页内偏移</li>
<li>根据页号查找页表,获得该页的描述信总</li>
<li>若该页中断位为1，产生缺页中断</li>
<li>更新该页的描述信息</li>
<li>根据页块号和页内偏移，计算物理地址。</li>
</ol>
</li>
<li><p>试说明在请求分页系统中页面的调入过程。<br>当程序要访问的页面未在内存时，便向CPU发出缺页中断，中断处理程序通过查找页表，得到该页在外存的物理块后，如果此时内存能容纳新页，则启动磁盘将所缺之页调入内存，然后修改页表。<br>如果内存已满，则须先按照置换算法从内存中选出一页准备换出，然后再把所缺的页调入内存，并修改页表中的相应表项，并将此页表项写入快表中。<br>在缺页调入内存后，修改后的页表形成所要访问数据的物理地址，再去访问内存数据。<br>整个页面的调入过程对用户是透明的。</p>
</li>
<li><p>在请求分页系统中，常采用哪几种页面置换算法?<br>最佳置换算法OPT<br>先进先出置换算法FIFO<br>最近最久未使用置换算法LRU<br>最少使用置换算法LFU<br>简单的Clock置换算法<br>改进型Clock置换算法</p>
</li>
</ol>
<ol start="18">
<li>在请求分页系统中，产生“抖动”的原因是什么?<ul>
<li>进程分配的物理块太少</li>
<li>置换算法选择不当</li>
<li>全局置换使抖动传播</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/26/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE/fabric%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91%E6%AD%A3%E5%BC%8F%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/26/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE/fabric%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91%E6%AD%A3%E5%BC%8F%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">fabric区块链开发正式记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-26 18:58:57" itemprop="dateCreated datePublished" datetime="2022-03-26T18:58:57+08:00">2022-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-30 16:42:03" itemprop="dateModified" datetime="2022-03-30T16:42:03+08:00">2022-03-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/26/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B7%E4%BD%93%E6%B7%B1%E5%85%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/26/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B7%E4%BD%93%E6%B7%B1%E5%85%A5/" class="post-title-link" itemprop="url">区块链具体深入</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-26 13:05:33" itemprop="dateCreated datePublished" datetime="2022-03-26T13:05:33+08:00">2022-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-30 14:21:43" itemprop="dateModified" datetime="2022-03-30T14:21:43+08:00">2022-03-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="链码事件"><a href="#链码事件" class="headerlink" title="链码事件"></a>链码事件</h2><p>Hyperledger Fabric采用异步通信的模式来进行开发，可以在链码里面定义某些事件，然后通过应用程序去监听，当某个事件被触发的时候，就可以执行预先设定好的回调函数了<br>具体体现在cc的invoke</p>
<h2 id="账本与通道"><a href="#账本与通道" class="headerlink" title="账本与通道"></a>账本与通道</h2><p>账本是通过通道（channel）进行隔离的，这种隔离不仅体现在逻辑上，在物理上也是进行分隔的。</p>
<h2 id="智能合约与交易的关系"><a href="#智能合约与交易的关系" class="headerlink" title="智能合约与交易的关系"></a>智能合约与交易的关系</h2><p>智能合约相当于函数的声明与定义，而交易相当于函数的一次调用</p>
<h2 id="身份"><a href="#身份" class="headerlink" title="身份"></a>身份</h2><p>Hyperledger Fabric利用的PKI体系（公钥架构，在网络中提供安全通信的技术，让HTTP变成HTTPS）和CA系统，提供了包括注册登录，身份认证等待功能。<strong>这里的注册登录是指能与区块链底层进行交互的一个身份的管理</strong>，一个应用程序可能只需要一个身份就可以完成所有与区块链底层交互的功能。<br>注册登记，客户端向CA机构表名自己的身份，然后从CA机构获取相应的证书，用于后续的操作，比如交易提案，交易提交等等（CA在区块链外，可以是一个第三方CA）</p>
<h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><p>区块链这样的典型的分布式系统中，他保证每一个节点都有一份完整的数据，都可以对外提供完整的服务。因此区块链是弱化了一致性C，正因为区块链弱化了一致性，所以需要更好的共识算法保证一致性。</p>
<h2 id="PEER"><a href="#PEER" class="headerlink" title="PEER"></a>PEER</h2><p>Peer节点是一个统称，包含了Leader（主节点），Anchor（锚节点），Endorser（背书节点）以及Committer（记账节点）</p>
<p>Leader主节点连接到Orderer节点并与之通信并通知给组织内部的其他节点<br>Anchor锚节点是在通道上可以被所有其他Peer节点发现的节点</p>
<h2 id="Orderer"><a href="#Orderer" class="headerlink" title="Orderer"></a>Orderer</h2><p>从全网的客户端节点接收交易，然后将交易按照一定的规则进行排序<br>将排序好的交易按照固定的时间间隔打包成区块，然后分发给其他组织的主节点</p>
<p>有两种常用类型的排序方法：</p>
<ul>
<li>solo，整个网络中只有一个排序节点，它收到的交易的顺序就是整个网络中的排好序的交易顺序。整个模式仅仅适用于开发和测试时用，如果Orderer节点挂掉了，整个网络就是瘫痪的</li>
<li>kafka，将整个网络中的交易排序过程转交给了kafka集群，每一个Orderer节点都是kafka集群的生产者和消费者，生产者将从客户端节点接收到的交易转发给kafka集群，同时消费者中kafka集群里面获取交易，这样或得到的交易就已经是排好序的了</li>
</ul>
<p>————————————————<br>转自CSDN博主「TLpigff」的文章，遵循CC 4.0 BY-SA版权协议<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lvyibin890/category_10008527.html">https://blog.csdn.net/lvyibin890/category_10008527.html</a></p>

      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/23/%E7%BD%91%E7%BB%9C/tests/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/23/%E7%BD%91%E7%BB%9C/tests/" class="post-title-link" itemprop="url">计网练习题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-23 15:28:57" itemprop="dateCreated datePublished" datetime="2022-03-23T15:28:57+08:00">2022-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-26 16:05:11" itemprop="dateModified" datetime="2022-05-26T16:05:11+08:00">2022-05-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-8周"><a href="#1-8周" class="headerlink" title="1-8周"></a>1-8周</h1><h2 id="Checksum校验和"><a href="#Checksum校验和" class="headerlink" title="Checksum校验和"></a>Checksum校验和</h2><p>请分别按 16 bit一组和 8 bit 一组计算计算以下数据 Checksum，分块儿后不足的请在尾部用0补足。<br>0xC0A800010ACBD1223<br>答案：3368</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>第一步：补零<br>第二部：4位累加，溢出做0001加<br>第三步：二进制取反</p>
<h1 id="7-16周"><a href="#7-16周" class="headerlink" title="7-16周"></a>7-16周</h1><h2 id="请计算以下数据的校验和（16-bit一组）："><a href="#请计算以下数据的校验和（16-bit一组）：" class="headerlink" title="请计算以下数据的校验和（16 bit一组）："></a>请计算以下数据的校验和（16 bit一组）：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  0XC0A8,</span><br><span class="line">  0X0001,</span><br><span class="line">  0xACBD,</span><br><span class="line">  0X1223</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案：8075</p>
<h2 id="TCP定时器所采用的指数加权移动平均算法中，指数的提法从何而来？"><a href="#TCP定时器所采用的指数加权移动平均算法中，指数的提法从何而来？" class="headerlink" title="TCP定时器所采用的指数加权移动平均算法中，指数的提法从何而来？"></a>TCP定时器所采用的指数加权移动平均算法中，指数的提法从何而来？</h2><h2 id="参见下图，假设网络初始构建，若PC0-ping-PC1，请简述它们之间的完整通信过程。"><a href="#参见下图，假设网络初始构建，若PC0-ping-PC1，请简述它们之间的完整通信过程。" class="headerlink" title="参见下图，假设网络初始构建，若PC0 ping PC1，请简述它们之间的完整通信过程。"></a>参见下图，假设网络初始构建，若PC0 ping PC1，请简述它们之间的完整通信过程。</h2><h1 id="win64-or-linux64内存对齐"><a href="#win64-or-linux64内存对齐" class="headerlink" title="win64 or linux64内存对齐"></a>win64 or linux64内存对齐</h1><p>#include&lt;stdio.h&gt;<br>int main(){<br>    struct {char a;int b;char c;}X2;//1+3+4+1+3=12<br>    struct {int a;char b;}X3;//4+1+3=8<br>    struct {char a;short b;}X4;//1+1+2=4<br>    struct {char a;short b;char c;}X5;//1+1+2+1+1=6<br>    struct {char a;long b;}X6;//1+3+4=8 or 1+7+8=16<br>    struct {char a;long b;char c;}X7;//1+3+4+1+3=12 or 1+7+8+1+7=24<br>    struct {char a;long long b;}X8;//1+7+8=16<br>    struct {char a;long long b;char c;}X9;//1+7+8+1+7=24<br>    struct {char a;int b;short c;}X10;//1+3+4+2+2=12<br>    struct {char a;short b;char c;int d;}X11;//1+1+2+1+3+4=12<br>    printf(“%ld\n”,sizeof(X2));<br>    printf(“%ld\n”,sizeof(X3));<br>    printf(“%ld\n”,sizeof(X4));<br>    printf(“%ld\n”,sizeof(X5));<br>    printf(“%ld\n”,sizeof(X6));<br>    printf(“%ld\n”,sizeof(X7));<br>    printf(“%ld\n”,sizeof(X8));<br>    printf(“%ld\n”,sizeof(X9));<br>    printf(“%ld\n”,sizeof(X10));<br>    printf(“%ld\n”,sizeof(X11));</p>
<p>}</p>
<pre><code>


</code></pre>

      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dyinjin"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">dyinjin</p>
  <div class="site-description" itemprop="description">摸鱼窝</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fas fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dyinjin</span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">本博客全站共188.2k字呐~</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,120,50' opacity='0.3' zIndex='-2' count='100' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
<div class="moon-menu">
  <div class="moon-menu-items">
    
    <div id="moon-menu-item-back2bottom" class="moon-menu-item">
      <i class='fas fa-chevron-down'></i>    </div>
    
    <div id="moon-menu-item-back2top" class="moon-menu-item">
      <i class='fas fa-chevron-up'></i>    </div>
    
  </div>
  <div class="moon-menu-button">
    <svg class="moon-menu-bg">
      <circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle>
      <circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle>
    </svg>
    <div class="moon-menu-content">
      <div class="moon-menu-icon"><i class='fas fa-ellipsis-v'></i></div>
      <div class="moon-menu-text"></div>
    </div>
  </div>
</div><script src="/js/injector.js"></script>
</body>
</html>
