<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":250,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":false,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="摸鱼窝">
<meta property="og:type" content="website">
<meta property="og:title" content="岛屿尽">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="岛屿尽">
<meta property="og:description" content="摸鱼窝">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="dyinjin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<link rel="stylesheet" type="text/css" href="/css/injector/main.css" /><link rel="preload" as="style" href="/css/injector/light.css" /><link rel="preload" as="style" href="/css/injector/dark.css" />
  <title>岛屿尽</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">岛屿尽</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">dyingjin</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-cube fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-bookmark fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-cubes fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-server fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/26/MC/debugfile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/26/MC/debugfile/" class="post-title-link" itemprop="url">minecraft making log</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-26 17:02:45" itemprop="dateCreated datePublished" datetime="2021-09-26T17:02:45+08:00">2021-09-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-22 17:58:26" itemprop="dateModified" datetime="2022-04-22T17:58:26+08:00">2022-04-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MC/" itemprop="url" rel="index"><span itemprop="name">MC</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/2021/09/26/MC/debugfile/ti.png" alt="2021-12-04_16"></p>
<h1 id="模组部分"><a href="#模组部分" class="headerlink" title="模组部分"></a>模组部分</h1><p>按时间顺序【由近及远】</p>
<h2 id="【结构】大型结构Shrines-1-16-5-2-0-0-Beta8"><a href="#【结构】大型结构Shrines-1-16-5-2-0-0-Beta8" class="headerlink" title="【结构】大型结构Shrines-1.16.5-2.0.0-Beta8"></a>【结构】大型结构Shrines-1.16.5-2.0.0-Beta8</h2><p>加载闪退(毕竟BETA)<br>日志fatal报错：</p>
<figure class="highlight plaintext"><figcaption><span>apply failed mixins.shrines.json:MixinMinecraftServer -> net.minecraft.server.MinecraftServer:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">org.spongepowered.asm.mixin.injection.throwables.InvalidInjectionException Critical injection failure: @Inject annotation on onConfigurePackRepository could not find any targets matching &#x27;configurePackRepository&#x27; in net.minecraft.server.MinecraftServer. </span><br><span class="line">No refMap loaded. [PREINJECT Applicator Phase -&gt; mixins.shrines.json:MixinMinecraftServer -&gt; Prepare Injections -&gt;  -&gt; </span><br><span class="line">handler$bbi000$onConfigurePackRepository(.../mixin/injection/callback/CallbackInfoReturnable;)V -&gt; Parse]</span><br><span class="line">org.spongepowered.asm.mixin.injection.throwables.InvalidInjectionException: Critical injection failure: @Inject annotation on onConfigurePackRepository could not find any targets matching </span><br><span class="line">&#x27;configurePackRepository&#x27; in net.minecraft.server.MinecraftServer. No refMap loaded. [PREINJECT Applicator Phase -&gt; </span><br><span class="line">mixins.shrines.json:MixinMinecraftServer -&gt; Prepare Injections -&gt;  -&gt; handler$bbi000$onConfigurePackRepository(.../mixin/injection/callback/CallbackInfoReturnable;)V -&gt; Parse]</span><br></pre></td></tr></table></figure>
<p>有：<br>InvalidInjectionException严重注入失败：@onConfigurePackRepository上的injection批注在网络中找不到任何与“configurePackRepository”匹配的目标。我的世界。服务器MinecraftServer。未加载参考地图。<br>更换为BETA7版本正常</p>
<h2 id="某生物附魔模组更新后"><a href="#某生物附魔模组更新后" class="headerlink" title="某生物附魔模组更新后"></a>某生物附魔模组更新后</h2><p>更新后会生物附魔详情会以名称形式显示（很长很难看）<br>找出来了，是【生物】【前置24】地下城怪物dungeons_mobs-1.16.5-2.0.1-beta（测试版？）<br>暂时配置中关闭附魔功能（另有模组——稀有精英怪）</p>
<h2 id="变异骷髅闪退"><a href="#变异骷髅闪退" class="headerlink" title="变异骷髅闪退"></a>变异骷髅闪退</h2><ul>
<li>【生物】变异生物MutantBeasts-1.16.4-1.1.3.jar</li>
<li>生成的变异骷髅似乎在一个跳跃动作后便会使整合包闪退</li>
<li>其它生物均无此现象</li>
<li>可能与实体优化相关模组有关#待解决</li>
<li>已排除：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">【优化】实体剔除EntityCulling-1.16.5-2.1.6</span><br><span class="line">【优化】生物加载performant-1.16.2-5-3.77m</span><br><span class="line">【优化】渲染优化（针对多人） out_of_sight-1.16.4-1.0.1</span><br><span class="line">……</span><br><span class="line">所有【优化】</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="BYG草甸方块材质？"><a href="#BYG草甸方块材质？" class="headerlink" title="BYG草甸方块材质？"></a>BYG草甸方块材质？</h2><ul>
<li>现象为草甸方块放在任意草方块、泥土方块上直接变透明</li>
<li>应该是模组冲突导致，与草坪优化相关</li>
<li>【装饰】【前置30】更好的树叶BetterFoliage-2.7.1-Forge-1.16.5.jar由此模组导致此模组识别各个模组的草方块、树叶方块等再基于原本材质进行修饰(如跟丰富的树叶)，可能草甸方块不是简单的草方块换皮，所以有BUG(可通过设置改变，其提供的设置十分详细和丰富)</li>
</ul>
<h2 id="【杂项】快速树叶腐烂FastLeafDecay-v25-jar导致（这个BUG价值三天）"><a href="#【杂项】快速树叶腐烂FastLeafDecay-v25-jar导致（这个BUG价值三天）" class="headerlink" title="【杂项】快速树叶腐烂FastLeafDecay-v25.jar导致（这个BUG价值三天）"></a>【杂项】快速树叶腐烂FastLeafDecay-v25.jar导致（这个BUG价值三天）</h2><ul>
<li>整合包加入了非常的群系性结构性影响生成世界的模组，</li>
<li>在创造新的世界时约有30%的可能卡死</li>
<li>(表现为并非未响应，但加载百分比长时间不变化，任务管理器占用内存变化幅度非常小，如果打开日志的话可以观察到已经在卡死前报错fatal了，只是并没有彻底的阶数游戏进程而且也不再继续)</li>
<li>最后分析可能与树叶检测有关：在生成世界时部分模组已经生成树叶，部分还没有生成，而本模组在生成时就已经开始执行检测？造成冲突？！</li>
</ul>
<h2 id="区块预生成Chunk-Pregenerator"><a href="#区块预生成Chunk-Pregenerator" class="headerlink" title="区块预生成Chunk-Pregenerator"></a>区块预生成Chunk-Pregenerator</h2><ul>
<li>在选择世界生成类型的下方会有一个按钮</li>
<li>在其中点击start便可以预生成区块</li>
</ul>
<h2 id="优化性模组"><a href="#优化性模组" class="headerlink" title="优化性模组"></a>优化性模组</h2><p>在大型整合包中年尤为重要</p>
<h3 id="Out-Of-Sight-机翻"><a href="#Out-Of-Sight-机翻" class="headerlink" title="Out Of Sight(机翻)"></a>Out Of Sight(机翻)</h3><p>厌倦了你的邻居巨大的模板工厂基地 （你甚至看不到大部分时间） 降低你的框架？这个模组是你需要的！<br>如果磁贴实体距离远超过 24 个街区，则”视线外”只需停止它们的渲染，并且您可以在配置文件中将此范围配置到最适合您的任何范围。<br>它还支持实体，一些模组用于渲染 fps 重功能。<br>在一个完美的世界中，每个模组都经过优化和良好的测试，但与通常包含超过 100 模组的模组包，这个世界并不存在。所以我这样做， 使多人模组更可玩！<br><strong>优点：</strong></p>
<ul>
<li>在繁忙的复杂基地附近， 包含大量模板实体和实体 （如机器、灯光等） 的框架速度非常好</li>
<li>客户端仅模组</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>当你走近时， 更明显的弹出的实体和瓷砖实体</li>
</ul>
<h3 id="ferritecore-机翻"><a href="#ferritecore-机翻" class="headerlink" title="ferritecore(机翻)"></a>ferritecore(机翻)</h3><p>此模组以几种不同的方式减少了 Minecraft 的内存使用。此处提供了有关更改的高级别技术描述。<br>保存的内存量将取决于模组，在 1.16.4 Direwolf20 包的 1.2.0 版本中，它大约将标题屏幕上的内存使用量（GC 之后）从 3.1 GB 减少到 1.1-1.2 GB。</p>
<h3 id="smoothboot-机翻"><a href="#smoothboot-机翻" class="headerlink" title="smoothboot(机翻)"></a>smoothboot(机翻)</h3><p>平滑启动 - 优化 Minecraft 装载性能，使低端系统更平滑，高端系统规模更好。<br>如果您的 PC 具有较旧或低端 CPU（前 CPU 具有 8 个或更少的线程），您可能已经注意到 Minecraft 在加载到标题屏幕时占用了 CPU 的 100%，导致光标口吃，使多任务处理变得非常困难。平滑启动可以完全解决这个问题，加载应该更顺畅，而且可能更快。</p>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul>
<li>  更改用于加载的线程数量</li>
<li>  更改 Minecraft 使用的线程的优先级</li>
</ul>
<h4 id="模组的工作原理"><a href="#模组的工作原理" class="headerlink" title="模组的工作原理"></a>模组的工作原理</h4><p>Minecraft 使用执行器执行多重任务。问题是，在加载过程中运行的任务在 CPU 上相当繁重，因此它会导致 100% CPU 使用。而且，有些任务不一定受益于多阅读。平滑引导通过更改执行者的参数（包括其使用的线程数和每个线程的优先级）来修复这些问题。<br>欲了解更多信息，请阅读<a target="_blank" rel="noopener" href="https://github.com/UltimateBoomer/mc-smoothboot/wiki">平滑启动维基</a></p>
<h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><p>模组应与所有模组兼容，包括 Optifine。但是，值得注意的是，模组使用混合素覆盖用于加载游戏的某些方法。</p>
<h3 id="Entity-Culling-机翻"><a href="#Entity-Culling-机翻" class="headerlink" title="Entity Culling(机翻)"></a>Entity Culling(机翻)</h3><p><strong>实体剔除</strong>是一个相对较小的客户端性能核心模组，旨在跳过隐藏（磁贴）实体的渲染。<br>在香草中，它只呈现玩家视野中的所有（瓷砖）实体。这意味着可能有成百上千的 （瓷砖） 实体吃你的 fps， 而你甚至看不到他们， 因为他们隐藏在墙后。<br><strong>剔除隐藏实体</strong><br>此模组光线跟踪另一个线程，以检查（瓷砖实体）是否可见。因为这种方法不是100%准确的每个（瓷砖）实体，不被认为是可见的开放gl遮挡测试将作出。<br>当许多（瓷砖）实体不可见时，这可能导致大量 fps 改进。同时，当大多数（瓷砖）实体可见时，也只有最低限度的开销。<br><strong>阴影的配置选项（当使用视网膜和带阴影的阴影的阴影时）</strong><br>此模组还添加了一些配置选项，以在安装视光素和使用带阴影的阴影的阴影器时调整阴影的渲染。<br>某些阴影器可能会提供配置选项来调整阴影渲染距离。但问题是，所有被认为太远的实体、瓷砖实体和块的阴影仍将由 cpu 处理，然后由遮光板扔掉。<br>此模组允许用户指定实体、瓷砖实体和地形的最大阴影距离。<br>或者，它还允许完全跳过实体、瓷砖实体或地形阴影的渲染。</p>
<h3 id="performant-机翻"><a href="#performant-机翻" class="headerlink" title="performant(机翻)"></a>performant(机翻)</h3><p><strong>最显著的功能：</strong><br>所有功能均可配置，可在配置中调整/启用/禁用。<br><strong>减少 AI 开销</strong><br>AI 不再花费一半的时间来决定他们应该执行哪些任务<br><strong>实体碰撞和路径的多重读数</strong><br>实体更新、碰撞路径和移动的昂贵部分更快，并且发生多重阅读。<br><strong>AI/实体、磁体和事件的负载平衡</strong><br>负载平衡是一种更具侵入性的机械师，以限制滞后罪犯，它可能会影响其他模组的功能，但只有在您的游戏已经落后时才会变得活跃起来。它通过定期检查服务器的 tps 以及它是否低于配置负载平衡中的阈值而工作。然后，它开始配置 AI/实体、Tileent 和事件，以确定谁导致最多的滞后，并限制其更新与这些源导致的滞后。这主要是一个功能，以保持你的游戏可玩，而一些特定的滞后来源通常会把它带到它的膝盖。<br><strong>FPS</strong><br>用于渲染实体的 FPS 得到改进，但仅对客户端的改进很少。<br><strong>登录/播放超时</strong><br>可配置的登录超时，用于在游戏期间登录和断开连接，帮助使用较慢 PC 和连接的玩家。<br><strong>食谱缓存</strong><br>食谱查找得到快得多，帮助所有这些自动制作的模组在那里造成滞后时，通过大量的食谱。<br><strong>快速世界更新</strong><br>随机块和块滴答声整体速度更快，性能成本更低。<br><strong>可配置的公用设施</strong><br>禁用实体生成特定类型的实体。<br>显示非正常块负载的调试设置。<br>用于显示的调试设置</p>
<h2 id="【结构】【前置40】valhelsia-structures-1-16-5-0-1-6-jar"><a href="#【结构】【前置40】valhelsia-structures-1-16-5-0-1-6-jar" class="headerlink" title="【结构】【前置40】valhelsia_structures-1.16.5-0.1.6.jar"></a>【结构】【前置40】valhelsia_structures-1.16.5-0.1.6.jar</h2><ul>
<li>本身是别人整合包用的</li>
<li>但是在生成结构的时候，其特殊的代码(貌似调用结构使用方块时会用其特别标志替代，有时会不切换回方块本身)会使草方块(本应是)变为透视方块</li>
<li>貌似是JAVA版本要求比较严格-其建议JAVA8</li>
</ul>
<h2 id="【前置10】【辅助】jei-1-16-5-7-7-1-110-jar-old"><a href="#【前置10】【辅助】jei-1-16-5-7-7-1-110-jar-old" class="headerlink" title="【前置10】【辅助】jei-1.16.5-7.7.1.110.jar.old"></a>【前置10】【辅助】jei-1.16.5-7.7.1.110.jar.old</h2><ul>
<li>jei这之后的几个版本不能使用标签搜索。。</li>
<li>jei-1.16.5-7.7.1.136此版本可以了</li>
</ul>
<h2 id="【生物】-BETA-dannys-expansion1-16-5-1-0-9-1-jar"><a href="#【生物】-BETA-dannys-expansion1-16-5-1-0-9-1-jar" class="headerlink" title="【生物】[BETA]dannys_expansion1.16.5-1.0.9.1.jar"></a>【生物】[BETA]dannys_expansion1.16.5-1.0.9.1.jar</h2><ul>
<li>非常优质的生物模组</li>
<li>待更新或手动调整（生成和掉落物还有问题）</li>
</ul>
<h2 id="风铃chime模组"><a href="#风铃chime模组" class="headerlink" title="风铃chime模组"></a>风铃chime模组</h2><ul>
<li>在1.16.5中缺少与模组衔接的铜风铃合成表与紫水晶风铃合成表</li>
<li>计划通过kubejs手动添加（已添加）</li>
</ul>
<h2 id="【前置13】【生物】【前置12】mysticalworld-1-16-5-0-3-5-24"><a href="#【前置13】【生物】【前置12】mysticalworld-1-16-5-0-3-5-24" class="headerlink" title="【前置13】【生物】【前置12】mysticalworld-1.16.5-0.3.5.24"></a>【前置13】【生物】【前置12】mysticalworld-1.16.5-0.3.5.24</h2><ul>
<li>此版本银与水银物品贴图有部分混淆</li>
<li>以简单修复</li>
</ul>
<h2 id="【辅助】工具栏inventorio-1-16-forge-1-6-1-jar"><a href="#【辅助】工具栏inventorio-1-16-forge-1-6-1-jar" class="headerlink" title="【辅助】工具栏inventorio-1.16-forge-1.6.1.jar"></a>【辅助】工具栏inventorio-1.16-forge-1.6.1.jar</h2><ul>
<li>此模组提供的额外工具栏位以及自动切换系统较方便</li>
<li>但存在三叉戟等蓄力投掷物无法右击蓄力释放的问题</li>
<li>暂无解决方法</li>
</ul>
<h2 id="Forgotten-Treasures-已弃用"><a href="#Forgotten-Treasures-已弃用" class="headerlink" title="Forgotten+Treasures(已弃用)"></a>Forgotten+Treasures(已弃用)</h2><p>以下问题已查明，系此模组<code>Forgotten+Treasures</code>导致<br><img src="https://raw.githubusercontent.com/dyinjin/xiaoshujiang/main/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1635869592303.png" alt="enter description here"></p>
<ul>
<li>“耕地消失术”表现为自然村庄耕地或玩家耕地在玩家身边几秒内变为普通泥土</li>
<li>钟乳石问题<del>在更新为<code>【前置4】cavebiomeapi-1.16.5-1.4.1.jar 【群系】【前置4】cavesandcliffs-1.16.5-7.0.jar</code>后，钟乳石刷新异常：</del>bs表现为如沙子一样的下落特性，且肉眼可见的作为实体间断刷新</li>
</ul>
<h2 id="Epic-Fight-Mod"><a href="#Epic-Fight-Mod" class="headerlink" title="Epic Fight Mod"></a>Epic Fight Mod</h2><ul>
<li>本模组由于为僵尸村民也修改了动作，使用任何其它模组中的僵尸村民都将出现贴图错误。</li>
<li>本模组对生物也进行了修改，模组生物不会受到本模组的控制。</li>
<li>本模组对装备显示兼容(如旅行者背包)正在更新</li>
</ul>
<h2 id="更好的第一人称视角与地下城武器"><a href="#更好的第一人称视角与地下城武器" class="headerlink" title="更好的第一人称视角与地下城武器"></a>更好的第一人称视角与地下城武器</h2><ul>
<li>无法正常使用双持武器与弩</li>
<li>地下城武器同样与村民守卫模组不能很好兼容(村民守卫无法使用模组中的弩)</li>
</ul>
<h2 id="“弱响应？”"><a href="#“弱响应？”" class="headerlink" title="“弱响应？”"></a>“弱响应？”</h2><ul>
<li>测试时，在进入末地或末地加载千格左右时出现，表现为区块不在加载(甚至直接可以下到原本的地形中)，实体不再响应(生物、掉落物、箱子)，而方块的放置不受影响</li>
<li><DEL>查看日志，在多次排除法h后确定其报错为<code>GL ERROR 65539: invalid key -1</code></DEL></li>
<li>简单更换JAVA版本无法解决</li>
<li><del>经过去除部分模组，确认为模组原因，确定系byg1.3.5导致</del></li>
</ul>
<h2 id="Druidcraft"><a href="#Druidcraft" class="headerlink" title="Druidcraft"></a>Druidcraft</h2><ul>
<li>其0.4.53出现接骨木树花朵材质丢失问题</li>
<li>作者已在0.4.54修复，很快啊(这种bug还要我来de-?)</li>
</ul>
<h2 id="BYG与BOP"><a href="#BYG与BOP" class="headerlink" title="BYG与BOP"></a>BYG与BOP</h2><ul>
<li>两大高版本群系模组</li>
<li>其实由于BOP生成是特殊生成模式，所以冲突在所难免</li>
<li>又有”【优化】生物群系修复(争对新添加群系)biomeidfixer-1.16.5-1.0.1.s4”与”【优化】【前置15】byg群系生成修复chocolate-1.3.0-1.16.4”能够对此问题进行修复</li>
<li>但我混合正常使用只能在两百加模组的全部整合中成功，推测另有模组旁敲侧击的解决了问题</li>
<li>使用单独以上两个修复模组不能使BYG与BOP在BOP群系下正常使用</li>
</ul>
<h2 id="【群系】【前置4】CavesAndCliffsBackport-1-16-5-6-3-jar"><a href="#【群系】【前置4】CavesAndCliffsBackport-1-16-5-6-3-jar" class="headerlink" title="【群系】【前置4】CavesAndCliffsBackport-1.16.5-6.3.jar"></a>【群系】【前置4】CavesAndCliffsBackport-1.16.5-6.3.jar</h2><ul>
<li>目前此模组及其前置共添加了三种地下群系（cavesandcliffs:lush_caves/cavebiomeapi:caves/cavesandcliffs:dripstone_caves）鉴于普通模组没有特别涉及地下生成设置会致使以上群系生物过于单一，故特别添加生成设置</li>
<li>此模组【前置4】系”【前置4】cavebiomeapi-1.16.5-1.3.7.jar”存在一定的特殊性（鉴于在1.17以下还原三维群系此前置模组特加入了三维群系），具观察加入三维群系方式过于暴力（指定一定深度以下为洞穴群系），可能兼容性较差</li>
<li>此模组的创建世界卡死为间歇性，有待进一步确定</li>
<li>关于此模组受特定世界类型影响导致的：地下全是繁茂洞穴、滴水洞穴的问题，或地下完全不存在此模组添加的以上两种群系的问题。目前推断为旧版本问题</li>
</ul>
<h2 id="【音效】动态环绕4-26DynamicSurroundings-1-16-4-4-0-4-2-jar"><a href="#【音效】动态环绕4-26DynamicSurroundings-1-16-4-4-0-4-2-jar" class="headerlink" title="【音效】动态环绕4.26DynamicSurroundings-1.16.4-4.0.4.2.jar"></a>【音效】动态环绕4.26DynamicSurroundings-1.16.4-4.0.4.2.jar</h2><ul>
<li>此模组添加了真实的音效系统，较好的解决了隔墙听声问题</li>
<li>此模组目前以确认可能导致已创建世界无法加载进入问题，日志报错”SoundControl Sound Processor is lagging”，暂停使用后即可成功进入</li>
<li>以上问题目前推测为角色生处方块内部物理声效无法计算所导致（例如处在观察者模式在地下退出世界后重新加入时）</li>
</ul>
<h2 id="【优化】储物抽屉优化drawerfps-2-1-jar"><a href="#【优化】储物抽屉优化drawerfps-2-1-jar" class="headerlink" title="【优化】储物抽屉优化drawerfps-2.1.jar"></a>【优化】储物抽屉优化drawerfps-2.1.jar</h2><ul>
<li>此模组系解决”【杂项】储物抽屉StorageDrawers-1.16.3-8.2.2”所导致的间歇性掉帧问题，效果良好<br><del>* 但此观察此模组系通过在一定范围外不加载“抽屉”单元贴图来解决问题，这常常间歇性导致正常地形方块成片贴图不加载（同种类或不同种类，多数情况下为树干贴图消失、岩壁贴图消失等）同时系统直接报错”OpenGL Error 1281: Invalid Value”（此报错可能原因多样，经多次尝试发现系此模组导致）</del></li>
<li>见下OpenGL</li>
</ul>
<h2 id="Error-adding-element-Base-value-out-of-range-256-10-128"><a href="#Error-adding-element-Base-value-out-of-range-256-10-128" class="headerlink" title="Error adding element: Base value out of range: 256 [-10-128]"></a>Error adding element: Base value out of range: 256 [-10-128]</h2><p>Adding onto the list: betterdefaultbiomes gives warnings whenever this mod (2.2.0) is introduced, the same lag spike as faeldray mentioned happens every 5mins</p>
<ul>
<li>【群系拓展】更好的群系BetterDefaultBiomes-1.16.4+-Alpha 2.6.1 导致？不是</li>
<li>好像无伤大雅？</li>
</ul>
<h2 id="varint-too-big"><a href="#varint-too-big" class="headerlink" title="varint too big"></a>varint too big</h2><p>在连接自己的模组服的时候发生<br><img src="/2021/09/26/MC/debugfile/1647423239616.png" alt="enter description here"><br>好像是Terrain模组导致<code>【风味拓展】【自然】【装饰】装饰性环境植物terraincognita-1.16.3-1.7.1.1.jar</code></p>
<h1 id="生成调整-待记录"><a href="#生成调整-待记录" class="headerlink" title="生成调整(待记录)"></a>生成调整(待记录)</h1><h2 id="矿石"><a href="#矿石" class="headerlink" title="矿石"></a>矿石</h2><ul>
<li>生成铜的模组有三个，太多了，关闭两个（一个设为1）</li>
<li>wyrmroost中生成的铂矿太多了，且不可调控，通过强制修改掉落物，使其掉落NNOW中提供的兼容铂粒(好蠢后面发现拿kube可以直接改)</li>
<li>锡也有两个模组在生成，降低了比例</li>
<li>铅也调整了在mysticalworld中配置的生成高度等</li>
</ul>
<h2 id="生物"><a href="#生物" class="headerlink" title="生物"></a>生物</h2><p>其实之前通过“【辅助】生物生成管理SpawnBalanceUtility-1.36.0.11.jar”改过很多，当时没有做记录，现在可能也忘了<br>原版生物<br>各种水生物<br>三洞穴群系<br>BOSS(特指有屏幕血条的生物)</p>
<p>以下正式记录</p>
<h3 id="减少"><a href="#减少" class="headerlink" title="减少"></a>减少</h3><ul>
<li>‘minecraft_earth_mod:系列<br>虽然只有10的weight但有各种牛<br>故将其中的牛下调为5<br>(除 minecraft_earth_mod:wooly_cow在寒带将15下调为10)<br>其中又给viler女巫下调为5，并减少群系</li>
</ul>
<h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><ul>
<li>河流、湖泊、沼泽、洞穴的鱼类<br>河流<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">minecraft:river</span><br><span class="line">mysticalbiomes:petrified_river</span><br><span class="line">mysticalbiomes:sprout_river</span><br><span class="line">mysticalbiomes:uncanny_river</span><br><span class="line">minecraft:frozen_river</span><br></pre></td></tr></table></figure>
湖泊<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">betterendforge:megalake（the_end</span><br><span class="line">betterendforge:megalake_grove（the_end</span><br><span class="line">biomesoplenty:coniferous_lakes</span><br><span class="line">biomesoplenty:grove_lakes</span><br><span class="line">byg:fresh_water_lake</span><br><span class="line">byg:frozen_lake</span><br><span class="line">byg:great_lake_isles</span><br><span class="line">byg:great_lakes</span><br><span class="line">byg:polluted_lake</span><br><span class="line">genericeco:cold_lake</span><br><span class="line">genericeco:frozen_lake</span><br><span class="line">genericeco:great_lakes</span><br><span class="line">genericeco:lake</span><br><span class="line">genericeco:lukewarm_lake</span><br><span class="line">genericeco:red_desert_lakes</span><br><span class="line">genericeco:warm_lake</span><br><span class="line">minecraft:desert_lakes</span><br><span class="line">projectvibrantjourneys:crystal_lakes</span><br></pre></td></tr></table></figure>
沼泽<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">byg:cold_swamplands</span><br><span class="line">byg:cypress_swamplands</span><br><span class="line">byg:vibrant_swamplands</span><br><span class="line">byg:mangrove_marshes</span><br><span class="line">byg:marshlands</span><br><span class="line">environmental:marsh</span><br><span class="line">environmental:mushroom_marsh</span><br><span class="line">genericeco:dark_swampland</span><br><span class="line">genericeco:dark_swampland_marshes</span><br><span class="line">genericeco:dense_marsh</span><br><span class="line">genericeco:lush_swamp</span><br><span class="line">genericeco:lush_swamp_marshes</span><br><span class="line">genericeco:marsh</span><br><span class="line">genericeco:swamp_marshes</span><br><span class="line">minecraft:swamp</span><br><span class="line">projectvibrantjourneys:mangrove_marsh</span><br></pre></td></tr></table></figure>
洞穴<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cavebiomeapi:caves</span><br><span class="line">cavesandcliffs:dripstone_caves</span><br><span class="line">cavesandcliffs:lush_caves</span><br><span class="line">darkerdepths:crystal_cave</span><br><span class="line">darkerdepths:glowshroom_caves</span><br></pre></td></tr></table></figure>
byg:dead_sea</li>
</ul>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="Better-Minecraft-FORGE-v34"><a href="#Better-Minecraft-FORGE-v34" class="headerlink" title="Better Minecraft [FORGE] v34"></a>Better Minecraft [FORGE] v34</h2><p>在此版本后，项目组不再使用Global Data- &amp; Resourcepacks (by JTK222)模组</p>
<h2 id="data-get-entity-p-SelectedItem"><a href="#data-get-entity-p-SelectedItem" class="headerlink" title="/data get entity @p SelectedItem"></a><code>/data get entity @p SelectedItem</code></h2><p>查看手持物品详细数据<br>非常有用</p>
<h2 id="OpenGL-Error-1281-Invalid-Value"><a href="#OpenGL-Error-1281-Invalid-Value" class="headerlink" title="OpenGL Error 1281: Invalid Value"></a><code>OpenGL Error 1281: Invalid Value</code></h2><p><del>老问题，不只是“【优化】储物抽屉优化drawerfps-2.1.jar”的原因，这次表现为水体透明<br>好家伙不查不知道，首先看看OpenGL是个啥吧：<br><code>OpenGL（英语：Open Graphics Library，译名：开放图形库或者“开放式图形库”）是用于渲染2D、3D矢量图形的跨语言、跨平台的应用程序编程接口（API）。这个接口由近350个不同的函数调用组成，用来绘制从简单的图形比特到复杂的三维景象。而另一种程序接口系统是仅用于Microsoft Windows上的Direct3D。OpenGL常用于CAD、虚拟现实、科学可视化程序和电子游戏开发。</code><br>总之不只是我的世界高清修复在用<br>那么看了一下日志，发现和一个叫VBO的东西相关，一查：<br><code>顶点缓存对象（VBO）准许顶点数组数据存放在服务端的高性能显卡内存中，且提供高效数据传输。</code><br>又有知乎大佬说和做水效相关，那么找对问题了，但怎么解决。。。</del></p>
<ul>
<li>与JAVA版本有关</li>
<li>尝试关闭Optifine提供的性能设置中的区域渲染</li>
</ul>

      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/" class="post-title-link" itemprop="url">计算机操作系统(4)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-20 14:51:07" itemprop="dateCreated datePublished" datetime="2022-04-20T14:51:07+08:00">2022-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-22 18:00:40" itemprop="dateModified" datetime="2022-04-22T18:00:40+08:00">2022-04-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h1><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><p><img src="/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/1650529219846.png" alt="enter description here"><br>速度从高到低、容量从小到大</p>
<h3 id="存储器管理的目的和功能"><a href="#存储器管理的目的和功能" class="headerlink" title="存储器管理的目的和功能"></a>存储器管理的目的和功能</h3><ul>
<li>主存储器的分配和管理</li>
<li>提高主存储器的利用率</li>
<li>“扩充”主存容量</li>
<li>存储保护</li>
</ul>
<h3 id="存储分配的三种方式"><a href="#存储分配的三种方式" class="headerlink" title="存储分配的三种方式"></a>存储分配的三种方式</h3><ul>
<li>直接指定方式（汇编地址写入）</li>
<li>静态分配方式（程序装入时确定位置）</li>
<li>动态分配方式</li>
</ul>
<h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><p>将用户源程序变为可在内存中执行的程序：</p>
<ul>
<li> 编译 翻译成机器级代码</li>
<li> 链接 使目标模块链接（引用的其它模块）成装入模块的过程</li>
<li> 装入 由装入程序将装入模块装入内存并执行</li>
</ul>
<h3 id="程序的装入"><a href="#程序的装入" class="headerlink" title="程序的装入"></a>程序的装入</h3><ul>
<li>绝对装入方式</li>
<li>可重定位装入方式（静态、动态）</li>
<li>动态运行时装入方式</li>
</ul>
<h3 id="程序的链接"><a href="#程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h3><ul>
<li>静态链接</li>
<li>装入时动态链接</li>
<li>运行时动态链接</li>
</ul>
<h2 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h2><p>程序空间本来就是连续的用连续的内存装入连续的程序，减少管理工作的难度</p>
<ul>
<li><p>单一连续分配方式（一个进程在内存）</p>
<ul>
<li>优点：易于管理</li>
<li>缺点：对要求内存空间少的程序，造成内存浪费；程序全部装入，很少使用的程序部分也占用内存。</li>
</ul>
</li>
<li><p>分区式分配方式（一个进程占据一个分区）</p>
<ul>
<li>固定分区分配<ul>
<li>易于实现，开销小</li>
<li>内碎片造成浪费；分区总数固定，限制了并发执行的程序数目；存储空间的利用率太低</li>
</ul>
</li>
<li>动态分区分配——分区分配算法</li>
</ul>
</li>
</ul>
<ul>
<li>可重定位分区分配 定时把存储空间中的空白区合并为一个大的连续区 之前的可变式分区分配根据其要求量为其划定相应的区域。消除了 “内零头”，但造成“外零头”</li>
</ul>
<h3 id="分区分配算法"><a href="#分区分配算法" class="headerlink" title="分区分配算法"></a>分区分配算法</h3><p><img src="/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/1650532050974.png" alt="enter description here"></p>
<ul>
<li>内零头(Internal Fragment)：分配给用户但用户没有使用的空间 “多分配的空间”</li>
<li>外零头(External Fragment )：没有分配但无法分配的空间，太小而无法分配，“分不出去的空间”</li>
</ul>
<h4 id="最佳适应算法BF"><a href="#最佳适应算法BF" class="headerlink" title="最佳适应算法BF"></a>最佳适应算法BF</h4><p>选择分区时总是寻找其大小最接近作业所要求的存储区域</p>
<ul>
<li>优点：遇到大作业到来时，比较容易得到满足</li>
<li>缺点： 留下许多无法使用的空白区；回收时，把它插入空白区链也颇为费时</li>
</ul>
<h4 id="最坏适应算法WF"><a href="#最坏适应算法WF" class="headerlink" title="最坏适应算法WF"></a>最坏适应算法WF</h4><p>寻找最大的空白区</p>
<ul>
<li>缺点：将大空间分给了小作业后大作业来到无法满足申请</li>
</ul>
<h4 id="首次适应算法FF"><a href="#首次适应算法FF" class="headerlink" title="首次适应算法FF"></a>首次适应算法FF</h4><p>空白区链的始端开始查找，选择第一个足以满足请求的空白块<br>分配后空白区被分成两部分一部分分配给作业；剩下的部分留在原空白区链中</p>
<ul>
<li>优点：简单，查找速度快</li>
<li>缺点：存储空间利用率不高；找到合适空白区的速度降低。</li>
</ul>
<h4 id="循环首次适应算法NF"><a href="#循环首次适应算法NF" class="headerlink" title="循环首次适应算法NF"></a>循环首次适应算法NF</h4><p>（下次适应算法）从上次查找结束的地方开始，找到一个足够大的空白区，就分配</p>
<ul>
<li>优点：存储空间的利用更加均衡</li>
<li>缺点：需要获得相当大的空白区时，很难满足</li>
</ul>
<h4 id="快速适应算法QF"><a href="#快速适应算法QF" class="headerlink" title="快速适应算法QF"></a>快速适应算法QF</h4><p>每一类具有<strong>相同容量</strong>的空闲分区，单独设立一个空闲分区链表<br>在内存中设立一张<strong>索引表</strong>，每一个表项记录空闲分区链表表头的指针<br>分配过程：根据进程的长度，寻找到能容纳它的最小空闲分区链表，并取下第一块进行分配即可</p>
<ul>
<li>优点：查找效率高；满足对大空间的需求，也不会产生内存碎片</li>
<li>缺点：分区归还算法复杂，系统开销较大；以进程为单位，存在一定的浪费</li>
</ul>
<h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h4><p>固定分区分配：并发执行的进程数量受到限制；内部碎片影响内存利用率<br>动态分区分配：算法复杂，回收分区时系统开销大</p>
<p>在伙伴系统中，可用内存块的大小为 2^k (1≤k≤m) </p>
<ul>
<li>2^1表示分配的最小块的尺寸；</li>
<li>2^m表示分配的最大块的尺寸，通常是可供分配的整个内存空间的大小。</li>
</ul>
<p>对空闲区按照大小分类，相同大小的分区链接为一个双向空闲链表；最多可形成 k（0 ≤k≤m ）个链表。</p>
<h2 id="分页存储管理方式"><a href="#分页存储管理方式" class="headerlink" title="分页存储管理方式"></a>分页存储管理方式</h2><h3 id="引入分页"><a href="#引入分页" class="headerlink" title="引入分页"></a>引入分页</h3><ul>
<li>离散分配方式的引入：<br>  连续分配方式会产生内/外零头<br>  为解决零头问题又要进行紧凑等高开销活动 </li>
<li>什么是离散分配：程序在内存中不一定连续存放 </li>
<li>根据离散时的基本单位不同，可分为三种：<br>  分页存储管理<br>  分段存储管理<br>  段页式存储管理</li>
</ul>
<h4 id="分页存储管理基本思想"><a href="#分页存储管理基本思想" class="headerlink" title="分页存储管理基本思想"></a>分页存储管理基本思想</h4><ul>
<li>离散的基础<pre><code>分页(Pages)：将程序地址空间分页
分块(Frames)：将内存空间分块
</code></pre>
</li>
<li>离散分配的体现<ul>
<li>内存一块可以装入程序一页</li>
<li>连续的多个页不一定装入连续的多个块中</li>
<li>注：系统中页块的大小是不变的。</li>
</ul>
</li>
</ul>
<p>离散分配没有外零头，且内零头肯定少于一个页面</p>
<h4 id="分页存储管理的基本方法"><a href="#分页存储管理的基本方法" class="headerlink" title="分页存储管理的基本方法"></a>分页存储管理的基本方法</h4><p>如何建立程序空间与主存空间的映射——页表<br>如何进行地址变换——从程序逻辑地址到内存物理地址</p>
<h4 id="页面和物理块"><a href="#页面和物理块" class="headerlink" title="页面和物理块"></a>页面和物理块</h4><ul>
<li>页面或页(Page)：把每个进程的逻辑地址空间分成一些大小相等的片。</li>
<li>物理块或页框(Page Frame)：内存空间也分成与页相同大小的若干存储块。在为进程分配存储空间时，总是以页框为单位。</li>
</ul>
<p>页面大小由机器的地址结构决定通常在1KB~8KB之间。</p>
<h4 id="实现分页存储管理的数据结构"><a href="#实现分页存储管理的数据结构" class="headerlink" title="实现分页存储管理的数据结构"></a>实现分页存储管理的数据结构</h4><ul>
<li>页表：进程，描述该进程的各页面在内存中对应的物理块号。页表中包括页号、物理块号。</li>
<li>作业表：系统，记录作业的页表情况。</li>
<li>空闲块表：系统，记录主存当前空闲块。</li>
</ul>
<h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><p>使用寄存器：速度快，成本高<br>一般将页表存在内存进程的PCB中，运行时再装入页表寄存器PTR</p>
<p>分页系统中的地址变换过程如下：</p>
<ol>
<li>根据逻辑地址,<strong>计算出页号和页内偏移量</strong>；</li>
<li>从PTR中得到页表首址，然后<strong>检索页表</strong>，查找指定页面对应的<strong>页框号</strong>；</li>
<li>用页框号乘以页面大小获得其对应的<strong>起始地址</strong>，并将其送入物理地址的<strong>高端</strong>。</li>
<li>将<strong>页内偏移量</strong>送入物理地址低端，<strong>形成完整的物理地址</strong>。</li>
</ol>
<h3 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h3><p>快表TLB为了提高地址变换速度，为进程页表设置一个<strong>专用的高速缓冲存储器</strong>其中专门保存<strong>当前进程最近访问过</strong>的一组页表项。<br>根据逻辑地址中的页号，会先查找快表中是否存在对应的页表项。<br>若快表中存在该表项，称为<strong>命中</strong>，取出其中的页框号加上页内偏移量计算出物理地址。<br>若快表中不存在该页表项，称为<strong>命中失败</strong>，则再查找页表，找到逻辑地址中指定页号对应的页框号。<br>同时，更新快表，将该表项插入快表中。</p>
<h4 id="访问内存的有效时间-EAT"><a href="#访问内存的有效时间-EAT" class="headerlink" title="访问内存的有效时间 EAT"></a>访问内存的有效时间 EAT</h4><p>命中率a、查找快表时间b、访问内存时间c<br>有效访问时间EAT=a ✖ （b+c）+ (1- a) ✖ (b+2c)</p>
<h3 id="两级和多级页表"><a href="#两级和多级页表" class="headerlink" title="两级和多级页表"></a>两级和多级页表</h3><p>引入两级页表采用离散分配方式，来解决难以找到一块连续的大内存空间的问题</p>
<p>利用离散分配方法实现的两级页表只是解决了大页表无需大片<strong>连续</strong>存储空间问题，但并未减少<strong>用较少内存去存放大页表</strong>问题，有关此类问题的成功解决方案在虚拟存储器管理中。</p>
<h3 id="反置页表IPT"><a href="#反置页表IPT" class="headerlink" title="反置页表IPT"></a>反置页表IPT</h3><p>为了解决大页表问题占内存多现象，减少内存开销，避免一个进程一个页表。</p>
<p>IPT采用为主存中的每一个物理块建立一个页表项并按照块号排序，该表每个表项包含正在访问该物理块的进程标识、页号及特征位，用来完成主存物理块到访问进程的页号的转换。</p>
<p><strong>即反过来查，原来是进程查物理现在是物理地址记录进程</strong></p>
<h2 id="对换"><a href="#对换" class="headerlink" title="对换"></a>对换</h2><p>对换就是把内存中暂时不用的程序和数据换到外存，或把需要的程序和数据换入内存。<br>分为：</p>
<ul>
<li>整体对换 以进程为单位</li>
<li>页面/分段对换：以页或段为单位</li>
</ul>
<h2 id="分段存储管理方式"><a href="#分段存储管理方式" class="headerlink" title="分段存储管理方式"></a>分段存储管理方式</h2><p>根据程序模块化设计时会将程序分段（如主程序段、子程序段、数据段等）而分段管理便是按程序模块化设计思想分段存储。</p>
<ul>
<li>作业地址空间按逻辑信息的完整性被划分为若干个段；</li>
<li>段内的地址空间是连续的；</li>
<li>许多编译程序支持分段方式，自动根据源程序的情况产生若干个段。</li>
</ul>
<p>分段较分页易于实现段的共享和段的保护。</p>
<h2 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h2><ul>
<li>分页管理内存管理效率高<ul>
<li>没有外零头</li>
<li>内零头小</li>
</ul>
</li>
<li>分段管理符合模块化思想<ul>
<li>每个分段都具备完整的功能</li>
<li>方便代码共享、保护</li>
<li>没有内零头，存在外零头</li>
</ul>
</li>
</ul>
<p>段页式管理结合：先将用户程序分段，每段内再划分成若干页，每段有段号，每段内部的页有一连续的页号。</p>
<p>但在段页式存储管理方式中，每访问一次数据，需访问三次内存。 访问段表、访问页表、访问相应数据，大大降低了访问速度。<br>可以设置快表，表项应包括段号、页号、物理块号。</p>
<p>总结：</p>
<ul>
<li>综合了分段和分页技术的优点，既能有效地利用存储空间，又能方便用户进行程序设计</li>
<li>但是，实现段页式存储管理系统需要增加硬件成本，系统的复杂度和管理开销也大大增加</li>
<li>因此，段页式存储管理技术适合于大、中型计算机系统，不太适合小型、微型计算机系统</li>
</ul>
<h1 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h1><h2 id="虚拟存储器概述"><a href="#虚拟存储器概述" class="headerlink" title="虚拟存储器概述"></a>虚拟存储器概述</h2><p>传统内存管理的一次性和驻留性严重降低内存利用率，减少系统吞吐量<br>当一个程序要求的存储容量超过内存，或大量作业需要内存空间时<br>从物理上增加内存容量，增加系统成本，并且增加是有限的。<br>所以从逻辑上增加内存容量，是虚拟存储技术所要解决的主要问题。</p>
<p>当进程运行时，先将当前<strong>要运行的部分程序装入内存</strong>，其他部分暂留外存；<br>当要执行的指令不在内存时，处理器发生中断，通知操作系统将所缺部分从外存调入内存，保证程序继续执行；<br>当内存不足时，允许程序部分换入、换出。<br><img src="/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/1650616504120.png" alt="enter description here"></p>
<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>程序的执行总是呈现局部性。即在一个较短的时间段内，程序的执行仅限于某个部分。因此只要保证进程<strong>执行所需</strong>的部分程序和数据<strong>驻留在内存</strong>，一段时间内进程都能顺利执行。</p>
<p>具体表现为</p>
<ul>
<li>时间局限性 被访问过的数据可能再次被访问</li>
<li>空间局限性 被访问过的存储单元其附近也可能被访问</li>
</ul>
<h3 id="虚拟存储器的定义"><a href="#虚拟存储器的定义" class="headerlink" title="虚拟存储器的定义"></a>虚拟存储器的定义</h3><p><strong>虚拟存储器</strong>：是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。<br>是一种性能非常优越的存储器管理技术，故被广泛地应用于大、中、小型机器和微型机中。</p>
<h3 id="虚拟存储器的特征"><a href="#虚拟存储器的特征" class="headerlink" title="虚拟存储器的特征"></a>虚拟存储器的特征</h3><ul>
<li><strong>多次性</strong> 多次性是指一个作业被分成多次调入内存运行。相对传统储存管理的<strong>一次性</strong></li>
<li><strong>对换性</strong> 对换性是指作业的运行过程中进行换进、换出。换进和换出能有效地提高内存利用率。相对传统储存管理的常驻性</li>
<li><strong>虚拟性</strong> 虚拟性是指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。</li>
</ul>
<h2 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h2><p><strong>工作原理</strong>：作业运行时，只将当前的一部分装入内存其余的放在辅存，一旦发现访问的页不在主存中，则发出缺页中断，由OS将其从辅存调入主存，如果内存无空块，则根据某种算法选择一个页淘汰以便装入新的页面。</p>
<p>利用这种方法，可使更多的作业处于就绪状态，且能支持比主存容量大的作业在系统中运行。从而提高存储空间利用率。</p>
<p>为了实现请求调页、页面置换两大功能，系统必须提供如下的硬件支持：</p>
<ol>
<li>请求分页的页表机制。</li>
<li>缺页中断机构。</li>
<li>地址变换机构。</li>
</ol>
<h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><ul>
<li>固定分配局部置换 但是难以确定进程合适的分配大小</li>
<li>可变分配全局置换（常用方式）预先分配用完再加</li>
<li>可变分配局部置换 发现缺页后要换出再自行换入，不干涉其它区域</li>
</ul>
<h3 id="物理块分配算法"><a href="#物理块分配算法" class="headerlink" title="物理块分配算法"></a>物理块分配算法</h3><ul>
<li>平均分配算法</li>
<li>按比例分配算法 根据进程的大小</li>
<li>考虑优先权的分配算法</li>
</ul>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><h3 id="最佳-优-置换算法OPT"><a href="#最佳-优-置换算法OPT" class="headerlink" title="最佳(优)置换算法OPT"></a>最佳(优)置换算法OPT</h3><p>理论上最理想的页面置换策略是：从主存中移出永远不再需要的页面；如无这样的页面存在，则应选择最长时间不需要访问的页面。</p>
<h3 id="先进先出（FIFO）页面置换算法"><a href="#先进先出（FIFO）页面置换算法" class="headerlink" title="先进先出（FIFO）页面置换算法"></a>先进先出（FIFO）页面置换算法</h3><p>实质是：总是选择作业中驻留时间最长(即最老)的一页淘汰。即：先进入主存的页面先退出主存。</p>
<h3 id="最近最久未使用（LRU）置换算法"><a href="#最近最久未使用（LRU）置换算法" class="headerlink" title="最近最久未使用（LRU）置换算法"></a>最近最久未使用（LRU）置换算法</h3><p>实质是：当需要置换一页面时，选择在最近一段时间内最久不用的页面予以淘汰。<br>特别的LRU需要硬件支持记录每个页面的最近使用情况</p>
<p>另有最少使用置换算法LFU：选择到当前时间为止被访问次数最少的页面被置换</p>
<h3 id="简单Clock置换算法"><a href="#简单Clock置换算法" class="headerlink" title="简单Clock置换算法"></a>简单Clock置换算法</h3><p>此算法为每页设置一位访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列。<br>具体操作：</p>
<ul>
<li>当某页被访问时，其访问位被置1。</li>
<li>置换程序从上次停止位置开始检查页面的访问位。<ul>
<li>如果是0，就选择该页换出；</li>
<li>若为1，则重新将它置0，给该页驻留内存的机会暂不换出。</li>
</ul>
</li>
</ul>
<p>例：<br><img src="/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/1650618210434.png" alt="enter description here"><br><img src="/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/1650618215534.png" alt="enter description here"></p>
<h3 id="改进Clock置换算法"><a href="#改进Clock置换算法" class="headerlink" title="改进Clock置换算法"></a>改进Clock置换算法</h3><p>如果该页面驻留内存期间没有被修改过，那么不必把它写回辅存，否则系统必须把它写回辅存。<br><strong>即相对简单CLOCK添加修改位</strong></p>
<p>由访问位A和修改位M组合四种类型页面：</p>
<ol>
<li>类（A=0，M=0：既未彼访问，又未被修改，是最佳淘汰页。</li>
<li>类（A=0，M=1）：最近未被访问，但已被修改，并不是很好的淘汰页。</li>
<li>类（A=1，M=0）：最近已被访问，但未被修改：该页有可能再被访问。</li>
<li>类（A=1，M=1）：最近已被访问且被修改，该页可能再被访问。</li>
</ol>
<h2 id="缺页率对有效访问时间的影响"><a href="#缺页率对有效访问时间的影响" class="headerlink" title="缺页率对有效访问时间的影响"></a>缺页率对有效访问时间的影响</h2><p>设内存读写周期为t，查找快表时间为λ，缺页中断处理时间为ɛ</p>
<ul>
<li>页面在内存且页表项在快表中,只需一次访问内存<br>  EAT= λ + t</li>
<li>页面在内存但页表项不在快表中,需两次访问内存，一次读取页表，一次读取数据，另外还需更新快表。<br>  EAT= λ + t + t + λ=2(λ + t)</li>
<li>页面不在内存：考虑查找快表时间、查找页表时间、缺页中断处理时间、更新快表时间、访问实际物理地址时间<br>  EAT= λ + t +ɛ + λ + t = ɛ + 2(λ + t)<br>综上：</li>
<li>则<strong>引入快表命中率为α</strong>，<strong>缺页中断率为f</strong>，则有效访问内存时间为<br>  EAT= λ + α t + (1- α)[t + f(t +ɛ +λ) + (1-f)(t +λ)]</li>
</ul>
<h2 id="抖动和工作集"><a href="#抖动和工作集" class="headerlink" title="抖动和工作集"></a>抖动和工作集</h2><p><strong>抖动</strong>：如果运行进程的大部分时间都用于页面的换入/换出，而几乎不能完成任何有效的工作，则称此进程处于抖动状态。<br>抖动产生的原因有：</p>
<ul>
<li>进程分配的物理块太少</li>
<li>置换算法选择不当</li>
<li>全局置换使抖动传播</li>
</ul>
<p>可利用抖动发生前出现的征兆发现抖动并加以防范。<br>这些技术有：</p>
<ul>
<li>采取局部置换策略</li>
<li>引入工作集的算法</li>
<li>L=S准则 - L缺页之间的平均时间，S平均缺页服务时间</li>
<li>选择暂停的进程</li>
</ul>
<h2 id="请求分段存储管理方式"><a href="#请求分段存储管理方式" class="headerlink" title="请求分段存储管理方式"></a>请求分段存储管理方式</h2><p>工作原理：<br>请求分段系统中，程序运行之前，只需先调入若部分分段，便可启动运行。<br>当所访问的段不在内存中时，可请求OS将所缺的段调入内存。<br>硬件支持：</p>
<ul>
<li>请求分段的段表机制。</li>
<li>缺段中断机构。</li>
<li>地址变换机构。</li>
</ul>
<h3 id="段表机制"><a href="#段表机制" class="headerlink" title="段表机制"></a>段表机制</h3><p><img src="/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/1650619179190.png" alt="enter description here"></p>
<h3 id="环保护"><a href="#环保护" class="headerlink" title="环保护"></a>环保护</h3><p>环保护的基本原则是：<br>一个程序可以<strong>访问</strong>驻留在相同环或<strong>较低</strong>特权环中的数据<br>一个程序可以<strong>调用</strong>驻留在相同环或<strong>较高</strong>特权环中的服务。</p>
<h1 id="习题4"><a href="#习题4" class="headerlink" title="习题4"></a>习题4</h1><h2 id="P162"><a href="#P162" class="headerlink" title="P162"></a>P162</h2><ol start="2">
<li>可采用哪几种方式将程序装入内存？它们分别适合何种场合</li>
</ol>
<ul>
<li>绝对装入方式，适于单道程序环境</li>
<li>可重定位装入方式，适于多道程序环境，静态存储分配</li>
<li>动态运行时装入方式，适于多道程序环境，动态存储分配</li>
</ul>
<ol start="3">
<li>何谓静态链接？静态链接需要解决两个什么问题</li>
</ol>
<ul>
<li>静态链接：在程序运行之前，先将各目标模块及它们所需的库函数，链接成一个完整的装入模块（又称执行模块），以后不再拆开</li>
<li>需要解决：将相对地址进行修改；变换外部调用符号</li>
</ul>
<ol start="5">
<li>何谓运行时动态链接？运行时动态链接有何优点</li>
</ol>
<ul>
<li>运行时动态链接：将某些目标模块的链接推迟到执行时才进行。</li>
<li>优点：节省内存空间</li>
</ul>
<ol start="6">
<li>在动态分区分配方式中，应如何将各空闲分区链接成空闲分区链</li>
</ol>
<ul>
<li><strong>按照地址递增的顺序链接分区</strong>：首次适应、循环首次适应</li>
<li><strong>按照分区大小顺序链接分区</strong>：最佳适应、最坏适应算法</li>
<li><strong>按分区的大小和分类链接成多条分区链</strong>：快速适应、伙伴系统、哈希算法</li>
</ul>
<ol start="8">
<li><p>什么是基于顺序搜索的动态分区分配算法？分为哪几种<br> 它将空闲分区链接成空闲分区链，以此在分配时搜索链上分区，找到满足算法要求的分区<br> 分为首次适应算法、循环首次适应算法、最佳适应算法、最坏适应算法</p>
</li>
<li><p>在采用首次适应算法回收内存时，可能出现哪几种情况？应怎么处理</p>
</li>
</ol>
<ul>
<li>回收区与<strong>上面</strong>的空闲分区邻接，合并，首地址仍是前一空闲分区的，不必为回收分区分配新表项，只需修改前一分区大小</li>
<li>回收区与<strong>下面</strong>的空白区邻接，合并，重新使用新空闲区首址，修改大小</li>
<li>回收区与<strong>上、下面</strong>的空白区邻接，合并，直接将后面空白区取消，修改大小，首地址仍是前一空闲分区的</li>
<li>回收区与<strong>上、下面</strong>的空白区均不邻接，建立新表项</li>
</ul>
<ol start="13">
<li><p>为什么要引入对换？对换可分为哪几种类型<br>为了提高系统的吞吐量，提高内存的利用率和处理机的利用率；<br>全局对换、局部对换。</p>
</li>
<li><p>为实现对换，系统应具备哪几方面的功能<br>对对换空间的管理<br>进程的换入、换出</p>
</li>
<li><p>基于离散分配时所用的基本单位不同，可将离散分配分为哪几种？<br>分页存储管理方式、分段存储管理方式、段页式存储管理方式</p>
</li>
<li><p>什么是页表？页表的作用是什么？<br>每个进程对应 1 个页表，描述该进程的所需各页面在内存中对应的物理块号。</p>
</li>
<li><p>为实现分页存储管理。需要哪些硬件支持?<br>页表寄存器、物理地址寄存器和快表寄存器。<br>地址变换机构。</p>
</li>
<li><p>在分页系统中是如何实现地址变换的?<br>（1）根据逻辑地址,计算出页号和页内偏移量；<br>（2）从PTR中得到页表首址，然后检索页表，查找指定页面对应的页框号；<br>（3）用页框号乘以页面大小获得其对应的起始地址，并将其送入物理地址的高端。<br>（4）将页内偏移量送入物理地址低端，形成完整的物理地址。</p>
</li>
<li><p>在具有快表的段页式存储管理方式中，如何实现地址变换?<br>根据逻辑地址中的页号，查找快表中是否存在对应的页表项。<br>若快表中存在该表项，称为命中（hit），取出其中的页框号，加上页内偏移量，计算出物理地址。<br>若快表中不存在该页表项，称为命中失败，则再查找页表，找到逻辑地址中指定页号对应的页框号。同时，更新快表，将该表项插入快表中。并计算物理地址</p>
</li>
<li><p>分页和分段存储管理有何区别?<br>页是信息的物理单位，而段是信息的逻辑单位。<br>页的大小固定而且由系统决定，段的大小不固定，通常由编译程序划分。<br>分页用户程序地址空间是一维的，分段用户程序地址空间是二维的。</p>
</li>
<li><p>试全面比较连续分配和离散分配方式。<br><strong>连续分配</strong>程序空间本来就是连续的，用连续的内存装入连续的程序，减少管理工作的难度<br><strong>离散分配</strong>方式需要额外的硬件支持，且实现的算法相对比较复杂<br>没有外零头 不受连续空间限制，每块都能分出去，仅有小于一个页面的内零头 程序大小一般不是页大小的整数倍。</p>
</li>
</ol>
<h2 id="P189"><a href="#P189" class="headerlink" title="P189"></a>P189</h2><ol start="2">
<li><p>什么是程序运行时的时间局限性和空间局限性?</p>
<ul>
<li>时间局限性 被访问过的数据可能再次被访问</li>
<li>空间局限性 被访问过的存储单元其附近也可能被访问</li>
</ul>
</li>
<li><p>实现虚拟存储器需要哪些硬件支持?<br> 请求分页/段的页/段表机制<br> 缺页/段中断机构<br> 地址变换机构</p>
</li>
<li><p>实现虚拟存储器需要哪些关键技术？<br> 请求调页/段功能、页面置换功能</p>
</li>
<li><p>请详细说明请求分页系统的地址变换过程。</p>
<ol>
<li>取逻辑地址分解为页号和页内偏移</li>
<li>根据页号查找页表,获得该页的描述信总</li>
<li>若该页中断位为1，产生缺页中断</li>
<li>更新该页的描述信息</li>
<li>根据页块号和页内偏移，计算物理地址。</li>
</ol>
</li>
<li><p>试说明在请求分页系统中页面的调入过程。<br>当程序要访问的页面未在内存时，便向CPU发出缺页中断，中断处理程序通过查找页表，得到该页在外存的物理块后，如果此时内存能容纳新页，则启动磁盘将所缺之页调入内存，然后修改页表。<br>如果内存已满，则须先按照置换算法从内存中选出一页准备换出，然后再把所缺的页调入内存，并修改页表中的相应表项，并将此页表项写入快表中。<br>在缺页调入内存后，修改后的页表形成所要访问数据的物理地址，再去访问内存数据。<br>整个页面的调入过程对用户是透明的。</p>
</li>
<li><p>在请求分页系统中，常采用哪几种页面置换算法?<br>最佳置换算法OPT<br>先进先出置换算法FIFO<br>最近最久未使用置换算法LRU<br>最少使用置换算法LFU<br>简单的Clock置换算法<br>改进型Clock置换算法</p>
</li>
</ol>
<ol start="18">
<li>在请求分页系统中，产生“抖动”的原因是什么?<ul>
<li>进程分配的物理块太少</li>
<li>置换算法选择不当</li>
<li>全局置换使抖动传播</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/26/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE/fabric%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91%E6%AD%A3%E5%BC%8F%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/26/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE/fabric%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91%E6%AD%A3%E5%BC%8F%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">fabric区块链开发正式记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-26 18:58:57" itemprop="dateCreated datePublished" datetime="2022-03-26T18:58:57+08:00">2022-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-30 16:42:03" itemprop="dateModified" datetime="2022-03-30T16:42:03+08:00">2022-03-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/26/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B7%E4%BD%93%E6%B7%B1%E5%85%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/26/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B7%E4%BD%93%E6%B7%B1%E5%85%A5/" class="post-title-link" itemprop="url">区块链具体深入</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-26 13:05:33" itemprop="dateCreated datePublished" datetime="2022-03-26T13:05:33+08:00">2022-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-30 14:21:43" itemprop="dateModified" datetime="2022-03-30T14:21:43+08:00">2022-03-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="链码事件"><a href="#链码事件" class="headerlink" title="链码事件"></a>链码事件</h2><p>Hyperledger Fabric采用异步通信的模式来进行开发，可以在链码里面定义某些事件，然后通过应用程序去监听，当某个事件被触发的时候，就可以执行预先设定好的回调函数了<br>具体体现在cc的invoke</p>
<h2 id="账本与通道"><a href="#账本与通道" class="headerlink" title="账本与通道"></a>账本与通道</h2><p>账本是通过通道（channel）进行隔离的，这种隔离不仅体现在逻辑上，在物理上也是进行分隔的。</p>
<h2 id="智能合约与交易的关系"><a href="#智能合约与交易的关系" class="headerlink" title="智能合约与交易的关系"></a>智能合约与交易的关系</h2><p>智能合约相当于函数的声明与定义，而交易相当于函数的一次调用</p>
<h2 id="身份"><a href="#身份" class="headerlink" title="身份"></a>身份</h2><p>Hyperledger Fabric利用的PKI体系（公钥架构，在网络中提供安全通信的技术，让HTTP变成HTTPS）和CA系统，提供了包括注册登录，身份认证等待功能。<strong>这里的注册登录是指能与区块链底层进行交互的一个身份的管理</strong>，一个应用程序可能只需要一个身份就可以完成所有与区块链底层交互的功能。<br>注册登记，客户端向CA机构表名自己的身份，然后从CA机构获取相应的证书，用于后续的操作，比如交易提案，交易提交等等（CA在区块链外，可以是一个第三方CA）</p>
<h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><p>区块链这样的典型的分布式系统中，他保证每一个节点都有一份完整的数据，都可以对外提供完整的服务。因此区块链是弱化了一致性C，正因为区块链弱化了一致性，所以需要更好的共识算法保证一致性。</p>
<h2 id="PEER"><a href="#PEER" class="headerlink" title="PEER"></a>PEER</h2><p>Peer节点是一个统称，包含了Leader（主节点），Anchor（锚节点），Endorser（背书节点）以及Committer（记账节点）</p>
<p>Leader主节点连接到Orderer节点并与之通信并通知给组织内部的其他节点<br>Anchor锚节点是在通道上可以被所有其他Peer节点发现的节点</p>
<h2 id="Orderer"><a href="#Orderer" class="headerlink" title="Orderer"></a>Orderer</h2><p>从全网的客户端节点接收交易，然后将交易按照一定的规则进行排序<br>将排序好的交易按照固定的时间间隔打包成区块，然后分发给其他组织的主节点</p>
<p>有两种常用类型的排序方法：</p>
<ul>
<li>solo，整个网络中只有一个排序节点，它收到的交易的顺序就是整个网络中的排好序的交易顺序。整个模式仅仅适用于开发和测试时用，如果Orderer节点挂掉了，整个网络就是瘫痪的</li>
<li>kafka，将整个网络中的交易排序过程转交给了kafka集群，每一个Orderer节点都是kafka集群的生产者和消费者，生产者将从客户端节点接收到的交易转发给kafka集群，同时消费者中kafka集群里面获取交易，这样或得到的交易就已经是排好序的了</li>
</ul>
<p>————————————————<br>转自CSDN博主「TLpigff」的文章，遵循CC 4.0 BY-SA版权协议<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lvyibin890/category_10008527.html">https://blog.csdn.net/lvyibin890/category_10008527.html</a></p>

      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/23/%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90TEST/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/23/%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90TEST/" class="post-title-link" itemprop="url">数据结构内存对齐TEST</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-23 15:28:57" itemprop="dateCreated datePublished" datetime="2022-03-23T15:28:57+08:00">2022-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-24 14:49:07" itemprop="dateModified" datetime="2022-03-24T14:49:07+08:00">2022-03-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="win64-or-linux64"><a href="#win64-or-linux64" class="headerlink" title="win64 or linux64"></a>win64 or linux64</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    struct &#123;char a;int b;char c;&#125;X2;//1+3+4+1+3=12</span><br><span class="line">    struct &#123;int a;char b;&#125;X3;//4+1+3=8</span><br><span class="line">    struct &#123;char a;short b;&#125;X4;//1+1+2=4</span><br><span class="line">    struct &#123;char a;short b;char c;&#125;X5;//1+1+2+1+1=6</span><br><span class="line">    struct &#123;char a;long b;&#125;X6;//1+3+4=8 or 1+7+8=16</span><br><span class="line">    struct &#123;char a;long b;char c;&#125;X7;//1+3+4+1+3=12 or 1+7+8+1+7=24</span><br><span class="line">    struct &#123;char a;long long b;&#125;X8;//1+7+8=16</span><br><span class="line">    struct &#123;char a;long long b;char c;&#125;X9;//1+7+8+1+7=24</span><br><span class="line">    struct &#123;char a;int b;short c;&#125;X10;//1+3+4+2+2=12</span><br><span class="line">    struct &#123;char a;short b;char c;int d;&#125;X11;//1+1+2+1+3+4=12</span><br><span class="line">    printf(&quot;%ld\n&quot;,sizeof(X2));</span><br><span class="line">    printf(&quot;%ld\n&quot;,sizeof(X3));</span><br><span class="line">    printf(&quot;%ld\n&quot;,sizeof(X4));</span><br><span class="line">    printf(&quot;%ld\n&quot;,sizeof(X5));</span><br><span class="line">    printf(&quot;%ld\n&quot;,sizeof(X6));</span><br><span class="line">    printf(&quot;%ld\n&quot;,sizeof(X7));</span><br><span class="line">    printf(&quot;%ld\n&quot;,sizeof(X8));</span><br><span class="line">    printf(&quot;%ld\n&quot;,sizeof(X9));</span><br><span class="line">    printf(&quot;%ld\n&quot;,sizeof(X10));</span><br><span class="line">    printf(&quot;%ld\n&quot;,sizeof(X11));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/20/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE/%E5%8C%BA%E5%9D%97%E9%93%BENFT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/20/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE/%E5%8C%BA%E5%9D%97%E9%93%BENFT/" class="post-title-link" itemprop="url">区块链NFT</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-20 19:16:52" itemprop="dateCreated datePublished" datetime="2022-03-20T19:16:52+08:00">2022-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-20 14:53:01" itemprop="dateModified" datetime="2022-04-20T14:53:01+08:00">2022-04-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ERC721"><a href="#ERC721" class="headerlink" title="ERC721"></a>ERC721</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/41437f66afa8">《什么是ERC-721 代币？》</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/393935101">《智能合约NFT之ERC721代币详解》</a></p>
<p>本质上说就是定义的函数接口标准</p>
<h2 id="ERC721标准"><a href="#ERC721标准" class="headerlink" title="ERC721标准"></a>ERC721标准</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.20;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface ERC721 &#123;</span><br><span class="line">    /// @dev 当任何NFT的所有权更改时（不管哪种方式），就会触发此事件。</span><br><span class="line">    ///  包括在创建时（`from` == 0）和销毁时(`to` == 0), 合约创建时除外。</span><br><span class="line">    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);</span><br><span class="line"></span><br><span class="line">    /// @dev 当更改或确认NFT的授权地址时触发。</span><br><span class="line">    ///  零地址表示没有授权的地址。</span><br><span class="line">    ///  发生 `Transfer` 事件时，同样表示该NFT的授权地址（如果有）被重置为“无”（零地址）。</span><br><span class="line">    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);</span><br><span class="line"></span><br><span class="line">    /// @dev 所有者启用或禁用操作员时触发。（操作员可管理所有者所持有的NFTs）</span><br><span class="line">    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);</span><br><span class="line"></span><br><span class="line">    /// @notice 统计所持有的NFTs数量</span><br><span class="line">    /// @dev NFT 不能分配给零地址，查询零地址同样会异常</span><br><span class="line">    /// @param _owner ： 待查地址</span><br><span class="line">    /// @return 返回数量，也许是0</span><br><span class="line">    function balanceOf(address _owner) external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    /// @notice 返回所有者</span><br><span class="line">    /// @dev NFT 不能分配给零地址，查询零地址抛出异常</span><br><span class="line">    /// @param _tokenId NFT 的id</span><br><span class="line">    /// @return 返回所有者地址</span><br><span class="line">    function ownerOf(uint256 _tokenId) external view returns (address);</span><br><span class="line"></span><br><span class="line">    /// @notice 将NFT的所有权从一个地址转移到另一个地址</span><br><span class="line">    /// @dev 如果`msg.sender` 不是当前的所有者（或授权者）抛出异常</span><br><span class="line">    /// 如果 `_from` 不是所有者、`_to` 是零地址、`_tokenId` 不是有效id 均抛出异常。</span><br><span class="line">    ///  当转移完成时，函数检查  `_to` 是否是合约，如果是，调用 `_to`的 `onERC721Received` 并且检查返回值是否是 `0x150b7a02` (即：`bytes4(keccak256(&quot;onERC721Received(address,address,uint256,bytes)&quot;))`)  如果不是抛出异常。</span><br><span class="line">    /// @param _from ：当前的所有者</span><br><span class="line">    /// @param _to ：新的所有者</span><br><span class="line">    /// @param _tokenId ：要转移的token id.</span><br><span class="line">    /// @param data : 附加额外的参数（没有指定格式），传递给接收者。</span><br><span class="line">    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;</span><br><span class="line"></span><br><span class="line">    /// @notice 将NFT的所有权从一个地址转移到另一个地址，功能同上，不带data参数。</span><br><span class="line">    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;</span><br><span class="line"></span><br><span class="line">    /// @notice 转移所有权 -- 调用者负责确认`_to`是否有能力接收NFTs，否则可能永久丢失。</span><br><span class="line">    /// @dev 如果`msg.sender` 不是当前的所有者（或授权者、操作员）抛出异常</span><br><span class="line">    /// 如果 `_from` 不是所有者、`_to` 是零地址、`_tokenId` 不是有效id 均抛出异常。</span><br><span class="line">    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;</span><br><span class="line"></span><br><span class="line">    /// @notice 更改或确认NFT的授权地址</span><br><span class="line">    /// @dev 零地址表示没有授权的地址。</span><br><span class="line">    ///  如果`msg.sender` 不是当前的所有者或操作员</span><br><span class="line">    /// @param _approved 新授权的控制者</span><br><span class="line">    /// @param _tokenId ： token id</span><br><span class="line">    function approve(address _approved, uint256 _tokenId) external payable;</span><br><span class="line"></span><br><span class="line">    /// @notice 启用或禁用第三方（操作员）管理 `msg.sender` 所有资产</span><br><span class="line">    /// @dev 触发 ApprovalForAll 事件，合约必须允许每个所有者可以有多个操作员。</span><br><span class="line">    /// @param _operator 要添加到授权操作员列表中的地址</span><br><span class="line">    /// @param _approved True 表示授权, false 表示撤销</span><br><span class="line">    function setApprovalForAll(address _operator, bool _approved) external;</span><br><span class="line"></span><br><span class="line">    /// @notice 获取单个NFT的授权地址</span><br><span class="line">    /// @dev 如果 `_tokenId` 无效，抛出异常。</span><br><span class="line">    /// @param _tokenId ：  token id</span><br><span class="line">    /// @return 返回授权地址， 零地址表示没有。</span><br><span class="line">    function getApproved(uint256 _tokenId) external view returns (address);</span><br><span class="line"></span><br><span class="line">    /// @notice 查询一个地址是否是另一个地址的授权操作员</span><br><span class="line">    /// @param _owner 所有者</span><br><span class="line">    /// @param _operator 代表所有者的授权操作员</span><br><span class="line">    function isApprovedForAll(address _owner, address _operator) external view returns (bool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解析与实现"><a href="#解析与实现" class="headerlink" title="解析与实现"></a>解析与实现</h2><h3 id="Transfer-event"><a href="#Transfer-event" class="headerlink" title="Transfer event"></a>Transfer event</h3><p>当任何NFT的所有权更改时（不管哪种方式），就会触发此事件，即成立为交易（包括创建，转让，销毁）</p>
<h3 id="Approval-event"><a href="#Approval-event" class="headerlink" title="Approval event"></a>Approval event</h3><p>当更改或确认NFT的<strong>授权</strong>地址时触发。</p>
<h3 id="ApprovalForAll-event"><a href="#ApprovalForAll-event" class="headerlink" title="ApprovalForAll event"></a>ApprovalForAll event</h3><p>所有者启用或禁用<strong>授权</strong>第三方（操作员）管理时触发。</p>
<h3 id="balanceOf"><a href="#balanceOf" class="headerlink" title="balanceOf*"></a>balanceOf*</h3><p>查找owner的资产数量，参数_owner，返回数量</p>
<h3 id="ownerOf"><a href="#ownerOf" class="headerlink" title="ownerOf*"></a>ownerOf*</h3><p>查找资产对应所有者，参数资产tokenid，返回拥有者</p>
<h3 id="safeTransferFrom"><a href="#safeTransferFrom" class="headerlink" title="safeTransferFrom"></a>safeTransferFrom</h3><p>安全的资产所有权转移（修改owner），参数当前所有者、目的所有者、资产tokenid、任意备注（可不带）</p>
<h3 id="transferFrom"><a href="#transferFrom" class="headerlink" title="transferFrom*"></a>transferFrom*</h3><p>资产所有权转移，相比safeTransferFrom参数一致</p>
<h3 id="approve"><a href="#approve" class="headerlink" title="approve*"></a>approve*</h3><p>更改或确认NFT的授权地址，参数新授权人、资产tokenid</p>
<h3 id="setApprovalForAll"><a href="#setApprovalForAll" class="headerlink" title="setApprovalForAll"></a>setApprovalForAll</h3><p>所有者启用或禁用授权第三方（操作员）管理，参数要授权的的操作员、启用/禁用布尔值</p>
<h3 id="getApproved"><a href="#getApproved" class="headerlink" title="getApproved*"></a>getApproved*</h3><p>获取资产授权地址，参数资产tokenid，返回授权地址</p>
<h3 id="isApprovedForAll"><a href="#isApprovedForAll" class="headerlink" title="isApprovedForAll"></a>isApprovedForAll</h3><p>查询一个操作员是否是一个所有者的授权操作员，参数所有者、操作员</p>
<h1 id="链码分析"><a href="#链码分析" class="headerlink" title="链码分析"></a>链码分析</h1><p>资产本身的信息是一组需要区块链记录的结构体，还有每次进行交易时希望对交易信息进行记录则交易信息也设定为一结构体（特殊类型定义为string 设置为宏定义方便转换用）</p>

      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/11/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE/qkledu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/11/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE/qkledu/" class="post-title-link" itemprop="url">区块链简单成绩系统实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-11 17:37:54" itemprop="dateCreated datePublished" datetime="2022-03-11T17:37:54+08:00">2022-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-31 17:22:33" itemprop="dateModified" datetime="2022-03-31T17:22:33+08:00">2022-03-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39200980?type=blog">从0到1：Hyperledger Fabric开发精要【最系统】</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/lvyibin890?type=blog">hubwiz私人博客</a><br><a target="_blank" rel="noopener" href="http://blog.hubwiz.com/categories/Hyperledger-Fabric/">CSDN TLpigff博客</a><br><a target="_blank" rel="noopener" href="https://www.chaindesk.cn/witbook/11/217">CSDN 烟火不完美博客</a></p>
<p><code>github.com/hyperledger/fabric/core/chaincode/shim</code><br><code>github.com/hyperledger/fabric/protos/peer</code><br>改为<br><code>github.com/hyperledger/fabric-chaincode-go/shim</code><br><code>github.com/hyperledger/fabric-protos-go/peer</code></p>
<p>报错：<code>undefined:discovery.ChaincodeCall</code><br>go.mod中<br><code>github.com/hyperledger/fabric-protos-go v0.0.0-20211006172752-14f4318ce71c</code><br>改为<br><code>github.com/hyperledger/fabric-protos-go v0.0.0-20200707132912-fee30f3ccd23</code></p>
<h1 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h1><p>以目录为检索结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">│  config.yaml</span><br><span class="line">│  main.go//重点，执行入口</span><br><span class="line">│  </span><br><span class="line">├─chaincode</span><br><span class="line">│  │  edu.go//业务层重点</span><br><span class="line">│  │  go.mod</span><br><span class="line">│  │  go.sum</span><br><span class="line">│  └─vendor</span><br><span class="line">│</span><br><span class="line">├─fixtures</span><br><span class="line">│  │  configtx.yaml//网络层重点</span><br><span class="line">│  │  crypto-config.yaml//网络层重点</span><br><span class="line">│  │  docker-compose.yaml//网络层重点</span><br><span class="line">│  ├─channel-artifacts    </span><br><span class="line">│  └─crypto-config </span><br><span class="line">│</span><br><span class="line">├─sdkInit</span><br><span class="line">│      integration.go//重点</span><br><span class="line">│      sdkInfo.go//重点</span><br><span class="line">│      sdkSetting.go//重点</span><br><span class="line">│</span><br><span class="line">├─service</span><br><span class="line">│      domain.go//业务层重点</span><br><span class="line">│      eduService.go//业务层重点</span><br><span class="line">│</span><br><span class="line">└─web//常见go网页应用工程MVC模式</span><br><span class="line">    │  webServer.go//各种http.HandleFunc</span><br><span class="line">    ├─controller    </span><br><span class="line">    ├─static      </span><br><span class="line">    └─tpl</span><br></pre></td></tr></table></figure>

<h2 id="fixtures"><a href="#fixtures" class="headerlink" title="fixtures"></a>fixtures</h2><p>三种配置文件、根据配置文件生成的组织结构以及基础区块</p>
<h3 id="crypto-config-yaml"><a href="#crypto-config-yaml" class="headerlink" title="crypto-config.yaml"></a>crypto-config.yaml</h3><p>用于生成相关组织的私钥和证书<br>Fabric 中会有两种类型的公私钥和证书</p>
<ul>
<li>  给节点之间通讯安全而准备的TLS证书</li>
<li>  用户登录和权限控制的用户证书。</li>
</ul>
<p>配置参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/lvyibin890/article/details/106213960">crypto-config配置参考</a></p>
<h3 id="configtx-yaml"><a href="#configtx-yaml" class="headerlink" title="configtx.yaml"></a>configtx.yaml</h3><p>configtx.yaml主要用来配置fabric的组织结构，通道及锚节点的配置。它主要完成以下几个功能：</p>
<ul>
<li>生成启动 Orderer 需要的创世区块orderer.block(genesis.block)</li>
<li>创建应用通道所需的配置交易文件</li>
<li>生成组织锚节点更新配置交易文件</li>
</ul>
<p>配置参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/lvyibin890/article/details/106217716?spm=1001.2014.3001.5502">configtx配置参考</a><br>之后可以使用configtxgen进行生成操作</p>
<h3 id="docker-compose-yaml"><a href="#docker-compose-yaml" class="headerlink" title="docker-compose.yaml"></a>docker-compose.yaml</h3><p>用以配置fabric网络的相关容器<br>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。<br>fabric区块链中多使用docker来创建虚拟容器</p>
<h2 id="chaincode"><a href="#chaincode" class="headerlink" title="chaincode"></a>chaincode</h2><p>链码，合约，或者这里我们理解为接口API<br>是在可执行代码中定义不同组织之间业务规则的代码<br>是业务逻辑中需要的组织交互逻辑而不是全部业务逻辑</p>
<h2 id="sdkinit"><a href="#sdkinit" class="headerlink" title="sdkinit"></a>sdkinit</h2><p>这一块结合main.go主函数理解，主要用于初始化启动SDK</p>
<h2 id="按执行顺序"><a href="#按执行顺序" class="headerlink" title="按执行顺序"></a>按执行顺序</h2><p>.sh脚本内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo docker rm -f $(sudo docker ps -aq)</span><br><span class="line">sudo docker network prune</span><br><span class="line">sudo docker volume prune</span><br><span class="line">删除可能的网络与容器</span><br><span class="line">cd fixtures &amp;&amp; docker-compose up -d</span><br><span class="line">启动docker容器（按fixtures配置）</span><br><span class="line">cd ..</span><br><span class="line">sudo rm education</span><br><span class="line">go build</span><br><span class="line">编译主函数</span><br><span class="line">./education</span><br><span class="line">执行</span><br></pre></td></tr></table></figure>

<h3 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h3><p>sdkInit.Setup<br>包含</p>
<ul>
<li>fabsdk.New</li>
<li>sdk.Context</li>
</ul>
<p>主要工作：初始化SDK</p>
<h3 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h3><p>sdkInit.CreateAndJoinChannel<br>包含</p>
<ul>
<li>createChannel</li>
<li>org.OrgResMgmt.JoinChannel</li>
</ul>
<p>主要工作：创建通道并将组织加入通道</p>
<h3 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h3><p>sdkInit.CreateCCLifecycle<br>分为：</p>
<ul>
<li>打包智能合约</li>
<li>安装智能合约</li>
<li>“认可”智能合约(Approve)</li>
<li>智能合约初始化</li>
</ul>
<p>主要工作：智能合约上链与初始化</p>
<h3 id="第四步："><a href="#第四步：" class="headerlink" title="第四步："></a>第四步：</h3><p>service.InitService<br>包含</p>
<ul>
<li>sdk.ChannelContext</li>
<li>channel.New</li>
</ul>
<p>主要功能：创建通道客户端实例。<br>通道客户端用于查询链码，执行链码，注册/取消特定通道上的链码事件。</p>
<h3 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h3><p>serviceSetup.SaveEdu<br>进行交易实验（添加信息）<br><strong>可跳过</strong></p>
<h3 id="第六步"><a href="#第六步" class="headerlink" title="第六步"></a>第六步</h3><p>serviceSetup.FindEduInfoByEntityID<br>进行交易实验（查询信息）<br><strong>可跳过</strong></p>
<h3 id="第七步"><a href="#第七步" class="headerlink" title="第七步"></a>第七步</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(&quot;第七步&quot;)</span><br><span class="line">app := controller.Application&#123;</span><br><span class="line">	Setup: serviceSetup,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动服务</p>
<h3 id="第八步"><a href="#第八步" class="headerlink" title="第八步"></a>第八步</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(&quot;第八步&quot;)</span><br><span class="line">web.WebStart(app)</span><br></pre></td></tr></table></figure>
<p>建立服务网站</p>
<h3 id="怎么调用链码的"><a href="#怎么调用链码的" class="headerlink" title="怎么调用链码的"></a>怎么调用链码的</h3><p><code>req := channel.Request&#123;ChaincodeID: t.ChaincodeID, Fcn: &quot;addEdu&quot;, Args: [][]byte&#123;b, []byte(eventID)&#125;&#125;</code><br>用这种语句在GO中调用链码写入信息</p>
<h3 id="couchDB"><a href="#couchDB" class="headerlink" title="couchDB"></a>couchDB</h3><p>fabric支持的唯二数据库，是一个NoSQL文档存储数据库。<br>它使用JSON存储数据（文档），使用http协议为api访问文档，使用Web浏览器查询索引。</p>
<h3 id="问题：为什么老是运行的以前的链码？"><a href="#问题：为什么老是运行的以前的链码？" class="headerlink" title="问题：为什么老是运行的以前的链码？"></a>问题：为什么老是运行的以前的链码？</h3><p>太大意了！<br><img src="/2022/03/11/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE/qkledu/1647281435396.png"><br>已经将文件命名为5edu了，却没有改对应路径QAQ</p>

      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/08/%E7%BD%91%E7%BB%9C/SRWE1-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/08/%E7%BD%91%E7%BB%9C/SRWE1-4/" class="post-title-link" itemprop="url">SRWE 1-4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-08 21:12:38" itemprop="dateCreated datePublished" datetime="2022-03-08T21:12:38+08:00">2022-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-11 17:18:56" itemprop="dateModified" datetime="2022-03-11T17:18:56+08:00">2022-03-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>交换、路由和无线基础</p>
<h1 id="基本设备配置"><a href="#基本设备配置" class="headerlink" title="基本设备配置"></a>基本设备配置</h1><h2 id="使用初始设置配置交换机"><a href="#使用初始设置配置交换机" class="headerlink" title="使用初始设置配置交换机"></a>使用初始设置配置交换机</h2><p>在一台思科交换机开机之后，会经过五步启动顺序：</p>
<ul>
<li>步骤 1: 首先，交换机会加载一个存储在ROM中的上电<strong>自检 (POST) 程序</strong>。POST 会校验CPU子系统。它会测试 CPU、DRAM 以及构成 Flash 文件系统的闪存设备部分。</li>
<li>步骤 2: 接下来，交换机加载<strong>启动加载程序</strong>软件。启动加载程序是存储在 ROM 中并在 POST 成功完成后立即运行的小程序。</li>
<li>步骤 3: 启动加载程序执行<strong>低级 CPU 初始化</strong>。启动加载程序初始化 CPU 寄存器，寄存器控制物理内存的映射位置、内存量以及内存速度。</li>
<li>步骤 4: 启动加载程序<strong>初始化</strong>系统主板上的 <strong>Flash 文件系统</strong>。</li>
<li>步骤 5: 最后，启动加载程序找到并将默认的 <strong>IOS 操作系统</strong>软件映像<strong>加载到内存</strong>，并将对交换机的控制权转交给 IOS。</li>
</ul>
<h3 id="boot-system-命令"><a href="#boot-system-命令" class="headerlink" title="boot system 命令"></a>boot system 命令</h3><p>使用 boot system 全局配置模式命令来设置 BOOT 环境变量。<br>如：<code>boot system flash:/c2960-lanbasek9-mz.150-2.SE/c2960-lanbasek9-mz.150-2.SE.bin</code><br>| 命令 | 定义 |<br>| — | — |<br>| boot system| 主命令。 |<br>| flash:| 存储设备 |<br>| c2960-lanbasek9-mz.150-2.SE/| 文件系统的路径 |<br>| c2960-lanbasek9-mz.150-2.SE.bin| IOS 文件名称 |</p>
<h3 id="交换机-LED-指示灯"><a href="#交换机-LED-指示灯" class="headerlink" title="交换机 LED 指示灯"></a>交换机 LED 指示灯</h3><ul>
<li><strong>SYST</strong> - 系统LED</li>
<li><strong>RPS</strong> - 冗余电源系统LED</li>
<li><strong>STAT</strong> - 端口状态LED</li>
<li><strong>DUPLX</strong> - 端口双工模式LED</li>
<li><strong>SPEED</strong> - 端口速率LED</li>
<li><strong>POE</strong> - 以太网端口供电LED</li>
</ul>
<h3 id="从系统崩溃中恢复"><a href="#从系统崩溃中恢复" class="headerlink" title="从系统崩溃中恢复"></a>从系统崩溃中恢复</h3><h2 id="配置交换机端口"><a href="#配置交换机端口" class="headerlink" title="配置交换机端口"></a>配置交换机端口</h2><h2 id="安全远程访问"><a href="#安全远程访问" class="headerlink" title="安全远程访问"></a>安全远程访问</h2><h2 id="路由器基本配置"><a href="#路由器基本配置" class="headerlink" title="路由器基本配置"></a>路由器基本配置</h2><h2 id="验证直连网络"><a href="#验证直连网络" class="headerlink" title="验证直连网络"></a>验证直连网络</h2><h1 id="交换的概念"><a href="#交换的概念" class="headerlink" title="交换的概念"></a>交换的概念</h1><h2 id="帧转发"><a href="#帧转发" class="headerlink" title="帧转发"></a>帧转发</h2><h2 id="交换域"><a href="#交换域" class="headerlink" title="交换域"></a>交换域</h2>
      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/04/%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/04/%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-title-link" itemprop="url">数据库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-04 19:06:38" itemprop="dateCreated datePublished" datetime="2022-03-04T19:06:38+08:00">2022-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-08 10:58:06" itemprop="dateModified" datetime="2022-03-08T10:58:06+08:00">2022-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据库及其系统概念"><a href="#数据库及其系统概念" class="headerlink" title="数据库及其系统概念"></a>数据库及其系统概念</h1><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>数据(Data)是数据库中存储的基本对象</p>
<ul>
<li>数据的定义<br>  描述事物的符号记录</li>
<li>数据的种类<br>  文字、图形、图象、声音</li>
<li>数据的特点<br>  数据与其语义是不可分的</li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>数据库的<strong>定义</strong>：<br>数据库(Database,简称DB)是长期储存在计算机内、有组织的、可共享的大量数据的集合。<br>数据库的基本<strong>特征</strong>：</p>
<ul>
<li>数据按一定的数据模型组织、描述和储存</li>
<li>可为各种用户共享</li>
<li>冗余度较小</li>
<li>数据独立性较高</li>
<li>易扩展<br>概括地讲，数据库具有永久存储、有组织、可共享三个基本特点。</li>
</ul>
<h2 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h2><ul>
<li>什么是DBMS：<br>  数据库管理系统（Database Management System，简称DBMS）是位于用户与操作系统之间的一层数据管理软件。</li>
<li>DBMS的用途：<br>  科学地组织和存储数据、高效地获取和维护数据<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3></li>
<li><strong>数据定义功能</strong><br>  提供数据定义语言(DDL) 定义数据库中的数据对象</li>
<li><strong>数据组织、存储和管理</strong><br>  分类组织、存储和管理各种数据<br>  确定组织数据的文件结构和存取方式<br>  实现数据之间的联系<br>  提供多种存取方法提高存取效率</li>
<li><strong>数据操纵功能</strong><br>  提供数据操纵语言(DML)<br>  实现对数据库的基本操作 (查询、插入、删除和修改)</li>
<li><strong>数据库的事务管理和运行管理</strong><br>  数据库在建立、运行和维护时由DBMS统一管理和控制 保证数据的安全性、完整性、多用户对数据的并发使用 发生故障后的系统恢复</li>
<li><strong>数据库的建立和维护功能</strong>(实用程序)<br>  数据库初始数据装载转换<br>  数据库转储<br>  介质故障恢复<br>  数据库的重组织<br>  性能监视分析等</li>
<li><strong>其它功能</strong><br>  DBMS与网络中其它软件系统的通信<br>  两个DBMS系统的数据转换<br>  异构数据库之间的互访和互操作</li>
</ul>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>数据模型是指描述事物对象的数据结构组成、数据语义联系、数据约束的抽象结构及其说明</p>
<ol>
<li><strong>数据结构</strong>: 用于描述事物对象的静态特征，包括事物对象的数据组成、数据类型、数据性质等。</li>
<li><strong>数据操作</strong>:用于描述事物对象的动态特征，包括数据的插入、修改、删除和查询等访问操作。</li>
<li><strong>数据约束</strong>：用于描述数据结构中数据之间的语义联系、数据之间的制约和依存关系，以及数据动态变化的规则等。<br>有：</li>
</ol>
<p><strong>层次</strong>数据模型、<strong>网状</strong>数据模型、<strong>关系</strong>数据模型、其它数据模型（如对象数据模型、键值对数据模型、列式数据模型、文档数据模型、图形数据模型等）</p>
<h2 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h2><p>数据库系统（Database Systems）是一类基于数据库进行数据管理与信息服务的软件系统。数据库系统由用户、数据库应用程序、数据库管理系统和数据库<strong>四个部分组成</strong>。</p>
<h3 id="关系数据库中数据内容"><a href="#关系数据库中数据内容" class="headerlink" title="关系数据库中数据内容"></a>关系数据库中数据内容</h3><p>在关系数据库中，除了存储和管理应用的<strong>用户数据</strong>外，还需要存储与管理数据库本身的<strong>元数据</strong>、<strong>索引数据</strong>、<strong>运行数据</strong>等系统数据。</p>
<h2 id="数据库系统应用结构"><a href="#数据库系统应用结构" class="headerlink" title="数据库系统应用结构"></a>数据库系统应用结构</h2><p>单机用户结构、单机用户结构、客户/服务器结构、分布式结构</p>
<h2 id="数据库应用系统生命周期"><a href="#数据库应用系统生命周期" class="headerlink" title="数据库应用系统生命周期"></a>数据库应用系统生命周期</h2><p>需求分析、系统设计、系统实现、系统测试、系统运行与维护</p>
<h2 id="典型数据库管理系统"><a href="#典型数据库管理系统" class="headerlink" title="典型数据库管理系统"></a>典型数据库管理系统</h2><p>ACCESS——微软公司推出的桌面数据库管理系统<br> SQL SERVER——微软公司推出的商用数据库管理系统<br> Oracle Database——甲骨文公司推出的企业级数据库管理系统<br> IBM DB2——IBM公司推出的企业级数据库管理系统<br> Sybase ASE——Sybase公司推出的企业级数据库管理系统<br> MySql——应用广泛的开源关系数据库管理系统<br> PostgreSQL——技术领先的开源对象-关系数据库管理系统<br> Sybase SQL Anywhere——Sybase推出的移动计算数据库管理系统<br> SQLite——开源的轻量级嵌入式数据库管理系统</p>
<h1 id="关系及其相关概念"><a href="#关系及其相关概念" class="headerlink" title="关系及其相关概念"></a>关系及其相关概念</h1><h2 id="关系、实体"><a href="#关系、实体" class="headerlink" title="关系、实体"></a>关系、实体</h2><p><strong>实体</strong>（entity）——是指包含有数据特征的事物对象在概念模型世界中的抽象名称。<br><strong>关系</strong>（relation）——是指具有关系特征、用于存放实体数据的二维表。关系也常被称为关系表。</p>
<h2 id="关系键"><a href="#关系键" class="headerlink" title="关系键"></a>关系键</h2><p>在关系中，可以用来唯一标识元组的属性列，称为键（Key），其它属性列都为非键列。</p>
<ul>
<li><strong>复合键</strong>（Compound Key）——是指关系中用来唯一标识元组的多列作为键。</li>
<li><strong>候选键</strong>（Candidate Key）——关系中可能有多个列均适合作为键，将其中每个都称为候选键。</li>
<li><strong>主键</strong>（Primary key）是关系表中最有代表性的一个候选键，每个关系表中只能定义一个主键。<br>  主键作用：<ul>
<li>唯一标识关系表的每行（元组）</li>
<li>与关联表的外键建立联系，实现关系表之间连接</li>
<li>数据库文件使用主键值来组织关系表的数据存储</li>
<li>数据库使用主键索引快速检索数据</li>
</ul>
</li>
<li><strong>代理键</strong>——采用DBMS自动生成的数字序列作为关系表的主键。</li>
</ul>
<h2 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h2><p><strong>关系模型</strong>（Relation Model）——是一种基于二维表结构存储数据实体及实体间联系的数据模型。<br>由数据结构、数据操作方式、数据关系约束组成。</p>
<h2 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h2><h3 id="关系模型完整性"><a href="#关系模型完整性" class="headerlink" title="关系模型完整性"></a>关系模型完整性</h3><p>关系模型完整性是指在关系数据模型中对关系实施的完整性约束。<br>完整性约束作用：</p>
<ul>
<li>消除关系表的元组重复存储</li>
<li>保持关联表的数据一致性</li>
<li>实现业务数据规则</li>
</ul>
<p>关系模型完整性约束组成：</p>
<ul>
<li>实体完整性约束</li>
<li>参照完整性约束</li>
<li>用户自定义完整性约束</li>
</ul>
<h3 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h3><p>实体完整性是指在关系表中实施的主键取值约束，以保证关系表中的每个元组可以被唯一标识。<br>实体完整性<strong>约束规则</strong>：</p>
<ul>
<li>每个关系表中的主键属性列都不允许为空值（NULL），否则就不可能标识实体。</li>
<li>现实世界中的实体是靠主键来标识，主键取值应该唯一，并区分关系表中的每个元组。</li>
</ul>
<h3 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h3><p>参照完整性是指关系表之间需要遵守的数据约束，以保证关系之间关联列的数据一致性。<br>参照完整性<strong>约束规则</strong>：若关系R中的外键F与关系S中的主键K相关联，则R中外键F值必须与S中主键K值一致。</p>
<p><strong>外键</strong>（Foreign key）——在关联的两个关系中，它们具有一个或多个相同属性。若关联列在第一个关系中作为主键，则在第二个关系中作为外键。</p>
<h3 id="用户自定义完整性"><a href="#用户自定义完整性" class="headerlink" title="用户自定义完整性"></a>用户自定义完整性</h3><p>用户自定义完整性是指用户根据具体业务对数据处理规则要求所定义的数据约束。<br>用户可以定义如下类型的完整性约束：</p>
<ul>
<li>定义列的数据类型与取值范围</li>
<li>定义列的缺省值</li>
<li>定义列是否允许取空值</li>
<li>定义列取值唯一性</li>
<li>定义列之间的数据依赖性</li>
</ul>

      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1-3)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1-3)/" class="post-title-link" itemprop="url">计算机操作系统(1-3)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-04 14:34:00" itemprop="dateCreated datePublished" datetime="2022-03-04T14:34:00+08:00">2022-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-22 17:56:34" itemprop="dateModified" datetime="2022-04-22T17:56:34+08:00">2022-04-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="操作系统引论"><a href="#操作系统引论" class="headerlink" title="操作系统引论"></a>操作系统引论</h1><h2 id="目标和作用"><a href="#目标和作用" class="headerlink" title="目标和作用"></a>目标和作用</h2><p>目标：方便性、有效性、可扩展性、开放性<br>作用</p>
<ol>
<li>作为用户与计算机硬件系统之间的接口</li>
<li>操作系统引论作为计算机系统资源的管理者</li>
<li>实现了对计算机资源的抽象</li>
</ol>
<h2 id="发展过程"><a href="#发展过程" class="headerlink" title="发展过程"></a>发展过程</h2><p>人工操作方式、脱机输入输出方式<br>单批道处理系统<br>多批道处理系统（资源利用率高，系统吞吐量大，平均周转时间长，无交互能力）<br>分时系统（多路性、独立性、及时性、交互性）<br>实时系统（多路性、独立性、及时性、交互性、可靠性）<br>微机操作系统（单用户多用户）</p>
<h2 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h2><ul>
<li>并发 -  <strong>并发性</strong>是指两个或多个事件在同一时间间隔内发生，而<strong>并行性</strong>是指两个或多个事件在同一时刻发生。</li>
<li>共享 -  <strong>资源共享</strong>是指系统中的资源可供内存中多个并发执行的进程共同使用。一段时间内只允许一个进程访问的资源称为<strong>临界资源</strong>一个进程访问结束并释放系统资源后才允许另一进程对该资源访问的方式称为<strong>互斥访问</strong></li>
<li>虚拟 -  通过<strong>空分复用</strong>或<strong>时分复用</strong>技术将一条物理信道变为若干条逻辑信道的技术</li>
<li>异步 -  进程的执行本身具有异步性（不可预知完成时间与顺序）所以要设计同步机制</li>
</ul>
<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><h3 id="处理机管理功能"><a href="#处理机管理功能" class="headerlink" title="处理机管理功能"></a>处理机管理功能</h3><ul>
<li>进程控制</li>
<li>进程同步</li>
<li>进程通信</li>
<li>调度</li>
</ul>
<h3 id="内存管理功能"><a href="#内存管理功能" class="headerlink" title="内存管理功能"></a>内存管理功能</h3><ul>
<li>内存分配</li>
<li>内存保护</li>
<li>地址映射</li>
<li>内存扩充</li>
</ul>
<h3 id="I-O-设备管理功能"><a href="#I-O-设备管理功能" class="headerlink" title="(I/O)设备管理功能"></a>(I/O)设备管理功能</h3><ul>
<li>缓冲管理</li>
<li>设备分配</li>
<li>设备处理</li>
</ul>
<h3 id="文件管理功能"><a href="#文件管理功能" class="headerlink" title="文件管理功能"></a>文件管理功能</h3><ul>
<li>文件存储空间管理</li>
<li>目录管理</li>
<li>文件读写管理与保护</li>
</ul>
<h3 id="操作系统与用户之间的接口"><a href="#操作系统与用户之间的接口" class="headerlink" title="操作系统与用户之间的接口"></a>操作系统与用户之间的接口</h3><ul>
<li>用户接口（联机用户接口、脱机用户接口、程序接口）</li>
<li>程序接口</li>
</ul>
<h2 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h2><h3 id="无结构"><a href="#无结构" class="headerlink" title="无结构"></a>无结构</h3><p>程序紧凑，高效利用内存<br>但是随着系统的不断扩大，所设计出的操作系统就会变得既庞大又杂乱。<br>一方面会使编制的程序错误很多给调试工作带来困难<br>另一方面也使程序难以阅读和理解，增加了维护负担</p>
<h3 id="模块化结构"><a href="#模块化结构" class="headerlink" title="模块化结构"></a>模块化结构</h3><p>模块化OS由程序设计的模块化设计思想演变而来<br>衡量模块化设计的两个标准：内聚性、耦合性<br>优点：</p>
<ol>
<li>提高OS设计的正确性、可理解性和可维护性。</li>
<li>增强OS的可适应性。</li>
<li>加速OS开发过程。<br>问题：</li>
<li>最初模块接口规定难以满足实际需求</li>
<li>无序设计</li>
</ol>
<h3 id="分层式结构"><a href="#分层式结构" class="headerlink" title="分层式结构"></a>分层式结构</h3><p>将模块接口法中对模块的设计顺序由无序变为有序，自底向上分层设计<br>优点：</p>
<ol>
<li>易保证系统的正确性</li>
<li>易扩充和易维护性<br>缺点：</li>
<li>系统效率降低：单向依赖的层次使得必须建立层次之间的通信机制增加通信开销</li>
</ol>
<h3 id="文件管理功能-文件管理功能"><a href="#文件管理功能-文件管理功能" class="headerlink" title="文件管理功能### 文件管理功能"></a>文件管理功能### 文件管理功能</h3><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><ol>
<li><p>设计现代OS的主要目标是什么？<br>方便性、有效性、可扩展性、开放性</p>
</li>
<li><p>试说明推动分时系统形成和发展的主要动力是什么。<br>满足人机交互需求，实现共享主机</p>
</li>
<li><p>为什么要引入实时操作系统？<br>更好的满足实时控制实时信息处理领域对时间控制的需求</p>
</li>
<li><p>试从交互性、及时性以及可靠性方面将分时系统与实时系统进行比较。<br>交互性：实时系统的交互性不像分时系统为终端用户提供数据和资源共享服务，而限于特定专用服务程序<br>及时性：分时系统的响应时间间隔通常为人们所能接受的1~3秒，实时系统由截至时间所确定通常为秒级到毫秒级<br>可靠性：实时系统相比分时系统要求更高的可靠性，所以采取多级容错措施保障系统的安全性</p>
</li>
<li><p>OS有几大特征？最基本的特征是什么？<br>并发性、共享性、虚拟性、异步性；并发性最基本</p>
</li>
<li><p>处理机管理有哪些主要功能？其主要任务是什么？<br>进程控制、进程同步、进程通信、调度<br>创建进程结束进程控制正在运行的进程、使多个进程有序同步进行、交换进程任务的信息、选择作业分配资源运行的作业调度和选择进程分配处理器设置现场执行的进程调度</p>
</li>
<li><p>存储器有哪些主要功能？其主要任务是什么？<br>内存分配、内存保护、地址映射、内存扩充<br>为程序分配内存空间、确保程序运行空间不干扰、将逻辑地址映射为物理地址、实现调用置换等功能</p>
</li>
<li><p>设备管理有哪些主要功能？其主要任务是什么？<br>缓冲管理、设备分配、设备处理<br>完成用户IO请求分配所需IO设备执行IO操作、提高CPU和IO设备的利用率提高IO速度方便用户使用</p>
</li>
<li><p>文件管理有哪些主要功能？其主要任务是什么？<br>文件存储空间管理、目录管理、文件读写管理与保护<br>分配外存空间提高外存利用率、为文件建立目录加以有效组织、根据用户请求读写外存数据、防止文件被非法窃取和受到破坏保障文件安全性</p>
</li>
</ol>
<h1 id="进程的描述与控制"><a href="#进程的描述与控制" class="headerlink" title="进程的描述与控制"></a>进程的描述与控制</h1><h2 id="前趋图和程序执行"><a href="#前趋图和程序执行" class="headerlink" title="前趋图和程序执行"></a>前趋图和程序执行</h2><p>前趋图（Precedence  Graph）是一个有向无循环图，用于描述进程之间执行的前后关系。</p>
<h3 id="程序的顺序执行"><a href="#程序的顺序执行" class="headerlink" title="程序的顺序执行"></a>程序的顺序执行</h3><ul>
<li>顺序性</li>
<li>封闭性</li>
<li>可再现性</li>
</ul>
<h3 id="程序的并发执行"><a href="#程序的并发执行" class="headerlink" title="程序的并发执行"></a>程序的并发执行</h3><ul>
<li>间断性</li>
<li>失去封闭性</li>
<li>不可再现性</li>
</ul>
<h2 id="进程的描述"><a href="#进程的描述" class="headerlink" title="进程的描述"></a>进程的描述</h2><p>而由程序段、相关的数据段和PCB三部分便构成了进程实体。</p>
<h3 id="典型定义"><a href="#典型定义" class="headerlink" title="典型定义"></a>典型定义</h3><ol>
<li>进程是程序的一次执行。</li>
<li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</li>
<li>进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</li>
</ol>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul>
<li>动态性</li>
<li>并发性</li>
<li>独立性</li>
<li>异步性</li>
</ul>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p><img src="/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1-3)/IMG_20220304_151207_edit_772433114767030.jpg" alt="IMG_20220304_151207_edit_772433114767030"></p>
<h3 id="PCB数据结构"><a href="#PCB数据结构" class="headerlink" title="PCB数据结构"></a>PCB数据结构</h3><ol>
<li><strong>进程标识符</strong> - 用于惟一地标识一个进程。分为内部标识符和外部标识符</li>
<li><strong>处理机状态</strong> - 组成：①通用寄存器②指令计数器③程序状态字PSW④用户栈指针</li>
<li><strong>进程调度信息</strong> - 包括：①进程状态②进程优先级③进程调度所需的其它信息④事件，阻塞原因</li>
<li><strong>进程控制信息</strong> - ①程序和数据的地址 ②进程同步和通信机制 ③资源清单 ④链接指针</li>
</ol>
<table>
<thead>
<tr>
<th>pid</th>
</tr>
</thead>
<tbody><tr>
<td>进程状态</td>
</tr>
<tr>
<td>现场</td>
</tr>
<tr>
<td>优先级</td>
</tr>
<tr>
<td>阻塞原因</td>
</tr>
<tr>
<td>程序地址</td>
</tr>
<tr>
<td>同步机制</td>
</tr>
<tr>
<td>资源清单</td>
</tr>
<tr>
<td>链接指针</td>
</tr>
</tbody></table>
<h3 id="PCB的组织方式"><a href="#PCB的组织方式" class="headerlink" title="PCB的组织方式"></a>PCB的组织方式</h3><ol>
<li><strong>线性方式</strong> 将系统中的所有PCB组织在一张线性表中，将该表的首地址存放在一个专用区域中。</li>
<li><strong>链接方式</strong> 把具有同一状态的PCB，用其中的链接字链接成一个队列，排成就绪队列，若干个阻塞队列以及空白队列。</li>
<li><strong>索引方式</strong> 系统根据所有进程的状态建立几张索引表。</li>
</ol>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>进程控制是用于创建一个新进程，终止一个已完成的进程，或去终止一个因出现某事件而使其无法运行下去的进程，还负责进程运行中的状态转换。</p>
<h3 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h3><p>OS内核—-常驻内存。<br>包含与硬件紧密相关的模块（中断处理） 常用设备驱动、运行频率高的模块（时钟管理、进程调度）<br>目的：1、保护；2、提供OS效率</p>
<ol>
<li>支撑功能 - 中断处理 时钟管理 原语操作</li>
<li>资源管理功能 - 进程管理 存储器管理 设备管理</li>
</ol>
<h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><h4 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h4><p>即父进程、子进程（可以继承父进程所拥有的资源）</p>
<h4 id="引起创建进程的事件"><a href="#引起创建进程的事件" class="headerlink" title="引起创建进程的事件"></a>引起创建进程的事件</h4><ol>
<li>用户登录</li>
<li>作业调度</li>
<li>提供服务</li>
<li>应用请求</li>
</ol>
<h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><p>调用进程创建原语Creat（ ）按下述步骤创建一个新进程：</p>
<ol>
<li>申请空白PCB。</li>
<li>为新进程分配资源。</li>
<li>初始化进程控制块。包括：<br>①初始化标识信息。<br>②初始化处理机状态信息。<br>③初始化处理机控制信息。</li>
<li>将新进程插入就绪队列。</li>
</ol>
<h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><h4 id="引起进程终止的事件"><a href="#引起进程终止的事件" class="headerlink" title="引起进程终止的事件"></a>引起进程终止的事件</h4><ol>
<li>正常结束: 批处理中用Holt指令，分时中用Logs off指令。</li>
<li>异常结束：<br>①越界错误。存储区。<br>②保护错。写一个只读文件。<br>③非法指令。执行一条不存在的指令。<br>④特权指令错。用户访问只允许OS执行的指令。<br>⑤运行超时。<br>⑥等待超时。<br>⑦算术运算错。被0除。<br>⑧I/O故障。</li>
<li>外界干预：外界干预并非指在本进程运行中出现了异常事件，而是指进程应外界的请求而终止运行。<br>① 操作员或操作系统干预。<br>② 父进程请求终止该进程。<br>③ 当父进程终止时，OS也将他的所有子孙进程终止。</li>
</ol>
<h4 id="进程的终止过程"><a href="#进程的终止过程" class="headerlink" title="进程的终止过程"></a>进程的终止过程</h4><ol>
<li>根据被终止进程的标识符ID，从PCB集合中检索出该进程的PCB，从中读出该进程的状态。</li>
<li>若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度。</li>
<li>若该进程还有子孙进程，还应将其所有子孙进程予以终止，以防他们成为不可控的进程。</li>
<li>将被终止进程所拥有的全部资源，或者归还给其父进程，或者归还给系统。</li>
<li>将被终止进程（它的PCB）从所在队列（或链表）中移出，等待其他程序来搜集信息。</li>
</ol>
<h3 id="进程的阻塞与唤醒、挂起与激活"><a href="#进程的阻塞与唤醒、挂起与激活" class="headerlink" title="进程的阻塞与唤醒、挂起与激活"></a>进程的阻塞与唤醒、挂起与激活</h3><h4 id="引起进程阻塞的事件"><a href="#引起进程阻塞的事件" class="headerlink" title="引起进程阻塞的事件"></a>引起进程阻塞的事件</h4><ol>
<li>请求系统服务：提出I/O服务时，并不立即满足该进程的要求时，转变为阻塞状态来等待</li>
<li>启动某种操作：当进程启动某种操作后，在该操作完成之后才能继续执行。</li>
<li>新数据尚未到达：对于相互合作的进程而言。 </li>
<li>无新工作可做。如发送进程。</li>
</ol>
<h4 id="进程阻塞过程"><a href="#进程阻塞过程" class="headerlink" title="进程阻塞过程"></a>进程阻塞过程</h4><p>正在执行的进程，当发现上述某事件时，由于无法继续执行，于是进程便通过调用阻塞原语block( )把自己阻塞。</p>
<ol>
<li>把进程控制块中的现行状态由“执行”改为“阻塞”，并将PCB插入阻塞队列。</li>
<li>转调度程序进行重新调度，将处理机分配给另一就绪进程，并进行切换。</li>
</ol>
<h4 id="进程唤醒过程"><a href="#进程唤醒过程" class="headerlink" title="进程唤醒过程"></a>进程唤醒过程</h4><p>当被阻塞进程所期待的事件出现时，则由有关进程（比如，用完并释放了该I/O设备的进程）调用唤醒原语wakeup( )，将等待该事件的进程唤醒。</p>
<ol>
<li>首先把被阻塞的进程从等待该事件的阻塞队列中移出，将其PCB中的现行状态由阻塞改为就绪</li>
<li>然后再将该PCB插入到就绪队列中。</li>
</ol>
<h4 id="进程的挂起"><a href="#进程的挂起" class="headerlink" title="进程的挂起"></a>进程的挂起</h4><p>当出现了引起进程挂起的事件时，系统将利用挂起原语suspend( )将指定进程进程挂起。</p>
<ol>
<li>首先检查被挂起进程的状态，若处于活动就绪状态，便将其改为静止就绪；</li>
<li>对于活动阻塞状态的进程，则将之改为静止阻塞状态。</li>
</ol>
<h4 id="进程的激活"><a href="#进程的激活" class="headerlink" title="进程的激活"></a>进程的激活</h4><p>当发生激活进程的事件时，则可将在外存上处于静止就绪状态的进程换入内存。 系统利用激活原语active( )将指定进程激活:</p>
<ol>
<li>激活原语先将进程从外存调入内存，检查该进程的现行状态; </li>
<li>若是静止就绪，便将之改为活动就绪；若为静止阻塞，便将之改为活动阻塞。</li>
</ol>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>为什么：<br>由于进程的异步性，也会给系统造成混乱，在OS中引入进程同步。<br>任务：<br>使并发执行的诸进程之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性。</p>
<h3 id="进程同步的基本概念"><a href="#进程同步的基本概念" class="headerlink" title="进程同步的基本概念"></a>进程同步的基本概念</h3><ul>
<li>两种形式的制约关系：1）间接相互制约关系。由于资源共享 2）直接相互制约关系。主要由于进程间的合作。</li>
<li><strong>临界资源</strong> 一次仅允许一个进程访问的资源为临界资源 。</li>
<li><strong>临界区</strong> 把在每个进程中访问临界资源的那段代码称为临界区。</li>
<li>同步机制<strong>规则</strong> ：1)空闲让进 2)忙则等待 3)有限等待 4)让权等待</li>
</ul>
<h3 id="硬件同步机制"><a href="#硬件同步机制" class="headerlink" title="硬件同步机制"></a>硬件同步机制</h3><p>利用计算机硬件指令解决临界区问题<br>    对临界区管理将标识看做一个锁，“锁开”进入，“锁关”等待。 初始打开，每个进入临界区的进程必须对锁进行测试。 测试和关锁操作必须连续（原子操作）<br>方法：</p>
<ul>
<li>关中断</li>
<li>利用Test-and-Set指令实现互斥</li>
<li>利用Swap指令实现进程互斥</li>
</ul>
<p>优点：</p>
<ul>
<li>适用于任意数目的进程，在单处理器或多处理器上</li>
<li>简单，容易验证其正确性</li>
<li>可以支持进程内存在多个临界区，只需为每个临界区设立一个布尔变量</li>
</ul>
<p>缺点：</p>
<ul>
<li>等待要耗费CPU时间，不能实现“让权等待”</li>
<li>可能“饥饿”：从等待进程中随机选择一个进入临界区，有的进程可能一直选不上</li>
</ul>
<h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><p>信号量（Semaphores）机制:是一种卓有成效的进程同步工具。</p>
<h4 id="整形信号量"><a href="#整形信号量" class="headerlink" title="整形信号量"></a>整形信号量</h4><ol>
<li>必须置一次且只能置一次初值，并且初值不能为负数。</li>
<li>只能执行P、V操作。</li>
<li>必须成对使用P、V操作：P操作遗漏则不能保证互斥访问，V操作遗漏则不能在使用临界资源之后将其释放；P，V次序不能错误、重复或遗漏。<br>整形信号量机制的问题：忙等。<br>wait操作中信号量S&lt;=0时，会不停的测试<br>未遵循让权等待的原则</li>
</ol>
<h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h4><p>只能用于共享一个临界资源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">	int value;</span><br><span class="line">	struct process_control_block *list;</span><br><span class="line">&#125;semaphore;</span><br><span class="line"></span><br><span class="line">wait(semaphore *S)&#123;</span><br><span class="line">	S-&gt;value--;</span><br><span class="line">	if(S-&gt;value&lt;0)block(S-&gt;list);</span><br><span class="line">&#125;</span><br><span class="line">signal(semaphore *S)&#123;</span><br><span class="line">	S-&gt;value++;</span><br><span class="line">	if(S-&gt;value&lt;=0)wakeup(S-&gt;list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>信号量的初值：0，1，n三种情况<br>    1：表示临界资源；<br>    0：表示进程间的同步（前驱）关系<br>    n：表示若干个资源</p>
<h4 id="AND型信号量"><a href="#AND型信号量" class="headerlink" title="AND型信号量"></a>AND型信号量</h4><p><strong>AND同步机制的基本思想</strong>：将进程在整个运行过程中需要的所有资源，一次性全都地分配给进程，待进程使用完后再一起释放。只要尚有一个资源未能分配给进程，其它所有可能为之分配的资源，也不分配给他。<br><strong>原子操作</strong>：要么全部分配到进程，要么一个也不分配。<br>在wait操作中，增加了一个“AND”条件，故称为AND同步，或称为同时wait操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Swait（S1，S2，···，Sn ） &#123;</span><br><span class="line">     while（true）&#123;</span><br><span class="line">         if（ S1≥1 and S2≥1 and…and Sn≥1 ）&#123;</span><br><span class="line">            for (i = 1 ; i&lt;= n; i++)&#123;</span><br><span class="line">                     Si =  Si – 1;</span><br><span class="line">             &#125;</span><br><span class="line">             break;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">               place  the process  in  the waiting  queue  associated  with  the  first  Si  found  with  Si＜1,  and  set  the program  count  of  this  process  to  the  beginning  of  Swait  operation//将进程置于与在 Si&lt;1 的条件下找到的**第一个** Si 关联的等待队列中，并将此过程的程序计数设置为 Swait 操作的开始</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ssignal（S1，S2，···，Sn）&#123;</span><br><span class="line">    for(  i = 1; i&lt;= n; i++ )&#123;</span><br><span class="line">         Si = Si+1;</span><br><span class="line">         Remove  all  the  process  waiting  in  the  queue  associated  with  Si  into  the  ready  queue//将与 Si 关联的队列中**所有**等待的进程移动到就绪队列中</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="信号量集"><a href="#信号量集" class="headerlink" title="信号量集"></a>信号量集</h4><p>一般信号量集是指同时需要多种资源、每种占用的数目不同、且可分配的资源(预留下限)还存在一个临界值时的信号量处理<br>一般信号量集的基本思路就是在AND型信号量集的基础上进行扩充，在一次原语操作中完成所有的资源申请</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Swait（S1，t1，d1，…，Sn，tn，dn）（满足ti≥ di）    </span><br><span class="line">    if( S1 ≥t1 &amp;…&amp; Sn≥tn)&#123;  </span><br><span class="line">          for(  i =1; i&lt;=n; i++)&#123;</span><br><span class="line">                    Si ＝Si － di;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">          Place  the  executing  process  in  the  waiting  queue  of  the  first Si  with Si＜ti  and  set  its  program  counter  to  the  beginning  of  the  Swait  operation//将进程置于与在 Si&lt;ti 的条件下找到的**第一个** Si 关联的等待队列中，并将此过程的程序计数设置为 Swait 操作的开始</span><br><span class="line">    &#125;//end if</span><br><span class="line">&#125;//end Swait </span><br><span class="line"></span><br><span class="line"> Ssignal（S1，d1，···，Sn，dn）&#123;</span><br><span class="line">    for( i =1; i&lt;= n; i++)&#123;  </span><br><span class="line">        Si = Si + di；</span><br><span class="line">        Remove  all  the  process  waiting  in  the  queue  associated  with  Si  into  the  ready  queue//将与 Si 关联的队列中**所有**等待的进程移动到就绪队列中</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三种特例：</p>
<ol>
<li>Swait(S,d,d)：允许每次申请d个资源。当资源数少于d时，不予分配。</li>
<li>Swait (S,1,1)：S&gt;1，记录型信号量。S=1时，互斥型信号量。</li>
<li>Swait(S,1,0)，可控开关，当S&gt;=1时，允许进入，S&lt;1时，不能进入。</li>
</ol>
<h2 id="经典进程的同步问题"><a href="#经典进程的同步问题" class="headerlink" title="经典进程的同步问题"></a>经典进程的同步问题</h2><h3 id="生产者——消费者问题"><a href="#生产者——消费者问题" class="headerlink" title="生产者——消费者问题"></a>生产者——消费者问题</h3><h4 id="记录型信号量解决"><a href="#记录型信号量解决" class="headerlink" title="记录型信号量解决"></a>记录型信号量解决</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void producer( )&#123;</span><br><span class="line">    do&#123;</span><br><span class="line">		…</span><br><span class="line">		Produce an item in nextp;</span><br><span class="line">		…</span><br><span class="line">		wait(empty);</span><br><span class="line">		wait(mutex);</span><br><span class="line">		buffer(in):=nextp;</span><br><span class="line">		in:=(in+1) mod n;</span><br><span class="line">		signal(mutex);</span><br><span class="line">		signal(full);</span><br><span class="line">	&#125;while(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void consumer&#123;</span><br><span class="line">  do&#123;</span><br><span class="line">  		wait(full);</span><br><span class="line">		wait(mutex);</span><br><span class="line">		nextc:=buffer(out);</span><br><span class="line">		out:=(out+1) mod n;</span><br><span class="line">		signal(mutex);</span><br><span class="line">		signal(empty);</span><br><span class="line">		Consumer the item in nextc;</span><br><span class="line">		……</span><br><span class="line">	&#125;while(TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AND信号量解决"><a href="#AND信号量解决" class="headerlink" title="AND信号量解决"></a>AND信号量解决</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int  in=0, out=0;</span><br><span class="line">item    buffer[ n ];</span><br><span class="line">semaphore  mutex=1, empty=n, full=0;</span><br><span class="line">void producer( )&#123;</span><br><span class="line">	do&#123;</span><br><span class="line">		…</span><br><span class="line">		produce an item in nextp;</span><br><span class="line">		…</span><br><span class="line">		Swait(empty, mutex);</span><br><span class="line">		buffer[in] = nextp;</span><br><span class="line">		in = (in+1) % n;</span><br><span class="line">		Ssignal(mutex, full);</span><br><span class="line">	&#125;while(TRUE);</span><br><span class="line">&#125; //end producer</span><br><span class="line"></span><br><span class="line">void consumer&#123;</span><br><span class="line">	do&#123;</span><br><span class="line">		Swait(full, mutex);</span><br><span class="line">		nextc = buffer[out];</span><br><span class="line">		out = (out+1) % n;</span><br><span class="line">		Ssignal(mutex, empty);</span><br><span class="line">		consumer the item in nextc;</span><br><span class="line">	&#125;while(TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><p>几种解决方法：</p>
<ol>
<li>至多只允许有四位哲学家同时去拿左边的筷子，最终能保证至少有一位哲学家能够进餐，并在用毕时能释放出他用过的两只筷子，从而使更多的哲学家能够进餐。</li>
<li>仅当哲学家的左、右两只筷子均可用时，才允许他拿起筷子进餐。</li>
<li>规定奇数号哲学家先拿他左边的筷子，然后再去拿右边的筷子；而偶数号哲学家则相反。按此规定，将是1、 2号哲学家竞争1号筷子；3、4号哲学家竞争3号筷子。即五位哲学家都先竞争奇数号筷子，获得后，再去竞争偶数号筷子，最后总会有一位哲学家能获得两只筷子而进餐</li>
</ol>
<h4 id="AND信号量解决-1"><a href="#AND信号量解决-1" class="headerlink" title="AND信号量解决"></a>AND信号量解决</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[5]=&#123;1,1,1,1,1&#125;;</span><br><span class="line">do&#123;</span><br><span class="line">	……;</span><br><span class="line">	think;</span><br><span class="line">	Sswait(chopstick[(i+1) % 5],chopstick[i]);</span><br><span class="line">	eat;</span><br><span class="line">	Ssignal(chopstick[(i+1) % 5],chopstick[i]);</span><br><span class="line">&#125;while(TRUE);</span><br></pre></td></tr></table></figure>

<h3 id="读者——写者问题"><a href="#读者——写者问题" class="headerlink" title="读者——写者问题"></a>读者——写者问题</h3><h4 id="记录型信号量解决-1"><a href="#记录型信号量解决-1" class="headerlink" title="记录型信号量解决"></a>记录型信号量解决</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">semaphore rmutex=1, wmutex = 1;</span><br><span class="line">int readcount = 0;</span><br><span class="line"></span><br><span class="line">void reader( )&#123;</span><br><span class="line">	do&#123;</span><br><span class="line">		wait(rmutex);</span><br><span class="line">		if  readcount=0  then  wait(wmutex);</span><br><span class="line">		readcount:=readcount+1;</span><br><span class="line">		signal(rmutex);</span><br><span class="line">		…				</span><br><span class="line">		perform read operation</span><br><span class="line">		…</span><br><span class="line">		wait(rmutex);</span><br><span class="line">		readcount:=readcount-1;</span><br><span class="line">		if readcount=0  then signal(wmutex);</span><br><span class="line">		signal(rmutex);</span><br><span class="line">	&#125;while(TRUE);</span><br><span class="line">&#125;//end reader</span><br><span class="line"></span><br><span class="line">void writer( )&#123;</span><br><span class="line">	do&#123;</span><br><span class="line">		wait(wmutex)</span><br><span class="line">		perform write operation;</span><br><span class="line">		signal(wmutex)</span><br><span class="line">	&#125;while(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">	cobegin</span><br><span class="line">	reader(); writer();</span><br><span class="line">	coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="信号量集解决"><a href="#信号量集解决" class="headerlink" title="信号量集解决"></a>信号量集解决</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int RN;</span><br><span class="line">Semaphore L=RN, mx=1;</span><br><span class="line">//RN标示同时允许多少读进程存在</span><br><span class="line">void reader( )&#123;</span><br><span class="line">	   do&#123;</span><br><span class="line">              swait(L,1,1);</span><br><span class="line">              swait(mx,1,0);</span><br><span class="line">                   …</span><br><span class="line"> 	        perform read operation;</span><br><span class="line">		        …</span><br><span class="line">	         ssignal(L,1);</span><br><span class="line">        &#125;while(TRUE);</span><br><span class="line">&#125;//end reader</span><br><span class="line"></span><br><span class="line"> void writer( )&#123;</span><br><span class="line">        do&#123;</span><br><span class="line">             swait(mx,1,1; L,RN,0);</span><br><span class="line">             perform write operation;</span><br><span class="line">             ssignal(mx, 1);</span><br><span class="line">        &#125;while(TRUE);</span><br><span class="line"> &#125; //end writer</span><br><span class="line"></span><br><span class="line"> void main( )&#123;</span><br><span class="line">    cobegin</span><br><span class="line">       reader(); writer();</span><br><span class="line">    coedn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul>
<li><strong>共享存储器系统</strong> - 基于共享数据结构的通信方式。基于共享存储区的通信方式。</li>
<li><strong>消息传递系统</strong> - 是目前的主要通信方式，信息单位：消息（报文）实现：一组通信命令（原语），具有透明性、同步的实现。实现方式的不同，而分成：<br>   （1）直接通信方式<br>   （2）间接通信方式</li>
<li><strong>管道通信系统</strong> - 管道：连接一个读进程和一个写进程之间通信的共享文件。 功能：大量的数据发收。 注意：<pre><code>（1）互斥
（2）同步
（3）对方是否存在
</code></pre>
</li>
<li><strong>客户机服务器系统</strong></li>
</ul>
<h3 id="消息传递通信的实现方法"><a href="#消息传递通信的实现方法" class="headerlink" title="消息传递通信的实现方法"></a>消息传递通信的实现方法</h3><ul>
<li><p>直接通信方式<br>这是指发送进程利用OS所提供的发送命令，直接把消息发送给目标进程。<br>系统提供下述两条通信命令（<strong>原语</strong>）：<br>   Send  （Receiver，  message）；<br>   Receive（Sender，  message）； </p>
</li>
<li><p>间接通信方式<br>指进程之间利用信箱的通信方式。发送进程发送给目标进程的消息存放信箱；接收进程则从该信箱中，取出对方发送给自己的消息；消息在信箱中可以安全地保存，只允许核准的目标用户随时读取。<br>   系统为信箱通信提供了若干条<strong>原语</strong>，分别用于信箱的创建、撤消和消息的发送、接收等。优点：在读/写时间上的随机性<br>信箱分为以下三类：<br>（1）私用信箱<br>（2）公用信箱<br>（3）共享信箱<br>在利用信箱通信时，在发送进程和接收进程之间，存在以下四种关系：<br>（1）一对一关系。<br>（2）多对一关系，客户/服务器交互。<br>（3）一对多关系， 广播方式。<br>（4）多对多关系。</p>
</li>
</ul>
<h3 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h3><p>消息头：含控制信息如：收/发进程名，消息长度、类型、编号<br>消息内容：<br>    定长消息：系统开销小，用户不便（特别是传长消息用户）<br>    变长消息：开销大，用户方便。</p>
<h3 id="消息格式进程同步方式"><a href="#消息格式进程同步方式" class="headerlink" title="消息格式进程同步方式"></a>消息格式进程同步方式</h3><p>1）发送和接收进程阻塞（汇合）用于紧密同步，无缓冲区时。<br>2）发送进程不阻塞，接收进程阻塞（多个）相当于接收进程（可能是多个）一直等待发送进程，如：打印进程等待打印任务。<br>3）发送/接收进程均不阻塞一般在发、收进程间有多个缓冲区时。</p>
<h2 id="进程运行与监控"><a href="#进程运行与监控" class="headerlink" title="进程运行与监控"></a>进程运行与监控</h2><h3 id="Linux进程控制块"><a href="#Linux进程控制块" class="headerlink" title="Linux进程控制块"></a>Linux进程控制块</h3><h4 id="task-struct结构"><a href="#task-struct结构" class="headerlink" title="task_struct结构"></a>task_struct结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pid_t pid;</span><br><span class="line">uid_t uid,euid; </span><br><span class="line">gid_t gid,egid;</span><br><span class="line">volatile long state;</span><br><span class="line">int exit_state;</span><br><span class="line">unsigned int rt_priority;</span><br><span class="line">unsigned int policy;</span><br><span class="line">struct list_head tasks;</span><br><span class="line">struct task_struct *real_parent;</span><br><span class="line">struct task_struct *parent;</span><br><span class="line">struct list_head children,sibling;</span><br><span class="line">struct fs_struct *fs;</span><br><span class="line">struct files_struct *files;</span><br><span class="line">struct mm_struct *mm;</span><br><span class="line">struct signal_struct *signal;</span><br><span class="line">struct sighand_struct *sighand;</span><br><span class="line">cputime_t utime, stime;</span><br><span class="line">struct timespec start_time;</span><br><span class="line">struct timespec real_start_time;</span><br></pre></td></tr></table></figure>

<h4 id="task-struct-进程状态"><a href="#task-struct-进程状态" class="headerlink" title="task_struct:进程状态"></a>task_struct:进程状态</h4><p>——<code>volatile long state;</code><br>state成员的可能取值如下： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define TASK_RUNNING	0  </span><br><span class="line">#define TASK_INTERRUPTIBLE	1  </span><br><span class="line">#define TASK_UNINTERRUPTIBLE	2  </span><br><span class="line">#define TASK_ZOMBIE	4  </span><br><span class="line">#define TASK_STOPPED	8</span><br></pre></td></tr></table></figure>

<h4 id="进程状态切换"><a href="#进程状态切换" class="headerlink" title="进程状态切换"></a>进程状态切换</h4><p><img src="/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1-3)/1646809311457.png"></p>
<h4 id="task-struct-文件管理"><a href="#task-struct-文件管理" class="headerlink" title="task_struct:文件管理"></a>task_struct:文件管理</h4><p><img src="/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1-3)/1647413678022.png"></p>
<h3 id="进程的启动"><a href="#进程的启动" class="headerlink" title="进程的启动"></a>进程的启动</h3><p>UNIX&amp;Linux中创建进程的方式：</p>
<ul>
<li><p>在shell中执行命令或可执行文件由shell进程调用fork函数创建子进程</p>
</li>
<li><p>在代码中（已经存在的进程中）调用fork函数创建子进程，fork创建的进程为子进程，原进程为父进程</p>
</li>
<li><p>Linux系统中进程0 （PID=0）是由内核创建，其他所有进程都是由父进程调用fork函数所创建的。进程0在创建子进程（PID=1，init进程）后，进程0就转为交换进程或空闲进程</p>
</li>
<li><p>进程1（init进程）是系统中其他所有进程的共同祖先</p>
</li>
</ul>
<h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><p><code>#include&lt;unistd.h&gt;</code>头文件定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* Clone the calling process, creating an exact copy.</span><br><span class="line">	Return -1 for errors, 0 to the new process,</span><br><span class="line">	and the process ID of the new process to the old process.  */</span><br></pre></td></tr></table></figure>
<p>fork函数被正确调用后，将会在子进程中和父进程中分别返回</p>
<ul>
<li>在子进程中返回值为0（不合法的PID，提示当前运行在子进程中）</li>
<li>在父进程中返回值为子进程ID（让父进程掌握所创建子进程的ID号）</li>
<li>出错返回-1</li>
</ul>
<p>子进程是父进程的副本</p>
<ul>
<li>子进程复制/拷贝父进程的PCB、用户空间（数据段、堆和栈）</li>
<li>父子进程共享正文段（只读）<br>父进程继续执行fork函数调用之后的代码，子进程也从fork函数调用之后的代码开始执行为了提高效率，fork后不并立即复制父进程数据段、堆和栈，采用了写时复制机制（Copy-On-Write）：当父子进程任意之一要修改数据段、堆、栈时，进行复制操作，并且仅复制修改区域</li>
</ul>
<p>子进程复制父进程的进程控制块</p>
<ul>
<li>父进程的文件描述符表被子进程复制，父子进程的同一文件描述符<strong>指向同一个文件表</strong></li>
<li>父子进程对同一文件访问基于<strong>相同的文件当前位置</strong></li>
</ul>
<p>父子进程对共享文件的常见处理方式：</p>
<ul>
<li>父进程等待子进程完成。当子进程终止后，文件当前位置已经得到了相应的更新</li>
<li>父子进程各自执行不同的程序段，各自关闭不需要的文件</li>
</ul>
<p>vfork函数保证子进程先执行，在它调用exec或者exit之后，父进程才会继续被调度执行（父进程处于TASK_UNINTERRUPTIBLE状态）</p>
<h4 id="进程内存空间布局"><a href="#进程内存空间布局" class="headerlink" title="进程内存空间布局"></a>进程内存空间布局</h4><ul>
<li>命令行参数和环境变量 - 主要用于支撑函数调用 存放参数、局部变量等</li>
<li>堆栈 - 用于动态分配内存</li>
<li>未初始化的数据 - 程序执行之前，将此段中 的数据初始化为0，如 全局变量long sum[1000];</li>
<li>初始化的数据 - 包含了程序中需明确赋 初值的变量，如全局变量 int maxcount=99;</li>
<li>正文 - CPU执行的代码部分，正文 段通常是共享、只读的</li>
</ul>
<h3 id="进程的运行控制"><a href="#进程的运行控制" class="headerlink" title="进程的运行控制"></a>进程的运行控制</h3><h4 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h4><p>设置环境变量的三种方法： </p>
<ul>
<li>putenv - 将环境变量字符串放入环境变量表中</li>
<li>setenv - 将指定环境变量的值设置为参数指定值</li>
<li>unsetenv - 删除指定的环境变量字符串</li>
</ul>
<h4 id="exec系列函数"><a href="#exec系列函数" class="headerlink" title="exec系列函数"></a>exec系列函数</h4><p>进程调用exec系列函数在进程中加载执行另外一个可执行文件<br>exec系列函数替换了当前进程（执行该函数的进程）的正文段、数据段、堆和栈（来源于加载的可执行文件），但并不修改PCB！<br>执行exec系列函数后从加载可执行文件的main函数开始重新执行<br>exec系列函数<strong>并不创建新进程</strong>，所以在调用exec系列函数后其进程ID(uid)并未改变，已经打开的文件描述符不变</p>
<p>execl execle execlp execv execve execvp<br>六个函数开头均为exec，所以称为exec系列函数</p>
<ul>
<li>l：表示list，每个命令行参数都说明为一个单独的参数</li>
<li>v：表示vector，命令行参数放在数组中</li>
<li>e：表示由函数调用者提供环境变量表</li>
<li>p：表示通过环境变量PATH来指定路径，查找可执行文件</li>
</ul>
<h3 id="进程的监测"><a href="#进程的监测" class="headerlink" title="进程的监测"></a>进程的监测</h3><h4 id="终止进程函数"><a href="#终止进程函数" class="headerlink" title="终止进程函数"></a>终止进程函数</h4><p>头文件stdlib.h定义：void  exit( int  status )<br>头文件unistd.h定义：void  _exit (int  status ）<br>调用这两个函数均会正常地终止一个进程<br>调用 <strong>_exit</strong> 函数将会<strong>立即</strong>返回内核<br>调用 <strong>exit</strong> 函数执行一些预先注册的终止处理函数,执行文件I/O操作的善后工作，使得所有缓冲的输出数据被更新到相应的设备,返回内核</p>
<h4 id="获知子进程状态改变"><a href="#获知子进程状态改变" class="headerlink" title="获知子进程状态改变"></a>获知子进程状态改变</h4><ul>
<li>主动获取 - 调用wait或waitpid函数等待子进程状态信息改变，并获取其状态信息</li>
<li>异步通知 - 当一个进程发生特定的状态变化（进程终止、暂停以及恢复）时，内核向其父进程发送SIGCHLD信号，父进程可以选择忽略该信号，也可以对信号进行处理（默认处理方式为忽略该信号）</li>
</ul>
<p>僵尸进程：<br>进程在退出之前会释放进程用户空间的所有资源，但PCB等内核空间资源不会被释放。当父进程调用wait或waitpid函数后，内核将根据情况<strong>关闭</strong>该进程打开的所有文件。而对于已经终止但父进程尚未对其调用wait或waitpid函数的进程（TASK_ZOMBIE状态），称为僵尸进程。</p>
<p>孤儿进程：<br>如果 <strong>父进程在子进程终止之前终止</strong>，则子进程的父进程将变为init进程，保证每个进程都有父进程，由init进程调用wait函数进行善后</p>
<h5 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h5><p>头文件：sys/wait.h<br>功能：获取任意子进程的状态改变信息（如果是终止状态则对子进程进行善后处理）<br><code>pid_t wait(int *statloc); </code><br>参数statloc：用于存储子进程的状态改变信息<br>若成功返回状态信息改变的子进程ID，出错返回-1<br>子进程状态改变信息包含了多种类型的信息，可以通过<strong>系统提供的宏</strong>来快速解析子进程的状态<br>如：<br>| 宏 | 功能说明 |<br>| — | — |<br>| WIFEXITED(statloc) | 当子进程正常终止时该宏为真，对于这种情况可进一步执行WEXITSTATUS(statloc)，获取子进程传递给exit、_exit函数参数的低8位 |<br>| WIFSIGNALED(statloc) | 当子进程异常终止时该宏为真，对于这种情况可进一步执行WTERMSTG(statloc)，获取使子进程终止的信号编号 |<br>| WIFSTOPPED(statloc) | 当子进程暂停时该宏为真，对于这种情况可进一步执行WSTOPSIG(statloc)，获取使子进程暂停的信号编号 |<br>| WIFCONTINUED(statloc) | 若子进程在暂停后已经继续则该宏为真 |</p>
<p>如果一个进程有几个子进程，那么只要有一个子进程状态改变，wait函数就返回</p>
<p>如何才能使用wait函数等待某个<strong>特定</strong>子进程的状态改变？</p>
<ol>
<li>调用wait，然后将其返回的进程ID和所期望的子进程ID进行比较</li>
<li>如果ID不一致，则保存该ID，并循环调用wait函数，直到等到所期望的子进程ID为止</li>
</ol>
<h5 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h5><p>功能：等待某个<strong>特定</strong>子进程状态改变<br><code>pid_t waitpid(pid_t pid, int *statloc, int options);</code><br>参数：</p>
<ul>
<li>pid：pid == -1：等待任意子进程状态改变（同wait）；pid &gt; 0：等待进程ID为pid的子进程状态改变；pid == 0：等待其组ID等于调用进程组ID的任意子进程；pid &lt; -1：等待其组ID等于pid绝对值的任意子进程</li>
<li>statloc：用于存储子进程的状态改变信息</li>
<li>options：可以为0，也可以是以下常量：WNOHANG：如果没有任何已经终止的子进程则马上返回, 函数不等待，此时返回值为0；WUNTRACED：用于跟踪调试<br>成功返回终止子进程ID，失败返回-1</li>
</ul>
<p>waitpid可以实现非阻塞的等待操作，有时希望取得子进程的状态改变信息，但不希望阻塞父进程等待子进程状态改变</p>
<h2 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h2><ol>
<li>在一个已有进程中<strong>创建</strong>一个新线程比创建一个全新进程所需的时间少。</li>
<li><strong>终止</strong>一个线程比终止一个进程花费的时间少。</li>
<li>线程间<strong>切换</strong>比进程间切换花费的时间少。</li>
<li>线程提高了不同的执行程序间<strong>通信</strong>的效率。同一个进程中的线程共享存储空间和文件，它们无需调用内核就可以互相通信。</li>
</ol>
<h3 id="线程的引入"><a href="#线程的引入" class="headerlink" title="线程的引入"></a>线程的引入</h3><p>引入进程是为了使多个程序能够并发执行，以提高资源利用率和系统吞吐量；<br>引入线程是为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性<br> 进程的两个基本属性</p>
<ul>
<li>一个可拥有资源的独立单位</li>
<li>一个可调度和分派的基本单位</li>
</ul>
<p>调度和分派的部分通常称为<strong>线程</strong>或轻型进程，而资源所有权的部分通常称为<strong>进程</strong>。</p>
<h3 id="线程与进程的比较"><a href="#线程与进程的比较" class="headerlink" title="线程与进程的比较"></a>线程与进程的比较</h3><p>从调度性、并发性、系统开销和拥有资源等方面对线程和进程进行比较。<br>（线程必须在某个进程内执行 一个进程可以包含一个线程或多个线程）</p>
<h4 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h4><p>在传统的操作系统中，进程作为拥有资源和独立调度、分派的基本单位。而在引入线程的操作系统中，则把线程作为调度和分派的基本单位，而进程作为资源拥有的基本单位。</p>
<h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可并发执行，使得操作系统具有更好的并发性，从而能更加有效地提高系统资源的利用率和系统的吞吐量。</p>
<h4 id="拥有资源"><a href="#拥有资源" class="headerlink" title="拥有资源"></a>拥有资源</h4><p>一般而言，线程<strong>自己不拥有系统资源</strong>(也有一点必不可少的资源)，但它可以访问其隶属进程的资源，即一个进程的代码段、数据段及所拥有的系统资源，如已打开的文件、I/O 设备等，可以<strong>供</strong>该进程中的所有线程所共享。</p>
<h4 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h4><p>同一进程中的不同线程共享进程的内存空间和资源。<br>同一进程中的<strong>不同线程</strong>的独立性低于<strong>不同进程</strong>。</p>
<h4 id="系统开销"><a href="#系统开销" class="headerlink" title="系统开销"></a>系统开销</h4><p>线程的切换只需要保存和设置少量的寄存器内容，不涉及存储器管理方面的操作。<br>由于一个进程中的多个线程具有相同的地址空间，在同步和通信的实现方面线程也比进程容易。在一些操作系统中，线程的切换、同步和通信都无须操作系统内核的干预。（少）</p>
<h4 id="支持多处理机系统"><a href="#支持多处理机系统" class="headerlink" title="支持多处理机系统"></a>支持多处理机系统</h4><p>一个进程分为多个线程分配到多个处理机上并行执行，可加速进程的完成。</p>
<h3 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h3><ol>
<li>轻型实体<br> 线程自己基本不拥有系统资源，只拥有少量必不可少的资源：TCB，程序计数器、一组寄存器、栈。</li>
<li>独立调度和分派的基本单位<br> 在多线程OS中,线程是独立运行的基本单位,因而也是独立调度和分派的基本单位。</li>
<li>可并发执行<br> 同一进程中的多个线程之间可以并发执行，一个线程可以创建和撤消另一个线程。</li>
<li>共享进程资源<br> 它可与同属一个进程的其它线程共享进程所拥有的全部资源。</li>
</ol>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>同进程一样，线程之间也存在共享资源和相互合作的制约关系，致使线程在运行时也具有间断性。<br>线程运行时有以下3种状态：<br>①<strong>执行</strong>状态:表示线程正获得CPU而运行；<br>②<strong>就绪</strong>状态:表示线程已具备了各种运行条件，一旦获得CPU便可执行；<br>③<strong>阻塞</strong>状态:表示线程在运行中因某事件而受阻，处于暂停执行的状态；</p>
<h3 id="线程的组成"><a href="#线程的组成" class="headerlink" title="线程的组成"></a>线程的组成</h3><p>每个线程有一个TCB结构，即线程控制块，用于保存自己私有的信息，主要由以下部分组成：</p>
<ul>
<li>一个唯一的线程标识符；</li>
<li>一组寄存器 ：包括程序计数器、状态寄存器、通用寄存器的内容；</li>
<li>线程运行状态：用于描述线程正处于何种运行状态；</li>
<li>优先级：描述线程执行的优先程度；</li>
<li>线程专有存储器：用于保存线程自己的局部变量拷贝；</li>
<li>信号屏蔽：对某些信号加以屏蔽；</li>
<li>两个栈指针：核心栈、用户栈。</li>
</ul>
<h3 id="进程线程对比"><a href="#进程线程对比" class="headerlink" title="进程线程对比"></a>进程线程对比</h3><table>
<thead>
<tr>
<th>应用功能</th>
<th>线程</th>
<th>进程</th>
</tr>
</thead>
<tbody><tr>
<td>创建</td>
<td>pthread_create</td>
<td>fork,vfork</td>
</tr>
<tr>
<td>退出</td>
<td>pthread_exit</td>
<td>exit</td>
</tr>
<tr>
<td>等待</td>
<td>pthread_join</td>
<td>wait、waitpid</td>
</tr>
<tr>
<td>取消/终止</td>
<td>pthread_cancel</td>
<td>abort</td>
</tr>
<tr>
<td>读取ID</td>
<td>pthread_self()</td>
<td>getpid()</td>
</tr>
<tr>
<td>同步互斥/通信机制</td>
<td>互斥锁、条件变量、读写锁</td>
<td>无名管道、有名管道、信号、消息队列、信号量、共享内存</td>
</tr>
</tbody></table>
<h3 id="线程间的同步和通信"><a href="#线程间的同步和通信" class="headerlink" title="线程间的同步和通信"></a>线程间的同步和通信</h3><p>▪为使系统中的多线程能有条不紊的运行，系统必须提供用于实现线程间同步和通信的机制。在多线程OS中，通常提供多种同步机制:</p>
<ul>
<li>互斥锁(mutex) - 互斥锁是一种比较简单的、用于实现进程间对资源互斥访问的机制。 由于操作互斥锁的时间和空间开销都较低，因而较适合于高频度使用的关键共享数据和程序段。</li>
<li>条件变量 - 每一个条件变量通常都与一个互斥锁一起使用。 单纯的互斥锁用于短期锁定，主要是用来保证对临界区的互斥进入。而条件变量则用于线程的长期等待， 直至所等待的资源成为可用的。</li>
<li>信号量机制 - 当某线程需利用信号量来实现同一进程中各线程之间的同步时，可调用创建信号量的命令来创建一私用信号量，其数据结构存放在应用程序的地址空间中。</li>
</ul>
<h2 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h2><h3 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h3><p>用户级线程仅存在于用户空间中。对于这种线程的创建、撤消、线程之间的同步与通信等功能，都无须内核来实现。<br>优点：</p>
<ul>
<li>线程切换<strong>不调用内核</strong></li>
<li>调度是应用程序特定的：可以选择<strong>最好的算法</strong></li>
<li>可运行在任何操作系统上（只需要线程库），可以在一个<strong>不支持线程的OS</strong>上实现<br>缺点：</li>
<li>当线程执行一个系统调用时，该线程及其所属进程内的所有线程都会<strong>被阻塞</strong>。</li>
<li>多线程应用<strong>不能利用</strong>多处理机进行多重处理。</li>
</ul>
<h3 id="内核支持线程"><a href="#内核支持线程" class="headerlink" title="内核支持线程"></a>内核支持线程</h3><p>内核支持线程，是在内核的支持下运行的，即无论是用户进程中的线程，还是系统进程中的线程，他们的创建、撤消和切换等，是依靠内核实现的。<br>优点：</p>
<ul>
<li>在多处理器系统中，内核能够<strong>同时</strong>调度同一进程中多个线程并行执行；</li>
<li>如果进程中的一个线程被阻塞了，内核<strong>可以</strong>调度该进程中的其它线程占有处理器运行，也可以运行其它进程中的线程；</li>
<li>内核支持线程具有很小的数据结构和堆栈，线程的切换比较<strong>快</strong>，切换<strong>开销小</strong>；</li>
<li>内核本身也可以采用多线程技术，可以提高系统的执行<strong>速度和效率</strong>。<br>缺点：<br>对于线程切换而言，其模式切换的开销较大 在同一个进程中，从一个线程切换到另一个线程时，需要<strong>从用户态转到内核态再转到用户态</strong>进行，这是因为用户进程的线程在用户态运行，而线程调度和管理是在内核实现的，系统开销较大。</li>
</ul>
<h3 id="组合方式"><a href="#组合方式" class="headerlink" title="组合方式"></a>组合方式</h3><p>用户级线程是在用户空间实现的。所有用户级线程都具有相同的数据结构，它们都运行在一个中间系统上：<br>运行时系统（又称为线程库）<br>内核控制线程又称为轻型进程LWP<br><img src="/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1-3)/1647413220791.png" alt="enter description here"></p>
<h2 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h2><ol>
<li><p>什么是前趋图？为什么要引入前趋图？<br>指一个有向无环图，用于描述进程之间执行的先后顺序</p>
</li>
<li><p>画出前趋图：S1:a=x+y;S2:b=z+1;S3:c=a-b;S4:w=c+1;<br><img src="/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1-3)/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" alt="未命名文件"></p>
</li>
<li><p>为什么要引入进程，会产生什么影响？<br>为了使程序并发的执行，并且可以对并发执行的程序加以描述与控制；使程序可以并发执行</p>
</li>
<li><p>从动态性、并发性和独立性的角度比较进程和程序<br>动态性：进程的实质是进程实体的执行过程，具有生命周期。而程序是静态的一组有序指令集。<br>并发性：进程可以并发执行。程序没有建立PCB不能并发执行。<br>独立性：进程是一个能够独立运行的、独立获得资源的、独立接受调度的基本单位。未建立PCB的程序不能独立参与运行</p>
</li>
<li><p>PCB的作用？为什么说PCB是进程唯一标志<br>PCB是进程实体的一部分，PCB使一个程序成为能够独立运行的基本单位，PCB描述进程的基本情况和活动过程，进而控制和管理进程。操作系统是通过PCB来对进程进行控制和管理的。</p>
</li>
<li><p>进程的三个基本状态转化原因<br>有1就绪状态——执行状态：进程调度<br>执行状态——就绪状态：时间片完成<br>执行状态——阻塞状态：I/O请求<br>阻塞状态——就绪状态：I/O完成</p>
</li>
<li><p>为什么要引入挂起状态，有什么性质？<br>有终端用户需求、父进程请求、负荷调节的需要、操作系统的需要；挂起状态进程静止不能被调度</p>
</li>
<li><p>进程切换时要保存的处理器状态信息有哪些？<br>通用寄存器、指令寄存器、程序状态寄存器、用户栈指针</p>
</li>
<li><p>引起进程创建的主要事件<br>用户登录、作业调度、提供服务、应用请求</p>
</li>
<li><p>引起进程撤销的主要事件<br>正常结束、异常结束（越界错、保护错、非法指令、特权指令错、运行超时、等待超时、算数运算错、I/O故障）、外界干扰（操作员或操作系统干预、父进程请求、因父进程终止而终止）</p>
</li>
<li><p>创建进程时所要完成的主要工作<br>申请空白PCB、为新进程分配资源、初始化PCB、插入就绪队列</p>
</li>
<li><p>引起进程阻塞或被唤醒的主要事件<br>请求共享资源失败、等待某种操作、新数据尚未到达、等待新任务</p>
</li>
<li><p>从调度性、并发性、拥有资源及系统开销方面对比进程与线程<br>调度性：线程作为调度和分派的基本单位，而进程作为资源拥有的基本单位。<br>并发性：均可并发执行。<br>拥有资源：进程是拥有资源的基本单位，线程只拥有必不可少的资源，本身不拥有系统资源，但可以访问隶属资源。<br>系统开销：在创建、撤销和切换进程的开销显著大于线程。</p>
</li>
<li><p>解释用户级线程与内核支持线程<br>用户级线程：用户级线程仅存在于用户空间中。对于这种线程的创建、撤消、线程之间的同步与通信等功能，都无须内核来实现。<br>内核支持线程：内核支持线程，是在内核的支持下运行的，即无论是用户进程中的线程，还是系统进程中的线程，他们的创建、撤消和切换等，是依靠内核实现的。</p>
</li>
</ol>
<h1 id="处理机调度与死锁"><a href="#处理机调度与死锁" class="headerlink" title="处理机调度与死锁"></a>处理机调度与死锁</h1><h2 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h2><ul>
<li>高级调度 - 又称长程调度或作业调度，将外存作业调入内存，创建PCB等，插入就绪队列。用于批处理系统。调度最慢</li>
<li>低级调度 - 又称进程调度或短程调度，决定就绪队列中的那个进程应获得处理机，并将处理机分配给选中的进程。调度最频繁</li>
<li>中级调度 - 又称内存调度，把外存上那些已经具备运行条件的就绪进程重新载入内存。从静止就绪到活动就绪。</li>
</ul>
<h2 id="处理机调度算法的目标"><a href="#处理机调度算法的目标" class="headerlink" title="处理机调度算法的目标"></a>处理机调度算法的目标</h2><h3 id="共同目标："><a href="#共同目标：" class="headerlink" title="共同目标："></a>共同目标：</h3><ul>
<li>资源利用率：使系统处理器和资源尽可能忙碌</li>
<li>公平性：为进程合理分配CPU时间，不会发生饥饿</li>
<li>平衡性：为不同类型进程平衡分配资源</li>
<li>策略强制执行：如安全策略可无条件准确执行</li>
</ul>
<h3 id="批处理系统的目标"><a href="#批处理系统的目标" class="headerlink" title="批处理系统的目标"></a>批处理系统的目标</h3><ul>
<li>平均周转时间短</li>
<li>系统吞吐量高：尽量多地选择短作业运行</li>
<li>处理机利用率高：尽量选择计算量大的作业</li>
</ul>
<h3 id="分时系统的目标"><a href="#分时系统的目标" class="headerlink" title="分时系统的目标"></a>分时系统的目标</h3><ul>
<li>响应时间快</li>
<li>均衡性：指系统响应时间的长短应与用户所请求服务的复杂性相适应。</li>
</ul>
<h3 id="实时系统的目标"><a href="#实时系统的目标" class="headerlink" title="实时系统的目标"></a>实时系统的目标</h3><ul>
<li>截至时间的保证：开始截止时间 完成截止时间 硬实时、软实时</li>
<li>可以预测性：对调度结果的可预见性</li>
</ul>
<h2 id="作业与作业调度"><a href="#作业与作业调度" class="headerlink" title="作业与作业调度"></a>作业与作业调度</h2><ul>
<li>作业 Job：用户提交给系统的一项相对独立的工作。程序+数据+作业说明书</li>
<li>作业步：在作业运行期间，每个作业都必须经过若干个相对独立，又相互关联的顺序加工步骤才能得到结果，每一个加工步骤称为一个作业步，各作业步之间存在着相互联系。</li>
<li>作业流：依次执行的作业步，作业步间非并行的。</li>
</ul>
<h3 id="作业控制块-JCB"><a href="#作业控制块-JCB" class="headerlink" title="作业控制块(JCB)"></a>作业控制块(JCB)</h3><p>作业在系统中存在的标志，保存了系统对作业进行管理和调度的全部信息。<br>通常包含：</p>
<ul>
<li>作业标识</li>
<li>用户名称</li>
<li>用户账号</li>
<li>作业类型(CPU 繁忙型、I/O 繁忙型、批量型、终端型)</li>
<li>作业状态</li>
<li>调度信息(CPU 繁忙型、I/O 繁忙型、批量型、终端型)</li>
<li>资源需求(预计运行时间、要求内存大小、要求 I/O 设备的类型和数量等)</li>
<li>资源使用情况等</li>
</ul>
<h3 id="作业运行的三个阶段和三种状态"><a href="#作业运行的三个阶段和三种状态" class="headerlink" title="作业运行的三个阶段和三种状态"></a>作业运行的三个阶段和三种状态</h3><p>收容阶段：后备状态<br>运行阶段：运行状态<br>完成阶段：完成状态</p>
<h3 id="作业调度的主要任务"><a href="#作业调度的主要任务" class="headerlink" title="作业调度的主要任务"></a>作业调度的主要任务</h3><ul>
<li>接纳多少个作业：太多会影响系统服务质量，如延长周转时间；太少会导致资源利用率和系统吞吐量太低</li>
<li>接纳哪些作业：将哪些作业从外存调入内存，取决于所采用的调度算法</li>
</ul>
<h3 id="先来先服务-FCFS-和短作业优先-SJF-调度算法"><a href="#先来先服务-FCFS-和短作业优先-SJF-调度算法" class="headerlink" title="先来先服务(FCFS)和短作业优先(SJF )调度算法"></a>先来先服务(FCFS)和短作业优先(SJF )调度算法</h3><p>在作业调度中是从后备队列调入内存运行。<br>在进程调度中则是从就绪队列中选出估计运行时间最短的进程分配处理机使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时，再重新调度。</p>
<h4 id="先来先服务："><a href="#先来先服务：" class="headerlink" title="先来先服务："></a>先来先服务：</h4><p>既可用于作业调度，也可用于进程调度。有利于长作业（进程），而不利于短作业（进程）。</p>
<h4 id="短作业-进程-优先调度算法SJ-P-F："><a href="#短作业-进程-优先调度算法SJ-P-F：" class="headerlink" title="短作业(进程)优先调度算法SJ(P)F："></a>短作业(进程)优先调度算法SJ(P)F：</h4><p>是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。<br>对长作业不利，不能保证紧迫性作业(进程)会被及时处理，根据用户所提供的估计执行时间而定不准确。</p>
<h3 id="优先级调度算法和高响应比优先调度算法"><a href="#优先级调度算法和高响应比优先调度算法" class="headerlink" title="优先级调度算法和高响应比优先调度算法"></a>优先级调度算法和高响应比优先调度算法</h3><p>优先级调度算法：<br>外部赋予作业（进程）相应的优先级，例如以作业的紧迫程度作为优先级。<br>选择优先级高的进程投入运行。既可用于作业调度算法，也可用于进程调度。</p>
<p>高响应比优先调度算法：<br>赋予作业动态优先级，优先级随作业等待时间延长而增加，从而使长作业的优先级在等待期间不断增加。<br>响应比Rp：<br><img src="/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1-3)/1647848472429.png" alt="enter description here"><br>算法既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务</p>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="主要任务"><a href="#主要任务" class="headerlink" title="主要任务"></a>主要任务</h3><ul>
<li>保存处理机的现场信息</li>
<li>按某种算法选取进程</li>
<li>把处理机分配给进程<strong>strong text</strong></li>
</ul>
<h3 id="进程调度机制"><a href="#进程调度机制" class="headerlink" title="进程调度机制"></a>进程调度机制</h3><p><img src="/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1-3)/1647853007722.png" alt="enter description here"></p>
<h3 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h3><h4 id="非抢占方式："><a href="#非抢占方式：" class="headerlink" title="非抢占方式："></a>非抢占方式：</h4><p>一旦进程投入运行，除了进程完成或者需要阻塞外，不能剥夺其处理机。<br>采用这种方式时，引起调度的原因可归结为： </p>
<ul>
<li>进程运行完毕或因发生某事件而无法继续运行</li>
<li>因I/O请求而阻塞</li>
<li>因通信或者同步而阻塞</li>
</ul>
<h4 id="抢占方式："><a href="#抢占方式：" class="headerlink" title="抢占方式："></a>抢占方式：</h4><p>允许根据某种原则，暂停正在执行的进程，重新分配处理机。<br>使用抢占式的原因： </p>
<ul>
<li>批处理：防止长进程长期占用CPU，公平</li>
<li>分时：人机交互</li>
<li>实时：紧迫任务的执行<br>主要原则</li>
<li>优先权</li>
<li>短进程优先</li>
<li>时间片原则</li>
</ul>
<h3 id="轮转调度算法-RR"><a href="#轮转调度算法-RR" class="headerlink" title="轮转调度算法(RR)"></a>轮转调度算法(RR)</h3><p>基于时间片轮转<br>原理： FCFS策略+时钟中断+时间片原则<br>时间片太小：利于短作业，但增大调度和上下文切换频率，增大系统开销； 时间片太长：退化为FCFS算法。 时间片合适：略大于一次典型的交互所需的时间，使大多数交互式进程能在一个时间片内完成。<br>当进程的时间片耗尽或运行完毕，系统将CPU分配给队首进程（或新到达紧迫进程）</p>
<h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h3><p>同样分为非抢占式和抢占式<br>对于优先级是的设立还分为静态优先权（简单，但低优先权作业可能长期不被调度）和动态优先权（长短兼顾 缺点：需计算 Rp=(等待时间＋服务时间)/服务时间 ）</p>
<h3 id="多队列调度算法"><a href="#多队列调度算法" class="headerlink" title="多队列调度算法"></a>多队列调度算法</h3><p>针对：不同用户的调度策略需求:实时/分时/批处理混合系统<br>和多CPU单就绪队列的问题:互斥访问导致效率不高<br>解决办法:<br>不同类型或者性质的进程组织在不同的队列中<br>每个CPU和一个队列，分配优化，CPU间队列均衡</p>
<h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><p>设置多个就绪队列，并为各个队列赋予不同的优先级。<br>优先级愈高的队列的进程的执行时间片就愈小。<br>新进程首先进入最高优先级的队列。每个队列采用FCFS算法。<strong>队列中的进程运行一个时间片后未结束则降级排到下一个队列的末尾</strong>。最低优先权队列中的进程则按RR方式运行。<br>按队列优先级调度。只有比队列的优先级高的队列均空时，才运行该队列中的进程。<br>特点：长、短作业兼顾，有较好的响应时间</p>
<h3 id="基于公平原则的调度算法"><a href="#基于公平原则的调度算法" class="headerlink" title="基于公平原则的调度算法"></a>基于公平原则的调度算法</h3><ol>
<li>保证调度算法 - 保证的是绝对运行时间，即启动后在某个时间段内必须获得多少运行时间。 例如N个进程平均分配时间。</li>
<li>公平分享调度算法 - 按照用户数量平均分配时间，而不是进程间平均分配。</li>
</ol>
<h2 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h2><p>实时调度必须满足实时任务对截至时间的要求</p>
<h3 id="实现实时调度的基本条件"><a href="#实现实时调度的基本条件" class="headerlink" title="实现实时调度的基本条件"></a>实现实时调度的基本条件</h3><ul>
<li>就绪时间</li>
<li>开始截止时间和完成截止时间</li>
<li>处理时间</li>
<li>资源要求</li>
<li>优先级</li>
</ul>
<p>单处理机条件下必须保证处理时间与截至时间之比小于1</p>
<h3 id="实时调度算法的分类"><a href="#实时调度算法的分类" class="headerlink" title="实时调度算法的分类"></a>实时调度算法的分类</h3><h4 id="非抢占式"><a href="#非抢占式" class="headerlink" title="非抢占式"></a>非抢占式</h4><p><img src="/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1-3)/1647855224272.png" alt="enter description here"></p>
<ol>
<li>非抢占式轮转调度</li>
<li>非抢占式优先调度</li>
</ol>
<h4 id="抢占式"><a href="#抢占式" class="headerlink" title="抢占式"></a>抢占式</h4><ol>
<li>基于时钟中断的抢占式</li>
<li>立即抢占式</li>
</ol>
<h3 id="EDF最早截至时间算法"><a href="#EDF最早截至时间算法" class="headerlink" title="EDF最早截至时间算法"></a>EDF最早截至时间算法</h3><p>就绪队列按各任务截止时间的早晚排序；具有最早截止时间的任务排在队列的最前面。</p>
<h3 id="LLF最低松弛度优先算法"><a href="#LLF最低松弛度优先算法" class="headerlink" title="LLF最低松弛度优先算法"></a>LLF最低松弛度优先算法</h3><p>松弛度=完成截至时间–剩余运行时间–当前时间<br>按松弛度排序实时任务的就绪队列，松弛度值最小的任务排在队列最前面</p>
<h3 id="优先级倒置"><a href="#优先级倒置" class="headerlink" title="优先级倒置"></a>优先级倒置</h3><p>即高优先级进程(或线程)被低优先级进程(或线程)延迟或阻塞。<br>主要原因可能是较低优先级任务占用临界资源后未释放而切换任务执行<br>解决方法：</p>
<ul>
<li>规定进入临界区后不允许抢占</li>
<li>优先级继承机制(动态优先级)，即占用同样资源的低优先级进程继承需要资源的进程的高优先级</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="资源问题"><a href="#资源问题" class="headerlink" title="资源问题"></a>资源问题</h3><ul>
<li>可重用性资源(打印机)和消耗性资源(消息)</li>
<li>不可抢占性资源(打印机)</li>
</ul>
<h3 id="计算机系统的死锁"><a href="#计算机系统的死锁" class="headerlink" title="计算机系统的死锁"></a>计算机系统的死锁</h3><p>原因：</p>
<ol>
<li>竞争可重用资源、可消耗资源</li>
<li>进程间推进顺序非法。<br><img src="/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1-3)/1647855855262.png" alt="enter description here"></li>
</ol>
<h3 id="定义、必要条件和处理方法"><a href="#定义、必要条件和处理方法" class="headerlink" title="定义、必要条件和处理方法"></a>定义、必要条件和处理方法</h3><p>定义：如果一组进程中的每一个进程<strong>都在等待仅由该组进程中的其他进程才能引发的事件</strong>，那么该组进程是死锁的</p>
<p>四个条件：</p>
<ol>
<li>互斥条件：指进程对所分配到的资源进行排它性使用 。</li>
<li>请求和保持条件：指进程已经保持了至少一个资源，但又提出了新的资源请求 。</li>
<li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链 。</li>
</ol>
<h4 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h4><p>通过<strong>设置某些限制条件</strong>，去破坏产生死锁的四个必要条件中的一个或几个条件，来预防发生死锁。<br>预防死锁使四个必要条件中的第2、3、4条件之一不能成立</p>
<h5 id="破环条件2"><a href="#破环条件2" class="headerlink" title="破环条件2"></a>破环条件2</h5><p>通过：</p>
<ul>
<li>第一种协议<strong>规定开始运行之前，必须一次性申请所需的全部资源</strong></li>
<li>第二种协议规定进程在运行过程中要逐步释放已用资源再请求新资源</li>
<li>*优点**：简单、易于实现且很安全。</li>
<li>*缺点**：资源被严重浪费，使进程延迟运行。</li>
</ul>
<h5 id="破环条件3"><a href="#破环条件3" class="headerlink" title="破环条件3"></a>破环条件3</h5><p>当一个已经保持了某些资源的进程，再提出新的资源请求而<strong>不能立即得到满足</strong>时，必须释放它已经保持了的所有资源。待以后需要时再重新申请<br><strong>缺点</strong>：因反复地申请和释放资源，致使进程执行被无限推迟，延长进程周转时间、增加系统开销、降低吞吐量</p>
<h5 id="破环条件4"><a href="#破环条件4" class="headerlink" title="破环条件4"></a>破环条件4</h5><p>将所有资源按类型进行线性排队，并赋予不同的序号。 所有进程对资源的请求必须严格按照资源序号递增的次序提出<br><strong>优点</strong>：相比前两种提高了资源利用率和系统吞吐量<br><strong>缺点</strong>：各类资源分配的序号必须相对稳定限制了新设备类型的增加；作业使用顺序与系统规定顺序不同造成资源浪费；增加了程序设计难度。</p>
<h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><p>是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。<strong>不会事先设置限制</strong><br>安全状态是指系统能按某种进程顺序，使每个进程都可顺利地完成，称系统处于安全状态。</p>
<h5 id="Dijkstra银行家算法"><a href="#Dijkstra银行家算法" class="headerlink" title="Dijkstra银行家算法"></a>Dijkstra银行家算法</h5><p>可利用资源向量Available<br>最大需求矩阵Max<br>分配矩阵Allocation<br>需求矩阵Need<br>P120</p>
<h4 id="死锁的检测与解除"><a href="#死锁的检测与解除" class="headerlink" title="死锁的检测与解除"></a>死锁的检测与解除</h4><p>检测死锁：通过系统所设置的<strong>检测机构</strong>，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源；<br>解除死锁：当<strong>检测</strong>到系统中<strong>已</strong>发生死锁时，须将进程从死锁状态中<strong>解脱出来</strong>。常用的实施方法是撤消或挂起一些进程。<br><strong>配套使用</strong></p>
<h5 id="检测："><a href="#检测：" class="headerlink" title="检测："></a>检测：</h5><p>系统必须保存有关资源的请求和分配信息，根据信息通过<strong>资源分配图</strong>或<strong>死锁定理</strong>的方法检测死锁</p>
<h5 id="解除："><a href="#解除：" class="headerlink" title="解除："></a>解除：</h5><p>两种常用方法：抢占资源(使死锁进程抢占其它进程资源以完成进程解除死锁)、终止进程(终止或撤销死锁进程)<br>其中终止方法可终止所有死锁进程，更好是按付出代价最小算法逐个解除</p>
<h6 id="付出代价最小算法"><a href="#付出代价最小算法" class="headerlink" title="付出代价最小算法"></a>付出代价最小算法</h6><ul>
<li><p>一种找到付出代价最小的终止顺序，但成本高的算法：</p>
<ol>
<li> 先从死锁进程组中取出一个，形成第一层终止，若有n个死锁进程，则有n个第一层。</li>
<li> 再从n个第一层中取一个，形成第二层终止，每个第一层又有n-1个第二层终止。</li>
<li> 如此循环，直到解除死锁，将各层的总代价计算，得到最小的终止顺序。<br>理解为从最低代价开始依次找到导致死锁的最低代价进程</li>
</ol>
</li>
<li><p>另一种比较有效的算法：</p>
<ol>
<li> 找到死锁进程组中，终止代价最小的，将其从死锁进程组中删去。</li>
<li> 再从新的死锁进程组中，找到终止代价最小的，删去。</li>
<li> 如此循环，直到解除死锁。<br>理解为一直解除最低代价进程(不判断此时死锁是否由它导致)直到解除死锁</li>
</ol>
</li>
</ul>
<h2 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h2><p>1、假设一个多级反馈队列的实现共有4级，各个队列的时间片长度是1、2、4、6秒，已知当前仅在第一级队列上有一个执行时长为10秒的进程O，在两秒后将有一个执行时长为8秒的任务A到达，请算出任务A的周转时间。<br>1:10-1=9O<br>2<br>4<br>6</p>
<p>1<br>2:9-1=8O<br>4<br>6<br>任务A到达<br>1:8-1=7A<br>2:<br>4:8O<br>6</p>
<p>1:<br>2:7A<br>4:8O-4=4O<br>6</p>
<p>1:<br>2:7A-2=5A<br>4:<br>6:4O</p>
<p>1:<br>2:<br>4:5A<br>6:4O-4=0O完成</p>
<p>1:<br>2:<br>4:5A-4=1A<br>6:</p>
<p>1:<br>2:<br>4:<br>6:1A-1=0A完成</p>
<p>所以答案等于1+4+2+4+4+1=16s</p>
<p>2、简述死锁的必要条件，以及预防死锁方法与必要条件的关系。<br>四个条件：</p>
<ol>
<li>互斥条件：指进程对所分配到的资源进行排它性使用 。</li>
<li>请求和保持条件：指进程已经保持了至少一个资源，但又提出了新的资源请求 。</li>
<li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链</li>
</ol>
<p>预防死锁通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来预防发生死锁。预防死锁使四个必要条件中的第2、3、4条件之一不能成立：</p>
<p>破环条件2通过：第一种协议规定开始运行之前，必须一次性申请所需的全部资源<br> 第二种协议规定进程在运行过程中要逐步释放已用资源再请求新资源；</p>
<p>破环条件3当一个已经保持了某些资源的进程，再提出新的资源请求而不能立即得到满足时，必须释放它已经保持了的所有资源。待以后需要时再重新申请；</p>
<p>破环条件4将所有资源按类型进行线性排队，并赋予不同的序号。 所有进程对资源的请求必须严格按照资源序号递增的次序提出。</p>
<p>3、在银行家算法中，若出现下述资源分配情况，试问：<br>| Process | Allocation | Need__  | Available |<br>|—|—|—|—|<br>| P0 | 0 0 3 2 | 0 0 1 2 | 1 6 2 2 |<br>| P1 | 1 0 0 0 | 1 7 5 0 |<br>| P2 | 1 3 5 4 | 2 3 5 6 |<br>| P3 | 0 3 3 2 | 0 6 5 2 |<br>| P4 | 0 0 1 4 | 0 6 5 6 |</p>
<p>（1）该状态是否安全？<br>安全，先执行P0后按P3、P4、P1、P2顺序即可完成全部进程<br>（2）若进程 P2 提出请求 Request（1，2，2，2）后，系统能否将资源分配<br>给它？<br>能，可按P2、P0、P3、P4、P1执行完成</p>

      
    </div>

    
    
    

 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dyinjin"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">dyinjin</p>
  <div class="site-description" itemprop="description">摸鱼窝</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">65</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fas fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dyinjin</span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">本博客全站共175.8k字呐~</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,120,50' opacity='0.3' zIndex='-2' count='100' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
<div class="moon-menu">
  <div class="moon-menu-items">
    
    <div id="moon-menu-item-back2bottom" class="moon-menu-item">
      <i class='fas fa-chevron-down'></i>    </div>
    
    <div id="moon-menu-item-back2top" class="moon-menu-item">
      <i class='fas fa-chevron-up'></i>    </div>
    
  </div>
  <div class="moon-menu-button">
    <svg class="moon-menu-bg">
      <circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle>
      <circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle>
    </svg>
    <div class="moon-menu-content">
      <div class="moon-menu-icon"><i class='fas fa-ellipsis-v'></i></div>
      <div class="moon-menu-text"></div>
    </div>
  </div>
</div><script src="/js/injector.js"></script>
</body>
</html>
