<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":250,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":false,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="操作系统引论目标和作用目标：方便性、有效性、可扩展性、开放性作用  作为用户与计算机硬件系统之间的接口 操作系统引论作为计算机系统资源的管理者 实现了对计算机资源的抽象  发展过程人工操作方式、脱机输入输出方式单批道处理系统多批道处理系统（资源利用率高，系统吞吐量大，平均周转时间长，无交互能力）分时系统（多路性、独立性、及时性、交互性）实时系统（多路性、独立性、及时性、交互性、可靠性）微机操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机操作系统(1-3)">
<meta property="og:url" content="http://example.com/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="岛屿尽">
<meta property="og:description" content="操作系统引论目标和作用目标：方便性、有效性、可扩展性、开放性作用  作为用户与计算机硬件系统之间的接口 操作系统引论作为计算机系统资源的管理者 实现了对计算机资源的抽象  发展过程人工操作方式、脱机输入输出方式单批道处理系统多批道处理系统（资源利用率高，系统吞吐量大，平均周转时间长，无交互能力）分时系统（多路性、独立性、及时性、交互性）实时系统（多路性、独立性、及时性、交互性、可靠性）微机操作系统">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/IMG_20220304_151207_edit_772433114767030.jpg">
<meta property="og:image" content="http://example.com/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1646809311457.png">
<meta property="og:image" content="http://example.com/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1647413678022.png">
<meta property="og:image" content="http://example.com/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1647413220791.png">
<meta property="og:image" content="http://example.com/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png">
<meta property="og:image" content="http://example.com/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1647848472429.png">
<meta property="og:image" content="http://example.com/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1647853007722.png">
<meta property="og:image" content="http://example.com/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1647855224272.png">
<meta property="og:image" content="http://example.com/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1647855855262.png">
<meta property="article:published_time" content="2022-03-04T06:34:00.153Z">
<meta property="article:modified_time" content="2022-04-14T09:05:29.636Z">
<meta property="article:author" content="dyinjin">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/IMG_20220304_151207_edit_772433114767030.jpg">

<link rel="canonical" href="http://example.com/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<link rel="stylesheet" type="text/css" href="/css/injector/main.css" /><link rel="preload" as="style" href="/css/injector/light.css" /><link rel="preload" as="style" href="/css/injector/dark.css" />
  <title>计算机操作系统(1-3) | 岛屿尽</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">岛屿尽</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">dyingjin</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-cube fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-bookmark fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-cubes fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-server fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机操作系统(1-3)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-04 14:34:00" itemprop="dateCreated datePublished" datetime="2022-03-04T14:34:00+08:00">2022-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 17:05:29" itemprop="dateModified" datetime="2022-04-14T17:05:29+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="操作系统引论"><a href="#操作系统引论" class="headerlink" title="操作系统引论"></a>操作系统引论</h1><h2 id="目标和作用"><a href="#目标和作用" class="headerlink" title="目标和作用"></a>目标和作用</h2><p>目标：方便性、有效性、可扩展性、开放性<br>作用</p>
<ol>
<li>作为用户与计算机硬件系统之间的接口</li>
<li>操作系统引论作为计算机系统资源的管理者</li>
<li>实现了对计算机资源的抽象</li>
</ol>
<h2 id="发展过程"><a href="#发展过程" class="headerlink" title="发展过程"></a>发展过程</h2><p>人工操作方式、脱机输入输出方式<br>单批道处理系统<br>多批道处理系统（资源利用率高，系统吞吐量大，平均周转时间长，无交互能力）<br>分时系统（多路性、独立性、及时性、交互性）<br>实时系统（多路性、独立性、及时性、交互性、可靠性）<br>微机操作系统（单用户多用户）</p>
<h2 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h2><ul>
<li>并发 -  <strong>并发性</strong>是指两个或多个事件在同一时间间隔内发生，而<strong>并行性</strong>是指两个或多个事件在同一时刻发生。</li>
<li>共享 -  <strong>资源共享</strong>是指系统中的资源可供内存中多个并发执行的进程共同使用。一段时间内只允许一个进程访问的资源称为<strong>临界资源</strong>一个进程访问结束并释放系统资源后才允许另一进程对该资源访问的方式称为<strong>互斥访问</strong></li>
<li>虚拟 -  通过<strong>空分复用</strong>或<strong>时分复用</strong>技术将一条物理信道变为若干条逻辑信道的技术</li>
<li>异步 -  进程的执行本身具有异步性（不可预知完成时间与顺序）所以要设计同步机制</li>
</ul>
<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><h3 id="处理机管理功能"><a href="#处理机管理功能" class="headerlink" title="处理机管理功能"></a>处理机管理功能</h3><ul>
<li>进程控制</li>
<li>进程同步</li>
<li>进程通信</li>
<li>调度</li>
</ul>
<h3 id="存储器管理功能"><a href="#存储器管理功能" class="headerlink" title="存储器管理功能"></a>存储器管理功能</h3><ul>
<li>内存分配</li>
<li>内存保护</li>
<li>地址映射</li>
<li>内存扩充</li>
</ul>
<h3 id="I-O-设备管理功能"><a href="#I-O-设备管理功能" class="headerlink" title="(I/O)设备管理功能"></a>(I/O)设备管理功能</h3><ul>
<li>缓冲管理</li>
<li>设备分配</li>
<li>设备处理</li>
</ul>
<h3 id="文件管理功能"><a href="#文件管理功能" class="headerlink" title="文件管理功能"></a>文件管理功能</h3><ul>
<li>文件存储空间管理</li>
<li>目录管理</li>
<li>文件读写管理与保护</li>
</ul>
<h3 id="操作系统与用户之间的接口"><a href="#操作系统与用户之间的接口" class="headerlink" title="操作系统与用户之间的接口"></a>操作系统与用户之间的接口</h3><ul>
<li>用户接口（联机用户接口、脱机用户接口、程序接口）</li>
<li>程序接口</li>
</ul>
<h2 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h2><h3 id="无结构"><a href="#无结构" class="headerlink" title="无结构"></a>无结构</h3><p>程序紧凑，高效利用内存<br>但是随着系统的不断扩大，所设计出的操作系统就会变得既庞大又杂乱。<br>一方面会使编制的程序错误很多给调试工作带来困难<br>另一方面也使程序难以阅读和理解，增加了维护负担</p>
<h3 id="模块化结构"><a href="#模块化结构" class="headerlink" title="模块化结构"></a>模块化结构</h3><p>模块化OS由程序设计的模块化设计思想演变而来<br>衡量模块化设计的两个标准：内聚性、耦合性<br>优点：</p>
<ol>
<li>提高OS设计的正确性、可理解性和可维护性。</li>
<li>增强OS的可适应性。</li>
<li>加速OS开发过程。<br>问题：</li>
<li>最初模块接口规定难以满足实际需求</li>
<li>无序设计</li>
</ol>
<h3 id="分层式结构"><a href="#分层式结构" class="headerlink" title="分层式结构"></a>分层式结构</h3><p>将模块接口法中对模块的设计顺序由无序变为有序，自底向上分层设计<br>优点：</p>
<ol>
<li>易保证系统的正确性</li>
<li>易扩充和易维护性<br>缺点：</li>
<li>系统效率降低：单向依赖的层次使得必须建立层次之间的通信机制增加通信开销</li>
</ol>
<h3 id="文件管理功能-文件管理功能"><a href="#文件管理功能-文件管理功能" class="headerlink" title="文件管理功能### 文件管理功能"></a>文件管理功能### 文件管理功能</h3><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><ol>
<li><p>设计现代OS的主要目标是什么？<br>方便性、有效性、可扩展性、开放性</p>
</li>
<li><p>试说明推动分时系统形成和发展的主要动力是什么。<br>满足人机交互需求，实现共享主机</p>
</li>
<li><p>为什么要引入实时操作系统？<br>更好的满足实时控制实时信息处理领域对时间控制的需求</p>
</li>
<li><p>试从交互性、及时性以及可靠性方面将分时系统与实时系统进行比较。<br>交互性：实时系统的交互性不像分时系统为终端用户提供数据和资源共享服务，而限于特定专用服务程序<br>及时性：分时系统的响应时间间隔通常为人们所能接受的1~3秒，实时系统由截至时间所确定通常为秒级到毫秒级<br>可靠性：实时系统相比分时系统要求更高的可靠性，所以采取多级容错措施保障系统的安全性</p>
</li>
<li><p>OS有几大特征？最基本的特征是什么？<br>并发性、共享性、虚拟性、异步性；并发性最基本</p>
</li>
<li><p>处理机管理有哪些主要功能？其主要任务是什么？<br>进程控制、进程同步、进程通信、调度<br>创建进程结束进程控制正在运行的进程、使多个进程有序同步进行、交换进程任务的信息、选择作业分配资源运行的作业调度和选择进程分配处理器设置现场执行的进程调度</p>
</li>
<li><p>存储器有哪些主要功能？其主要任务是什么？<br>内存分配、内存保护、地址映射、内存扩充<br>为程序分配内存空间、确保程序运行空间不干扰、将逻辑地址映射为物理地址、实现调用置换等功能</p>
</li>
<li><p>设备管理有哪些主要功能？其主要任务是什么？<br>缓冲管理、设备分配、设备处理<br>完成用户IO请求分配所需IO设备执行IO操作、提高CPU和IO设备的利用率提高IO速度方便用户使用</p>
</li>
<li><p>文件管理有哪些主要功能？其主要任务是什么？<br>文件存储空间管理、目录管理、文件读写管理与保护<br>分配外存空间提高外存利用率、为文件建立目录加以有效组织、根据用户请求读写外存数据、防止文件被非法窃取和受到破坏保障文件安全性</p>
</li>
</ol>
<h1 id="进程的描述与控制"><a href="#进程的描述与控制" class="headerlink" title="进程的描述与控制"></a>进程的描述与控制</h1><h2 id="前趋图和程序执行"><a href="#前趋图和程序执行" class="headerlink" title="前趋图和程序执行"></a>前趋图和程序执行</h2><p>前趋图（Precedence  Graph）是一个有向无循环图，用于描述进程之间执行的前后关系。</p>
<h3 id="程序的顺序执行"><a href="#程序的顺序执行" class="headerlink" title="程序的顺序执行"></a>程序的顺序执行</h3><ul>
<li>顺序性</li>
<li>封闭性</li>
<li>可再现性</li>
</ul>
<h3 id="程序的并发执行"><a href="#程序的并发执行" class="headerlink" title="程序的并发执行"></a>程序的并发执行</h3><ul>
<li>间断性</li>
<li>失去封闭性</li>
<li>不可再现性</li>
</ul>
<h2 id="进程的描述"><a href="#进程的描述" class="headerlink" title="进程的描述"></a>进程的描述</h2><p>而由程序段、相关的数据段和PCB三部分便构成了进程实体。</p>
<h3 id="典型定义"><a href="#典型定义" class="headerlink" title="典型定义"></a>典型定义</h3><ol>
<li>进程是程序的一次执行。</li>
<li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</li>
<li>进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</li>
</ol>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul>
<li>动态性</li>
<li>并发性</li>
<li>独立性</li>
<li>异步性</li>
</ul>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p><img src="/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/IMG_20220304_151207_edit_772433114767030.jpg" alt="IMG_20220304_151207_edit_772433114767030"></p>
<h3 id="PCB数据结构"><a href="#PCB数据结构" class="headerlink" title="PCB数据结构"></a>PCB数据结构</h3><ol>
<li><strong>进程标识符</strong> - 用于惟一地标识一个进程。分为内部标识符和外部标识符</li>
<li><strong>处理机状态</strong> - 组成：①通用寄存器②指令计数器③程序状态字PSW④用户栈指针</li>
<li><strong>进程调度信息</strong> - 包括：①进程状态②进程优先级③进程调度所需的其它信息④事件，阻塞原因</li>
<li><strong>进程控制信息</strong> - ①程序和数据的地址 ②进程同步和通信机制 ③资源清单 ④链接指针</li>
</ol>
<table>
<thead>
<tr>
<th>pid</th>
</tr>
</thead>
<tbody><tr>
<td>进程状态</td>
</tr>
<tr>
<td>现场</td>
</tr>
<tr>
<td>优先级</td>
</tr>
<tr>
<td>阻塞原因</td>
</tr>
<tr>
<td>程序地址</td>
</tr>
<tr>
<td>同步机制</td>
</tr>
<tr>
<td>资源清单</td>
</tr>
<tr>
<td>链接指针</td>
</tr>
</tbody></table>
<h3 id="PCB的组织方式"><a href="#PCB的组织方式" class="headerlink" title="PCB的组织方式"></a>PCB的组织方式</h3><ol>
<li><strong>线性方式</strong> 将系统中的所有PCB组织在一张线性表中，将该表的首地址存放在一个专用区域中。</li>
<li><strong>链接方式</strong> 把具有同一状态的PCB，用其中的链接字链接成一个队列，排成就绪队列，若干个阻塞队列以及空白队列。</li>
<li><strong>索引方式</strong> 系统根据所有进程的状态建立几张索引表。</li>
</ol>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>进程控制是用于创建一个新进程，终止一个已完成的进程，或去终止一个因出现某事件而使其无法运行下去的进程，还负责进程运行中的状态转换。</p>
<h3 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h3><p>OS内核—-常驻内存。<br>包含与硬件紧密相关的模块（中断处理） 常用设备驱动、运行频率高的模块（时钟管理、进程调度）<br>目的：1、保护；2、提供OS效率</p>
<ol>
<li>支撑功能 - 中断处理 时钟管理 原语操作</li>
<li>资源管理功能 - 进程管理 存储器管理 设备管理</li>
</ol>
<h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><h4 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h4><p>即父进程、子进程（可以继承父进程所拥有的资源）</p>
<h4 id="引起创建进程的事件"><a href="#引起创建进程的事件" class="headerlink" title="引起创建进程的事件"></a>引起创建进程的事件</h4><ol>
<li>用户登录</li>
<li>作业调度</li>
<li>提供服务</li>
<li>应用请求</li>
</ol>
<h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><p>调用进程创建原语Creat（ ）按下述步骤创建一个新进程：</p>
<ol>
<li>申请空白PCB。</li>
<li>为新进程分配资源。</li>
<li>初始化进程控制块。包括：<br>①初始化标识信息。<br>②初始化处理机状态信息。<br>③初始化处理机控制信息。</li>
<li>将新进程插入就绪队列。</li>
</ol>
<h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><h4 id="引起进程终止的事件"><a href="#引起进程终止的事件" class="headerlink" title="引起进程终止的事件"></a>引起进程终止的事件</h4><ol>
<li>正常结束: 批处理中用Holt指令，分时中用Logs off指令。</li>
<li>异常结束：<br>①越界错误。存储区。<br>②保护错。写一个只读文件。<br>③非法指令。执行一条不存在的指令。<br>④特权指令错。用户访问只允许OS执行的指令。<br>⑤运行超时。<br>⑥等待超时。<br>⑦算术运算错。被0除。<br>⑧I/O故障。</li>
<li>外界干预：外界干预并非指在本进程运行中出现了异常事件，而是指进程应外界的请求而终止运行。<br>① 操作员或操作系统干预。<br>② 父进程请求终止该进程。<br>③ 当父进程终止时，OS也将他的所有子孙进程终止。</li>
</ol>
<h4 id="进程的终止过程"><a href="#进程的终止过程" class="headerlink" title="进程的终止过程"></a>进程的终止过程</h4><ol>
<li>根据被终止进程的标识符ID，从PCB集合中检索出该进程的PCB，从中读出该进程的状态。</li>
<li>若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度。</li>
<li>若该进程还有子孙进程，还应将其所有子孙进程予以终止，以防他们成为不可控的进程。</li>
<li>将被终止进程所拥有的全部资源，或者归还给其父进程，或者归还给系统。</li>
<li>将被终止进程（它的PCB）从所在队列（或链表）中移出，等待其他程序来搜集信息。</li>
</ol>
<h3 id="进程的阻塞与唤醒、挂起与激活"><a href="#进程的阻塞与唤醒、挂起与激活" class="headerlink" title="进程的阻塞与唤醒、挂起与激活"></a>进程的阻塞与唤醒、挂起与激活</h3><h4 id="引起进程阻塞的事件"><a href="#引起进程阻塞的事件" class="headerlink" title="引起进程阻塞的事件"></a>引起进程阻塞的事件</h4><ol>
<li>请求系统服务：提出I/O服务时，并不立即满足该进程的要求时，转变为阻塞状态来等待</li>
<li>启动某种操作：当进程启动某种操作后，在该操作完成之后才能继续执行。</li>
<li>新数据尚未到达：对于相互合作的进程而言。 </li>
<li>无新工作可做。如发送进程。</li>
</ol>
<h4 id="进程阻塞过程"><a href="#进程阻塞过程" class="headerlink" title="进程阻塞过程"></a>进程阻塞过程</h4><p>正在执行的进程，当发现上述某事件时，由于无法继续执行，于是进程便通过调用阻塞原语block( )把自己阻塞。</p>
<ol>
<li>把进程控制块中的现行状态由“执行”改为“阻塞”，并将PCB插入阻塞队列。</li>
<li>转调度程序进行重新调度，将处理机分配给另一就绪进程，并进行切换。</li>
</ol>
<h4 id="进程唤醒过程"><a href="#进程唤醒过程" class="headerlink" title="进程唤醒过程"></a>进程唤醒过程</h4><p>当被阻塞进程所期待的事件出现时，则由有关进程（比如，用完并释放了该I/O设备的进程）调用唤醒原语wakeup( )，将等待该事件的进程唤醒。</p>
<ol>
<li>首先把被阻塞的进程从等待该事件的阻塞队列中移出，将其PCB中的现行状态由阻塞改为就绪</li>
<li>然后再将该PCB插入到就绪队列中。</li>
</ol>
<h4 id="进程的挂起"><a href="#进程的挂起" class="headerlink" title="进程的挂起"></a>进程的挂起</h4><p>当出现了引起进程挂起的事件时，系统将利用挂起原语suspend( )将指定进程进程挂起。</p>
<ol>
<li>首先检查被挂起进程的状态，若处于活动就绪状态，便将其改为静止就绪；</li>
<li>对于活动阻塞状态的进程，则将之改为静止阻塞状态。</li>
</ol>
<h4 id="进程的激活"><a href="#进程的激活" class="headerlink" title="进程的激活"></a>进程的激活</h4><p>当发生激活进程的事件时，则可将在外存上处于静止就绪状态的进程换入内存。 系统利用激活原语active( )将指定进程激活:</p>
<ol>
<li>激活原语先将进程从外存调入内存，检查该进程的现行状态; </li>
<li>若是静止就绪，便将之改为活动就绪；若为静止阻塞，便将之改为活动阻塞。</li>
</ol>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>为什么：<br>由于进程的异步性，也会给系统造成混乱，在OS中引入进程同步。<br>任务：<br>使并发执行的诸进程之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性。</p>
<h3 id="进程同步的基本概念"><a href="#进程同步的基本概念" class="headerlink" title="进程同步的基本概念"></a>进程同步的基本概念</h3><ul>
<li>两种形式的制约关系：1）间接相互制约关系。由于资源共享 2）直接相互制约关系。主要由于进程间的合作。</li>
<li><strong>临界资源</strong> 一次仅允许一个进程访问的资源为临界资源 。</li>
<li><strong>临界区</strong> 把在每个进程中访问临界资源的那段代码称为临界区。</li>
<li>同步机制<strong>规则</strong> ：1)空闲让进 2)忙则等待 3)有限等待 4)让权等待</li>
</ul>
<h3 id="硬件同步机制"><a href="#硬件同步机制" class="headerlink" title="硬件同步机制"></a>硬件同步机制</h3><p>利用计算机硬件指令解决临界区问题<br>    对临界区管理将标识看做一个锁，“锁开”进入，“锁关”等待。 初始打开，每个进入临界区的进程必须对锁进行测试。 测试和关锁操作必须连续（原子操作）<br>方法：</p>
<ul>
<li>关中断</li>
<li>利用Test-and-Set指令实现互斥</li>
<li>利用Swap指令实现进程互斥</li>
</ul>
<p>优点：</p>
<ul>
<li>适用于任意数目的进程，在单处理器或多处理器上</li>
<li>简单，容易验证其正确性</li>
<li>可以支持进程内存在多个临界区，只需为每个临界区设立一个布尔变量</li>
</ul>
<p>缺点：</p>
<ul>
<li>等待要耗费CPU时间，不能实现“让权等待”</li>
<li>可能“饥饿”：从等待进程中随机选择一个进入临界区，有的进程可能一直选不上</li>
</ul>
<h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><p>信号量（Semaphores）机制:是一种卓有成效的进程同步工具。</p>
<h4 id="整形信号量"><a href="#整形信号量" class="headerlink" title="整形信号量"></a>整形信号量</h4><ol>
<li>必须置一次且只能置一次初值，并且初值不能为负数。</li>
<li>只能执行P、V操作。</li>
<li>必须成对使用P、V操作：P操作遗漏则不能保证互斥访问，V操作遗漏则不能在使用临界资源之后将其释放；P，V次序不能错误、重复或遗漏。<br>n整形信号量机制的问题：忙等。<br>wait操作中信号量S&lt;=0时，会不停的测试<br>未遵循让权等待的原则</li>
</ol>
<h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h4><p>只能用于共享一个临界资源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">	int value;</span><br><span class="line">	struct process_control_block *list;</span><br><span class="line">&#125;semaphore;</span><br><span class="line"></span><br><span class="line">wait(semaphore *S)&#123;</span><br><span class="line">	S-&gt;value--;</span><br><span class="line">	if(S-&gt;value&lt;0)block(S-&gt;list);</span><br><span class="line">&#125;</span><br><span class="line">signal(semaphore *S)&#123;</span><br><span class="line">	S-&gt;value++;</span><br><span class="line">	if(S-&gt;value&lt;=0)wakeup(S-&gt;list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>信号量的初值：0，1，n三种情况<br>    1：表示临界资源；<br>    0：表示进程间的同步（前驱）关系<br>    n：表示若干个资源</p>
<h4 id="AND型信号量"><a href="#AND型信号量" class="headerlink" title="AND型信号量"></a>AND型信号量</h4><p><strong>AND同步机制的基本思想</strong>：将进程在整个运行过程中需要的所有资源，一次性全都地分配给进程，待进程使用完后再一起释放。只要尚有一个资源未能分配给进程，其它所有可能为之分配的资源，也不分配给他。<br><strong>原子操作</strong>：要么全部分配到进程，要么一个也不分配。<br>在wait操作中，增加了一个“AND”条件，故称为AND同步，或称为同时wait操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Swait（S1，S2，···，Sn ） &#123;</span><br><span class="line">     while（true）&#123;</span><br><span class="line">         if（ S1≥1 and S2≥1 and…and Sn≥1 ）&#123;</span><br><span class="line">            for (i = 1 ; i&lt;= n; i++)&#123;</span><br><span class="line">                     Si =  Si – 1;</span><br><span class="line">             &#125;</span><br><span class="line">             break;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">               place  the process  in  the waiting  queue  associated  with  the  first  Si  found  with  Si＜1,  and  set  the program  count  of  this  process  to  the  beginning  of  Swait  operation//将进程置于与在 Si&lt;1 的条件下找到的**第一个** Si 关联的等待队列中，并将此过程的程序计数设置为 Swait 操作的开始</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ssignal（S1，S2，···，Sn）&#123;</span><br><span class="line">    for(  i = 1; i&lt;= n; i++ )&#123;</span><br><span class="line">         Si = Si+1;</span><br><span class="line">         Remove  all  the  process  waiting  in  the  queue  associated  with  Si  into  the  ready  queue//将与 Si 关联的队列中**所有**等待的进程移动到就绪队列中</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="信号量集"><a href="#信号量集" class="headerlink" title="信号量集"></a>信号量集</h4><p>一般信号量集是指同时需要多种资源、每种占用的数目不同、且可分配的资源(预留下限)还存在一个临界值时的信号量处理<br>一般信号量集的基本思路就是在AND型信号量集的基础上进行扩充，在一次原语操作中完成所有的资源申请</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Swait（S1，t1，d1，…，Sn，tn，dn）（满足ti≥ di）    </span><br><span class="line">    if( S1 ≥t1 &amp;…&amp; Sn≥tn)&#123;  </span><br><span class="line">          for(  i =1; i&lt;=n; i++)&#123;</span><br><span class="line">                    Si ＝Si － di;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">          Place  the  executing  process  in  the  waiting  queue  of  the  first Si  with Si＜ti  and  set  its  program  counter  to  the  beginning  of  the  Swait  operation//将进程置于与在 Si&lt;ti 的条件下找到的**第一个** Si 关联的等待队列中，并将此过程的程序计数设置为 Swait 操作的开始</span><br><span class="line">    &#125;//end if</span><br><span class="line">&#125;//end Swait </span><br><span class="line"></span><br><span class="line"> Ssignal（S1，d1，···，Sn，dn）&#123;</span><br><span class="line">    for( i =1; i&lt;= n; i++)&#123;  </span><br><span class="line">        Si = Si + di；</span><br><span class="line">        Remove  all  the  process  waiting  in  the  queue  associated  with  Si  into  the  ready  queue//将与 Si 关联的队列中**所有**等待的进程移动到就绪队列中</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三种特例：</p>
<ol>
<li>Swait(S,d,d)：允许每次申请d个资源。当资源数少于d时，不予分配。</li>
<li>Swait (S,1,1)：S&gt;1，记录型信号量。S=1时，互斥型信号量。</li>
<li>Swait(S,1,0)，可控开关，当S&gt;=1时，允许进入，S&lt;1时，不能进入。</li>
</ol>
<h2 id="经典进程的同步问题"><a href="#经典进程的同步问题" class="headerlink" title="经典进程的同步问题"></a>经典进程的同步问题</h2><h3 id="生产者——消费者问题"><a href="#生产者——消费者问题" class="headerlink" title="生产者——消费者问题"></a>生产者——消费者问题</h3><h4 id="记录型信号量解决"><a href="#记录型信号量解决" class="headerlink" title="记录型信号量解决"></a>记录型信号量解决</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void producer( )&#123;</span><br><span class="line">    do&#123;</span><br><span class="line">		…</span><br><span class="line">		Produce an item in nextp;</span><br><span class="line">		…</span><br><span class="line">		wait(empty);</span><br><span class="line">		wait(mutex);</span><br><span class="line">		buffer(in):=nextp;</span><br><span class="line">		in:=(in+1) mod n;</span><br><span class="line">		signal(mutex);</span><br><span class="line">		signal(full);</span><br><span class="line">	&#125;while(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void consumer&#123;</span><br><span class="line">  do&#123;</span><br><span class="line">        wait(full);</span><br><span class="line">		wait(mutex);</span><br><span class="line">		nextc:=buffer(out);</span><br><span class="line">		out:=(out+1) mod n;</span><br><span class="line">		signal(mutex);</span><br><span class="line">		signal(empty);</span><br><span class="line">		Consumer the item in nextc;</span><br><span class="line">		……</span><br><span class="line">	&#125;while(TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AND信号量解决"><a href="#AND信号量解决" class="headerlink" title="AND信号量解决"></a>AND信号量解决</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int  in=0, out=0;</span><br><span class="line">item    buffer[ n ];</span><br><span class="line">semaphore  mutex=1, empty=n, full=0;</span><br><span class="line">void producer( )&#123;</span><br><span class="line">	do&#123;</span><br><span class="line">		…</span><br><span class="line">		produce an item in nextp;</span><br><span class="line">		…</span><br><span class="line">		Swait(empty, mutex);</span><br><span class="line">		buffer[in] = nextp;</span><br><span class="line">		in = (in+1) % n;</span><br><span class="line">		Ssignal(mutex, full);</span><br><span class="line">	&#125;while(TRUE);</span><br><span class="line">&#125; //end producer</span><br><span class="line"></span><br><span class="line">void consumer&#123;</span><br><span class="line">	do&#123;</span><br><span class="line">		Swait(full, mutex);</span><br><span class="line">		nextc = buffer[out];</span><br><span class="line">		out = (out+1) % n;</span><br><span class="line">		Ssignal(mutex, empty);</span><br><span class="line">		consumer the item in nextc;</span><br><span class="line">	&#125;while(TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><p>几种解决方法：</p>
<ol>
<li>至多只允许有四位哲学家同时去拿左边的筷子，最终能保证至少有一位哲学家能够进餐，并在用毕时能释放出他用过的两只筷子，从而使更多的哲学家能够进餐。</li>
<li>仅当哲学家的左、右两只筷子均可用时，才允许他拿起筷子进餐。</li>
<li>规定奇数号哲学家先拿他左边的筷子，然后再去拿右边的筷子；而偶数号哲学家则相反。按此规定，将是1、 2号哲学家竞争1号筷子；3、4号哲学家竞争3号筷子。即五位哲学家都先竞争奇数号筷子，获得后，再去竞争偶数号筷子，最后总会有一位哲学家能获得两只筷子而进餐</li>
</ol>
<h4 id="AND信号量解决-1"><a href="#AND信号量解决-1" class="headerlink" title="AND信号量解决"></a>AND信号量解决</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[5]=&#123;1,1,1,1,1&#125;;</span><br><span class="line">do&#123;</span><br><span class="line">	……;</span><br><span class="line">	think;</span><br><span class="line">	Sswait(chopstick[(i+1) % 5],chopstick[i]);</span><br><span class="line">	eat;</span><br><span class="line">	Ssignal(chopstick[(i+1) % 5],chopstick[i]);</span><br><span class="line">&#125;while(TRUE);</span><br></pre></td></tr></table></figure>

<h3 id="读者——写者问题"><a href="#读者——写者问题" class="headerlink" title="读者——写者问题"></a>读者——写者问题</h3><h4 id="记录型信号量解决-1"><a href="#记录型信号量解决-1" class="headerlink" title="记录型信号量解决"></a>记录型信号量解决</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">semaphore rmutex=1, wmutex = 1;</span><br><span class="line">int readcount = 0;</span><br><span class="line"></span><br><span class="line">void reader( )&#123;</span><br><span class="line">	do&#123;</span><br><span class="line">		wait(rmutex);</span><br><span class="line">		if  readcount=0  then  wait(wmutex);</span><br><span class="line">		readcount:=readcount+1;</span><br><span class="line">		signal(rmutex);</span><br><span class="line">		…				</span><br><span class="line">		perform read operation</span><br><span class="line">		…</span><br><span class="line">		wait(rmutex);</span><br><span class="line">		readcount:=readcount-1;</span><br><span class="line">		if readcount=0  then signal(wmutex);</span><br><span class="line">		signal(rmutex);</span><br><span class="line">	&#125;while(TRUE);</span><br><span class="line">&#125;//end reader</span><br><span class="line"></span><br><span class="line">void writer( )&#123;</span><br><span class="line">	do&#123;</span><br><span class="line">		wait(wmutex)</span><br><span class="line">		perform write operation;</span><br><span class="line">		signal(wmutex)</span><br><span class="line">	&#125;while(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">	cobegin</span><br><span class="line">	reader(); writer();</span><br><span class="line">	coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="信号量集解决"><a href="#信号量集解决" class="headerlink" title="信号量集解决"></a>信号量集解决</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int RN;</span><br><span class="line">Semaphore L=RN, mx=1;</span><br><span class="line">//RN标示同时允许多少读进程存在</span><br><span class="line">void reader( )&#123;</span><br><span class="line">	   do&#123;</span><br><span class="line">              swait(L,1,1);</span><br><span class="line">              swait(mx,1,0);</span><br><span class="line">                   …</span><br><span class="line"> 	        perform read operation;</span><br><span class="line">		        …</span><br><span class="line">	         ssignal(L,1);</span><br><span class="line">        &#125;while(TRUE);</span><br><span class="line">&#125;//end reader</span><br><span class="line"></span><br><span class="line"> void writer( )&#123;</span><br><span class="line">        do&#123;</span><br><span class="line">             swait(mx,1,1; L,RN,0);</span><br><span class="line">             perform write operation;</span><br><span class="line">             ssignal(mx, 1);</span><br><span class="line">        &#125;while(TRUE);</span><br><span class="line"> &#125; //end writer</span><br><span class="line"></span><br><span class="line"> void main( )&#123;</span><br><span class="line">    cobegin</span><br><span class="line">       reader(); writer();</span><br><span class="line">    coedn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul>
<li><strong>共享存储器系统</strong> - 基于共享数据结构的通信方式。基于共享存储区的通信方式。</li>
<li><strong>消息传递系统</strong> - 是目前的主要通信方式，信息单位：消息（报文）实现：一组通信命令（原语），具有透明性、同步的实现。实现方式的不同，而分成：<br>   （1）直接通信方式<br>   （2）间接通信方式</li>
<li><strong>管道通信系统</strong> - 管道：连接一个读进程和一个写进程之间通信的共享文件。 功能：大量的数据发收。 注意：<pre><code>（1）互斥
（2）同步
（3）对方是否存在
</code></pre>
</li>
<li><strong>客户机服务器系统</strong></li>
</ul>
<h3 id="消息传递通信的实现方法"><a href="#消息传递通信的实现方法" class="headerlink" title="消息传递通信的实现方法"></a>消息传递通信的实现方法</h3><ul>
<li><p>直接通信方式<br>这是指发送进程利用OS所提供的发送命令，直接把消息发送给目标进程。<br>系统提供下述两条通信命令（<strong>原语</strong>）：<br>   Send  （Receiver，  message）；<br>   Receive（Sender，  message）； </p>
</li>
<li><p>间接通信方式<br>指进程之间利用信箱的通信方式。发送进程发送给目标进程的消息存放信箱；接收进程则从该信箱中，取出对方发送给自己的消息；消息在信箱中可以安全地保存，只允许核准的目标用户随时读取。<br>   系统为信箱通信提供了若干条<strong>原语</strong>，分别用于信箱的创建、撤消和消息的发送、接收等。优点：在读/写时间上的随机性<br>信箱分为以下三类：<br>（1）私用信箱<br>（2）公用信箱<br>（3）共享信箱<br>在利用信箱通信时，在发送进程和接收进程之间，存在以下四种关系：<br>（1）一对一关系。<br>（2）多对一关系，客户/服务器交互。<br>（3）一对多关系， 广播方式。<br>（4）多对多关系。</p>
</li>
</ul>
<h3 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h3><p>消息头：含控制信息如：收/发进程名，消息长度、类型、编号<br>消息内容：<br>    定长消息：系统开销小，用户不便（特别是传长消息用户）<br>    变长消息：开销大，用户方便。</p>
<h3 id="消息格式进程同步方式"><a href="#消息格式进程同步方式" class="headerlink" title="消息格式进程同步方式"></a>消息格式进程同步方式</h3><p>1）发送和接收进程阻塞（汇合）用于紧密同步，无缓冲区时。<br>2）发送进程不阻塞，接收进程阻塞（多个）相当于接收进程（可能是多个）一直等待发送进程，如：打印进程等待打印任务。<br>3）发送/接收进程均不阻塞一般在发、收进程间有多个缓冲区时。</p>
<h2 id="进程运行与监控"><a href="#进程运行与监控" class="headerlink" title="进程运行与监控"></a>进程运行与监控</h2><h3 id="Linux进程控制块"><a href="#Linux进程控制块" class="headerlink" title="Linux进程控制块"></a>Linux进程控制块</h3><h4 id="task-struct结构"><a href="#task-struct结构" class="headerlink" title="task_struct结构"></a>task_struct结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pid_t pid;</span><br><span class="line">uid_t uid,euid; </span><br><span class="line">gid_t gid,egid;</span><br><span class="line">volatile long state;</span><br><span class="line">int exit_state;</span><br><span class="line">unsigned int rt_priority;</span><br><span class="line">unsigned int policy;</span><br><span class="line">struct list_head tasks;</span><br><span class="line">struct task_struct *real_parent;</span><br><span class="line">struct task_struct *parent;</span><br><span class="line">struct list_head children,sibling;</span><br><span class="line">struct fs_struct *fs;</span><br><span class="line">struct files_struct *files;</span><br><span class="line">struct mm_struct *mm;</span><br><span class="line">struct signal_struct *signal;</span><br><span class="line">struct sighand_struct *sighand;</span><br><span class="line">cputime_t utime, stime;</span><br><span class="line">struct timespec start_time;</span><br><span class="line">struct timespec real_start_time;</span><br></pre></td></tr></table></figure>

<h4 id="task-struct-进程状态"><a href="#task-struct-进程状态" class="headerlink" title="task_struct:进程状态"></a>task_struct:进程状态</h4><p>——<code>volatile long state;</code><br>state成员的可能取值如下： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define TASK_RUNNING	0  </span><br><span class="line">#define TASK_INTERRUPTIBLE	1  </span><br><span class="line">#define TASK_UNINTERRUPTIBLE	2  </span><br><span class="line">#define TASK_ZOMBIE	4  </span><br><span class="line">#define TASK_STOPPED	8</span><br></pre></td></tr></table></figure>

<h4 id="进程状态切换"><a href="#进程状态切换" class="headerlink" title="进程状态切换"></a>进程状态切换</h4><p><img src="/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1646809311457.png"></p>
<h4 id="task-struct-文件管理"><a href="#task-struct-文件管理" class="headerlink" title="task_struct:文件管理"></a>task_struct:文件管理</h4><p><img src="/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1647413678022.png"></p>
<h3 id="进程的启动"><a href="#进程的启动" class="headerlink" title="进程的启动"></a>进程的启动</h3><p>UNIX&amp;Linux中创建进程的方式：</p>
<ul>
<li><p>在shell中执行命令或可执行文件由shell进程调用fork函数创建子进程</p>
</li>
<li><p>在代码中（已经存在的进程中）调用fork函数创建子进程，fork创建的进程为子进程，原进程为父进程</p>
</li>
<li><p>Linux系统中进程0 （PID=0）是由内核创建，其他所有进程都是由父进程调用fork函数所创建的。进程0在创建子进程（PID=1，init进程）后，进程0就转为交换进程或空闲进程</p>
</li>
<li><p>进程1（init进程）是系统中其他所有进程的共同祖先</p>
</li>
</ul>
<h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><p><code>#include&lt;unistd.h&gt;</code>头文件定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* Clone the calling process, creating an exact copy.</span><br><span class="line">	Return -1 for errors, 0 to the new process,</span><br><span class="line">	and the process ID of the new process to the old process.  */</span><br></pre></td></tr></table></figure>
<p>fork函数被正确调用后，将会在子进程中和父进程中分别返回</p>
<ul>
<li>在子进程中返回值为0（不合法的PID，提示当前运行在子进程中）</li>
<li>在父进程中返回值为子进程ID（让父进程掌握所创建子进程的ID号）</li>
<li>出错返回-1</li>
</ul>
<p>子进程是父进程的副本</p>
<ul>
<li>子进程复制/拷贝父进程的PCB、用户空间（数据段、堆和栈）</li>
<li>父子进程共享正文段（只读）<br>父进程继续执行fork函数调用之后的代码，子进程也从fork函数调用之后的代码开始执行为了提高效率，fork后不并立即复制父进程数据段、堆和栈，采用了写时复制机制（Copy-On-Write）：当父子进程任意之一要修改数据段、堆、栈时，进行复制操作，并且仅复制修改区域</li>
</ul>
<p>子进程复制父进程的进程控制块</p>
<ul>
<li>父进程的文件描述符表被子进程复制，父子进程的同一文件描述符<strong>指向同一个文件表</strong></li>
<li>父子进程对同一文件访问基于<strong>相同的文件当前位置</strong></li>
</ul>
<p>父子进程对共享文件的常见处理方式：</p>
<ul>
<li>父进程等待子进程完成。当子进程终止后，文件当前位置已经得到了相应的更新</li>
<li>父子进程各自执行不同的程序段，各自关闭不需要的文件</li>
</ul>
<p>vfork函数保证子进程先执行，在它调用exec或者exit之后，父进程才会继续被调度执行（父进程处于TASK_UNINTERRUPTIBLE状态）</p>
<h4 id="进程内存空间布局"><a href="#进程内存空间布局" class="headerlink" title="进程内存空间布局"></a>进程内存空间布局</h4><ul>
<li>命令行参数和环境变量 - 主要用于支撑函数调用 存放参数、局部变量等</li>
<li>堆栈 - 用于动态分配内存</li>
<li>未初始化的数据 - 程序执行之前，将此段中 的数据初始化为0，如 全局变量long sum[1000];</li>
<li>初始化的数据 - 包含了程序中需明确赋 初值的变量，如全局变量 int maxcount=99;</li>
<li>正文 - CPU执行的代码部分，正文 段通常是共享、只读的</li>
</ul>
<h3 id="进程的运行控制"><a href="#进程的运行控制" class="headerlink" title="进程的运行控制"></a>进程的运行控制</h3><h4 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h4><p>设置环境变量的三种方法： </p>
<ul>
<li>putenv - 将环境变量字符串放入环境变量表中</li>
<li>setenv - 将指定环境变量的值设置为参数指定值</li>
<li>unsetenv - 删除指定的环境变量字符串</li>
</ul>
<h4 id="exec系列函数"><a href="#exec系列函数" class="headerlink" title="exec系列函数"></a>exec系列函数</h4><p>进程调用exec系列函数在进程中加载执行另外一个可执行文件<br>exec系列函数替换了当前进程（执行该函数的进程）的正文段、数据段、堆和栈（来源于加载的可执行文件），但并不修改PCB！<br>执行exec系列函数后从加载可执行文件的main函数开始重新执行<br>exec系列函数<strong>并不创建新进程</strong>，所以在调用exec系列函数后其进程ID(uid)并未改变，已经打开的文件描述符不变</p>
<p>execl execle execlp execv execve execvp<br>六个函数开头均为exec，所以称为exec系列函数</p>
<ul>
<li>l：表示list，每个命令行参数都说明为一个单独的参数</li>
<li>v：表示vector，命令行参数放在数组中</li>
<li>e：表示由函数调用者提供环境变量表</li>
<li>p：表示通过环境变量PATH来指定路径，查找可执行文件</li>
</ul>
<h3 id="进程的监测"><a href="#进程的监测" class="headerlink" title="进程的监测"></a>进程的监测</h3><h4 id="终止进程函数"><a href="#终止进程函数" class="headerlink" title="终止进程函数"></a>终止进程函数</h4><p>头文件stdlib.h定义：void  exit( int  status )<br>头文件unistd.h定义：void  _exit (int  status ）<br>调用这两个函数均会正常地终止一个进程<br>调用 <strong>_exit</strong> 函数将会<strong>立即</strong>返回内核<br>调用 <strong>exit</strong> 函数执行一些预先注册的终止处理函数,执行文件I/O操作的善后工作，使得所有缓冲的输出数据被更新到相应的设备,返回内核</p>
<h4 id="获知子进程状态改变"><a href="#获知子进程状态改变" class="headerlink" title="获知子进程状态改变"></a>获知子进程状态改变</h4><ul>
<li>主动获取 - 调用wait或waitpid函数等待子进程状态信息改变，并获取其状态信息</li>
<li>异步通知 - 当一个进程发生特定的状态变化（进程终止、暂停以及恢复）时，内核向其父进程发送SIGCHLD信号，父进程可以选择忽略该信号，也可以对信号进行处理（默认处理方式为忽略该信号）</li>
</ul>
<p>僵尸进程：<br>进程在退出之前会释放进程用户空间的所有资源，但PCB等内核空间资源不会被释放。当父进程调用wait或waitpid函数后，内核将根据情况<strong>关闭</strong>该进程打开的所有文件。而对于已经终止但父进程尚未对其调用wait或waitpid函数的进程（TASK_ZOMBIE状态），称为僵尸进程。</p>
<p>孤儿进程：<br>如果 <strong>父进程在子进程终止之前终止</strong>，则子进程的父进程将变为init进程，保证每个进程都有父进程，由init进程调用wait函数进行善后</p>
<h5 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h5><p>头文件：sys/wait.h<br>功能：获取任意子进程的状态改变信息（如果是终止状态则对子进程进行善后处理）<br><code>pid_t wait(int *statloc); </code><br>参数statloc：用于存储子进程的状态改变信息<br>若成功返回状态信息改变的子进程ID，出错返回-1<br>子进程状态改变信息包含了多种类型的信息，可以通过<strong>系统提供的宏</strong>来快速解析子进程的状态<br>如：<br>| 宏 | 功能说明 |<br>| — | — |<br>| WIFEXITED(statloc) | 当子进程正常终止时该宏为真，对于这种情况可进一步执行WEXITSTATUS(statloc)，获取子进程传递给exit、_exit函数参数的低8位 |<br>| WIFSIGNALED(statloc) | 当子进程异常终止时该宏为真，对于这种情况可进一步执行WTERMSTG(statloc)，获取使子进程终止的信号编号 |<br>| WIFSTOPPED(statloc) | 当子进程暂停时该宏为真，对于这种情况可进一步执行WSTOPSIG(statloc)，获取使子进程暂停的信号编号 |<br>| WIFCONTINUED(statloc) | 若子进程在暂停后已经继续则该宏为真 |</p>
<p>如果一个进程有几个子进程，那么只要有一个子进程状态改变，wait函数就返回</p>
<p>如何才能使用wait函数等待某个<strong>特定</strong>子进程的状态改变？</p>
<ol>
<li>调用wait，然后将其返回的进程ID和所期望的子进程ID进行比较</li>
<li>如果ID不一致，则保存该ID，并循环调用wait函数，直到等到所期望的子进程ID为止</li>
</ol>
<h5 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h5><p>功能：等待某个<strong>特定</strong>子进程状态改变<br><code>pid_t waitpid(pid_t pid, int *statloc, int options);</code><br>参数：</p>
<ul>
<li>pid：pid == -1：等待任意子进程状态改变（同wait）；pid &gt; 0：等待进程ID为pid的子进程状态改变；pid == 0：等待其组ID等于调用进程组ID的任意子进程；pid &lt; -1：等待其组ID等于pid绝对值的任意子进程</li>
<li>statloc：用于存储子进程的状态改变信息</li>
<li>options：可以为0，也可以是以下常量：WNOHANG：如果没有任何已经终止的子进程则马上返回, 函数不等待，此时返回值为0；WUNTRACED：用于跟踪调试<br>成功返回终止子进程ID，失败返回-1</li>
</ul>
<p>waitpid可以实现非阻塞的等待操作，有时希望取得子进程的状态改变信息，但不希望阻塞父进程等待子进程状态改变</p>
<h2 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h2><ol>
<li>在一个已有进程中<strong>创建</strong>一个新线程比创建一个全新进程所需的时间少。</li>
<li><strong>终止</strong>一个线程比终止一个进程花费的时间少。</li>
<li>线程间<strong>切换</strong>比进程间切换花费的时间少。</li>
<li>线程提高了不同的执行程序间<strong>通信</strong>的效率。同一个进程中的线程共享存储空间和文件，它们无需调用内核就可以互相通信。</li>
</ol>
<h3 id="线程的引入"><a href="#线程的引入" class="headerlink" title="线程的引入"></a>线程的引入</h3><p>引入进程是为了使多个程序能够并发执行，以提高资源利用率和系统吞吐量；<br>引入线程是为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性<br> 进程的两个基本属性</p>
<ul>
<li>一个可拥有资源的独立单位</li>
<li>一个可调度和分派的基本单位</li>
</ul>
<p>调度和分派的部分通常称为<strong>线程</strong>或轻型进程，而资源所有权的部分通常称为<strong>进程</strong>。</p>
<h3 id="线程与进程的比较"><a href="#线程与进程的比较" class="headerlink" title="线程与进程的比较"></a>线程与进程的比较</h3><p>从调度性、并发性、系统开销和拥有资源等方面对线程和进程进行比较。<br>（线程必须在某个进程内执行 一个进程可以包含一个线程或多个线程）</p>
<h4 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h4><p>在传统的操作系统中，进程作为拥有资源和独立调度、分派的基本单位。而在引入线程的操作系统中，则把线程作为调度和分派的基本单位，而进程作为资源拥有的基本单位。</p>
<h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可并发执行，使得操作系统具有更好的并发性，从而能更加有效地提高系统资源的利用率和系统的吞吐量。</p>
<h4 id="拥有资源"><a href="#拥有资源" class="headerlink" title="拥有资源"></a>拥有资源</h4><p>一般而言，线程<strong>自己不拥有系统资源</strong>(也有一点必不可少的资源)，但它可以访问其隶属进程的资源，即一个进程的代码段、数据段及所拥有的系统资源，如已打开的文件、I/O 设备等，可以<strong>供</strong>该进程中的所有线程所共享。</p>
<h4 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h4><p>同一进程中的不同线程共享进程的内存空间和资源。<br>同一进程中的<strong>不同线程</strong>的独立性低于<strong>不同进程</strong>。</p>
<h4 id="系统开销"><a href="#系统开销" class="headerlink" title="系统开销"></a>系统开销</h4><p>线程的切换只需要保存和设置少量的寄存器内容，不涉及存储器管理方面的操作。<br>由于一个进程中的多个线程具有相同的地址空间，在同步和通信的实现方面线程也比进程容易。在一些操作系统中，线程的切换、同步和通信都无须操作系统内核的干预。（少）</p>
<h4 id="支持多处理机系统"><a href="#支持多处理机系统" class="headerlink" title="支持多处理机系统"></a>支持多处理机系统</h4><p>一个进程分为多个线程分配到多个处理机上并行执行，可加速进程的完成。</p>
<h3 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h3><ol>
<li>轻型实体<br> 线程自己基本不拥有系统资源，只拥有少量必不可少的资源：TCB，程序计数器、一组寄存器、栈。</li>
<li>独立调度和分派的基本单位<br> 在多线程OS中,线程是独立运行的基本单位,因而也是独立调度和分派的基本单位。</li>
<li>可并发执行<br> 同一进程中的多个线程之间可以并发执行，一个线程可以创建和撤消另一个线程。</li>
<li>共享进程资源<br> 它可与同属一个进程的其它线程共享进程所拥有的全部资源。</li>
</ol>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>同进程一样，线程之间也存在共享资源和相互合作的制约关系，致使线程在运行时也具有间断性。<br>线程运行时有以下3种状态：<br>①<strong>执行</strong>状态:表示线程正获得CPU而运行；<br>②<strong>就绪</strong>状态:表示线程已具备了各种运行条件，一旦获得CPU便可执行；<br>③<strong>阻塞</strong>状态:表示线程在运行中因某事件而受阻，处于暂停执行的状态；</p>
<h3 id="线程的组成"><a href="#线程的组成" class="headerlink" title="线程的组成"></a>线程的组成</h3><p>每个线程有一个TCB结构，即线程控制块，用于保存自己私有的信息，主要由以下部分组成：</p>
<ul>
<li>一个唯一的线程标识符；</li>
<li>一组寄存器 ：包括程序计数器、状态寄存器、通用寄存器的内容；</li>
<li>线程运行状态：用于描述线程正处于何种运行状态；</li>
<li>优先级：描述线程执行的优先程度；</li>
<li>线程专有存储器：用于保存线程自己的局部变量拷贝；</li>
<li>信号屏蔽：对某些信号加以屏蔽；</li>
<li>两个栈指针：核心栈、用户栈。</li>
</ul>
<h3 id="进程线程对比"><a href="#进程线程对比" class="headerlink" title="进程线程对比"></a>进程线程对比</h3><table>
<thead>
<tr>
<th>应用功能</th>
<th>线程</th>
<th>进程</th>
</tr>
</thead>
<tbody><tr>
<td>创建</td>
<td>pthread_create</td>
<td>fork,vfork</td>
</tr>
<tr>
<td>退出</td>
<td>pthread_exit</td>
<td>exit</td>
</tr>
<tr>
<td>等待</td>
<td>pthread_join</td>
<td>wait、waitpid</td>
</tr>
<tr>
<td>取消/终止</td>
<td>pthread_cancel</td>
<td>abort</td>
</tr>
<tr>
<td>读取ID</td>
<td>pthread_self()</td>
<td>getpid()</td>
</tr>
<tr>
<td>同步互斥/通信机制</td>
<td>互斥锁、条件变量、读写锁</td>
<td>无名管道、有名管道、信号、消息队列、信号量、共享内存</td>
</tr>
</tbody></table>
<h3 id="线程间的同步和通信"><a href="#线程间的同步和通信" class="headerlink" title="线程间的同步和通信"></a>线程间的同步和通信</h3><p>▪为使系统中的多线程能有条不紊的运行，系统必须提供用于实现线程间同步和通信的机制。在多线程OS中，通常提供多种同步机制:</p>
<ul>
<li>互斥锁(mutex) - 互斥锁是一种比较简单的、用于实现进程间对资源互斥访问的机制。 由于操作互斥锁的时间和空间开销都较低，因而较适合于高频度使用的关键共享数据和程序段。</li>
<li>条件变量 - 每一个条件变量通常都与一个互斥锁一起使用。 单纯的互斥锁用于短期锁定，主要是用来保证对临界区的互斥进入。而条件变量则用于线程的长期等待， 直至所等待的资源成为可用的。</li>
<li>信号量机制 - 当某线程需利用信号量来实现同一进程中各线程之间的同步时，可调用创建信号量的命令来创建一私用信号量，其数据结构存放在应用程序的地址空间中。</li>
</ul>
<h2 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h2><h3 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h3><p>用户级线程仅存在于用户空间中。对于这种线程的创建、撤消、线程之间的同步与通信等功能，都无须内核来实现。<br>优点：</p>
<ul>
<li>线程切换<strong>不调用内核</strong></li>
<li>调度是应用程序特定的：可以选择<strong>最好的算法</strong></li>
<li>可运行在任何操作系统上（只需要线程库），可以在一个<strong>不支持线程的OS</strong>上实现<br>缺点：</li>
<li>当线程执行一个系统调用时，该线程及其所属进程内的所有线程都会<strong>被阻塞</strong>。</li>
<li>多线程应用<strong>不能利用</strong>多处理机进行多重处理。</li>
</ul>
<h3 id="内核支持线程"><a href="#内核支持线程" class="headerlink" title="内核支持线程"></a>内核支持线程</h3><p>内核支持线程，是在内核的支持下运行的，即无论是用户进程中的线程，还是系统进程中的线程，他们的创建、撤消和切换等，是依靠内核实现的。<br>优点：</p>
<ul>
<li>在多处理器系统中，内核能够<strong>同时</strong>调度同一进程中多个线程并行执行；</li>
<li>如果进程中的一个线程被阻塞了，内核<strong>可以</strong>调度该进程中的其它线程占有处理器运行，也可以运行其它进程中的线程；</li>
<li>内核支持线程具有很小的数据结构和堆栈，线程的切换比较<strong>快</strong>，切换<strong>开销小</strong>；</li>
<li>内核本身也可以采用多线程技术，可以提高系统的执行<strong>速度和效率</strong>。<br>缺点：<br>对于线程切换而言，其模式切换的开销较大 在同一个进程中，从一个线程切换到另一个线程时，需要<strong>从用户态转到内核态再转到用户态</strong>进行，这是因为用户进程的线程在用户态运行，而线程调度和管理是在内核实现的，系统开销较大。</li>
</ul>
<h3 id="组合方式"><a href="#组合方式" class="headerlink" title="组合方式"></a>组合方式</h3><p>用户级线程是在用户空间实现的。所有用户级线程都具有相同的数据结构，它们都运行在一个中间系统上：<br>运行时系统（又称为线程库）<br>内核控制线程又称为轻型进程LWP<br><img src="/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1647413220791.png" alt="enter description here"></p>
<h2 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h2><ol>
<li><p>什么是前趋图？为什么要引入前趋图？<br>指一个有向无环图，用于描述进程之间执行的先后顺序</p>
</li>
<li><p>画出前趋图：S1:a=x+y;S2:b=z+1;S3:c=a-b;S4:w=c+1;<br><img src="/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" alt="未命名文件"></p>
</li>
<li><p>为什么要引入进程，会产生什么影响？<br>为了使程序并发的执行，并且可以对并发执行的程序加以描述与控制；使程序可以并发执行</p>
</li>
<li><p>从动态性、并发性和独立性的角度比较进程和程序<br>动态性：进程的实质是进程实体的执行过程，具有生命周期。而程序是静态的一组有序指令集。<br>并发性：进程可以并发执行。程序没有建立PCB不能并发执行。<br>独立性：进程是一个能够独立运行的、独立获得资源的、独立接受调度的基本单位。未建立PCB的程序不能独立参与运行</p>
</li>
<li><p>PCB的作用？为什么说PCB是进程唯一标志<br>PCB是进程实体的一部分，PCB使一个程序成为能够独立运行的基本单位，PCB描述进程的基本情况和活动过程，进而控制和管理进程。操作系统是通过PCB来对进程进行控制和管理的。</p>
</li>
<li><p>进程的三个基本状态转化原因<br>有1就绪状态——执行状态：进程调度<br>执行状态——就绪状态：时间片完成<br>执行状态——阻塞状态：I/O请求<br>阻塞状态——就绪状态：I/O完成</p>
</li>
<li><p>为什么要引入挂起状态，有什么性质？<br>有终端用户需求、父进程请求、负荷调节的需要、操作系统的需要；挂起状态进程静止不能被调度</p>
</li>
<li><p>进程切换时要保存的处理器状态信息有哪些？<br>通用寄存器、指令寄存器、程序状态寄存器、用户栈指针</p>
</li>
<li><p>引起进程创建的主要事件<br>用户登录、作业调度、提供服务、应用请求</p>
</li>
<li><p>引起进程撤销的主要事件<br>正常结束、异常结束（越界错、保护错、非法指令、特权指令错、运行超时、等待超时、算数运算错、I/O故障）、外界干扰（操作员或操作系统干预、父进程请求、因父进程终止而终止）</p>
</li>
<li><p>创建进程时所要完成的主要工作<br>申请空白PCB、为新进程分配资源、初始化PCB、插入就绪队列</p>
</li>
<li><p>引起进程阻塞或被唤醒的主要事件<br>请求共享资源失败、等待某种操作、新数据尚未到达、等待新任务</p>
</li>
<li><p>从调度性、并发性、拥有资源及系统开销方面对比进程与线程<br>调度性：线程作为调度和分派的基本单位，而进程作为资源拥有的基本单位。<br>并发性：均可并发执行。<br>拥有资源：进程是拥有资源的基本单位，线程只拥有必不可少的资源，本身不拥有系统资源，但可以访问隶属资源。<br>系统开销：在创建、撤销和切换进程的开销显著大于线程。</p>
</li>
<li><p>解释用户级线程与内核支持线程<br>用户级线程：用户级线程仅存在于用户空间中。对于这种线程的创建、撤消、线程之间的同步与通信等功能，都无须内核来实现。<br>内核支持线程：内核支持线程，是在内核的支持下运行的，即无论是用户进程中的线程，还是系统进程中的线程，他们的创建、撤消和切换等，是依靠内核实现的。</p>
</li>
</ol>
<h1 id="处理机调度与死锁"><a href="#处理机调度与死锁" class="headerlink" title="处理机调度与死锁"></a>处理机调度与死锁</h1><h2 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h2><ul>
<li>高级调度 - 又称长程调度或作业调度，将外存作业调入内存，创建PCB等，插入就绪队列。用于批处理系统。调度最慢</li>
<li>低级调度 - 又称进程调度或短程调度，决定就绪队列中的那个进程应获得处理机，并将处理机分配给选中的进程。调度最频繁</li>
<li>中级调度 - 又称内存调度，把外存上那些已经具备运行条件的就绪进程重新载入内存。从静止就绪到活动就绪。</li>
</ul>
<h2 id="处理机调度算法的目标"><a href="#处理机调度算法的目标" class="headerlink" title="处理机调度算法的目标"></a>处理机调度算法的目标</h2><h3 id="共同目标："><a href="#共同目标：" class="headerlink" title="共同目标："></a>共同目标：</h3><ul>
<li>资源利用率：使系统处理器和资源尽可能忙碌</li>
<li>公平性：为进程合理分配CPU时间，不会发生饥饿</li>
<li>平衡性：为不同类型进程平衡分配资源</li>
<li>策略强制执行：如安全策略可无条件准确执行</li>
</ul>
<h3 id="批处理系统的目标"><a href="#批处理系统的目标" class="headerlink" title="批处理系统的目标"></a>批处理系统的目标</h3><ul>
<li>平均周转时间短</li>
<li>系统吞吐量高：尽量多地选择短作业运行</li>
<li>处理机利用率高：尽量选择计算量大的作业</li>
</ul>
<h3 id="分时系统的目标"><a href="#分时系统的目标" class="headerlink" title="分时系统的目标"></a>分时系统的目标</h3><ul>
<li>响应时间快</li>
<li>均衡性：指系统响应时间的长短应与用户所请求服务的复杂性相适应。</li>
</ul>
<h3 id="实时系统的目标"><a href="#实时系统的目标" class="headerlink" title="实时系统的目标"></a>实时系统的目标</h3><ul>
<li>截至时间的保证：开始截止时间 完成截止时间 硬实时、软实时</li>
<li>可以预测性：对调度结果的可预见性</li>
</ul>
<h2 id="作业与作业调度"><a href="#作业与作业调度" class="headerlink" title="作业与作业调度"></a>作业与作业调度</h2><ul>
<li>作业 Job：用户提交给系统的一项相对独立的工作。程序+数据+作业说明书</li>
<li>作业步：在作业运行期间，每个作业都必须经过若干个相对独立，又相互关联的顺序加工步骤才能得到结果，每一个加工步骤称为一个作业步，各作业步之间存在着相互联系。</li>
<li>作业流：依次执行的作业步，作业步间非并行的。</li>
</ul>
<h3 id="作业控制块-JCB"><a href="#作业控制块-JCB" class="headerlink" title="作业控制块(JCB)"></a>作业控制块(JCB)</h3><p>作业在系统中存在的标志，保存了系统对作业进行管理和调度的全部信息。<br>通常包含：</p>
<ul>
<li>作业标识</li>
<li>用户名称</li>
<li>用户账号</li>
<li>作业类型(CPU 繁忙型、I/O 繁忙型、批量型、终端型)</li>
<li>作业状态</li>
<li>调度信息(CPU 繁忙型、I/O 繁忙型、批量型、终端型)</li>
<li>资源需求(预计运行时间、要求内存大小、要求 I/O 设备的类型和数量等)</li>
<li>资源使用情况等</li>
</ul>
<h3 id="作业运行的三个阶段和三种状态"><a href="#作业运行的三个阶段和三种状态" class="headerlink" title="作业运行的三个阶段和三种状态"></a>作业运行的三个阶段和三种状态</h3><p>收容阶段：后备状态<br>运行阶段：运行状态<br>完成阶段：完成状态</p>
<h3 id="作业调度的主要任务"><a href="#作业调度的主要任务" class="headerlink" title="作业调度的主要任务"></a>作业调度的主要任务</h3><ul>
<li>接纳多少个作业：太多会影响系统服务质量，如延长周转时间；太少会导致资源利用率和系统吞吐量太低</li>
<li>接纳哪些作业：将哪些作业从外存调入内存，取决于所采用的调度算法</li>
</ul>
<h3 id="先来先服务-FCFS-和短作业优先-SJF-调度算法"><a href="#先来先服务-FCFS-和短作业优先-SJF-调度算法" class="headerlink" title="先来先服务(FCFS)和短作业优先(SJF )调度算法"></a>先来先服务(FCFS)和短作业优先(SJF )调度算法</h3><p>在作业调度中是从后备队列调入内存运行。<br>在进程调度中则是从就绪队列中选出估计运行时间最短的进程分配处理机使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时，再重新调度。</p>
<h4 id="先来先服务："><a href="#先来先服务：" class="headerlink" title="先来先服务："></a>先来先服务：</h4><p>既可用于作业调度，也可用于进程调度。有利于长作业（进程），而不利于短作业（进程）。</p>
<h4 id="短作业-进程-优先调度算法SJ-P-F："><a href="#短作业-进程-优先调度算法SJ-P-F：" class="headerlink" title="短作业(进程)优先调度算法SJ(P)F："></a>短作业(进程)优先调度算法SJ(P)F：</h4><p>是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。<br>对长作业不利，不能保证紧迫性作业(进程)会被及时处理，根据用户所提供的估计执行时间而定不准确。</p>
<h3 id="优先级调度算法和高响应比优先调度算法"><a href="#优先级调度算法和高响应比优先调度算法" class="headerlink" title="优先级调度算法和高响应比优先调度算法"></a>优先级调度算法和高响应比优先调度算法</h3><p>优先级调度算法：<br>外部赋予作业（进程）相应的优先级，例如以作业的紧迫程度作为优先级。<br>选择优先级高的进程投入运行。既可用于作业调度算法，也可用于进程调度。</p>
<p>高响应比优先调度算法：<br>赋予作业动态优先级，优先级随作业等待时间延长而增加，从而使长作业的优先级在等待期间不断增加。<br>响应比Rp：<br><img src="/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1647848472429.png" alt="enter description here"><br>算法既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务</p>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="主要任务"><a href="#主要任务" class="headerlink" title="主要任务"></a>主要任务</h3><ul>
<li>保存处理机的现场信息</li>
<li>按某种算法选取进程</li>
<li>把处理机分配给进程<strong>strong text</strong></li>
</ul>
<h3 id="进程调度机制"><a href="#进程调度机制" class="headerlink" title="进程调度机制"></a>进程调度机制</h3><p><img src="/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1647853007722.png" alt="enter description here"></p>
<h3 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h3><h4 id="非抢占方式："><a href="#非抢占方式：" class="headerlink" title="非抢占方式："></a>非抢占方式：</h4><p>一旦进程投入运行，除了进程完成或者需要阻塞外，不能剥夺其处理机。<br>采用这种方式时，引起调度的原因可归结为： </p>
<ul>
<li>进程运行完毕或因发生某事件而无法继续运行</li>
<li>因I/O请求而阻塞</li>
<li>因通信或者同步而阻塞</li>
</ul>
<h4 id="抢占方式："><a href="#抢占方式：" class="headerlink" title="抢占方式："></a>抢占方式：</h4><p>允许根据某种原则，暂停正在执行的进程，重新分配处理机。<br>使用抢占式的原因： </p>
<ul>
<li>批处理：防止长进程长期占用CPU，公平</li>
<li>分时：人机交互</li>
<li>实时：紧迫任务的执行<br>主要原则</li>
<li>优先权</li>
<li>短进程优先</li>
<li>时间片原则</li>
</ul>
<h3 id="轮转调度算法-RR"><a href="#轮转调度算法-RR" class="headerlink" title="轮转调度算法(RR)"></a>轮转调度算法(RR)</h3><p>基于时间片轮转<br>原理： FCFS策略+时钟中断+时间片原则<br>时间片太小：利于短作业，但增大调度和上下文切换频率，增大系统开销； 时间片太长：退化为FCFS算法。 时间片合适：略大于一次典型的交互所需的时间，使大多数交互式进程能在一个时间片内完成。<br>当进程的时间片耗尽或运行完毕，系统将CPU分配给队首进程（或新到达紧迫进程）</p>
<h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h3><p>同样分为非抢占式和抢占式<br>对于优先级是的设立还分为静态优先权（简单，但低优先权作业可能长期不被调度）和动态优先权（长短兼顾 缺点：需计算 Rp=(等待时间＋服务时间)/服务时间 ）</p>
<h3 id="多队列调度算法"><a href="#多队列调度算法" class="headerlink" title="多队列调度算法"></a>多队列调度算法</h3><p>针对：不同用户的调度策略需求:实时/分时/批处理混合系统<br>和多CPU单就绪队列的问题:互斥访问导致效率不高<br>解决办法:<br>不同类型或者性质的进程组织在不同的队列中<br>每个CPU和一个队列，分配优化，CPU间队列均衡</p>
<h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><p>设置多个就绪队列，并为各个队列赋予不同的优先级。<br>优先级愈高的队列的进程的执行时间片就愈小。<br>新进程首先进入最高优先级的队列。每个队列采用FCFS算法。<strong>队列中的进程运行一个时间片后未结束则降级排到下一个队列的末尾</strong>。最低优先权队列中的进程则按RR方式运行。<br>按队列优先级调度。只有比队列的优先级高的队列均空时，才运行该队列中的进程。<br>特点：长、短作业兼顾，有较好的响应时间</p>
<h3 id="基于公平原则的调度算法"><a href="#基于公平原则的调度算法" class="headerlink" title="基于公平原则的调度算法"></a>基于公平原则的调度算法</h3><ol>
<li>保证调度算法 - 保证的是绝对运行时间，即启动后在某个时间段内必须获得多少运行时间。 例如N个进程平均分配时间。</li>
<li>公平分享调度算法 - 按照用户数量平均分配时间，而不是进程间平均分配。</li>
</ol>
<h2 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h2><p>实时调度必须满足实时任务对截至时间的要求</p>
<h3 id="实现实时调度的基本条件"><a href="#实现实时调度的基本条件" class="headerlink" title="实现实时调度的基本条件"></a>实现实时调度的基本条件</h3><ul>
<li>就绪时间</li>
<li>开始截止时间和完成截止时间</li>
<li>处理时间</li>
<li>资源要求</li>
<li>优先级</li>
</ul>
<p>单处理机条件下必须保证处理时间与截至时间之比小于1</p>
<h3 id="实时调度算法的分类"><a href="#实时调度算法的分类" class="headerlink" title="实时调度算法的分类"></a>实时调度算法的分类</h3><h4 id="非抢占式"><a href="#非抢占式" class="headerlink" title="非抢占式"></a>非抢占式</h4><p><img src="/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1647855224272.png" alt="enter description here"></p>
<ol>
<li>非抢占式轮转调度</li>
<li>非抢占式优先调度</li>
</ol>
<h4 id="抢占式"><a href="#抢占式" class="headerlink" title="抢占式"></a>抢占式</h4><ol>
<li>基于时钟中断的抢占式</li>
<li>立即抢占式</li>
</ol>
<h3 id="EDF最早截至时间算法"><a href="#EDF最早截至时间算法" class="headerlink" title="EDF最早截至时间算法"></a>EDF最早截至时间算法</h3><p>就绪队列按各任务截止时间的早晚排序；具有最早截止时间的任务排在队列的最前面。</p>
<h3 id="LLF最低松弛度优先算法"><a href="#LLF最低松弛度优先算法" class="headerlink" title="LLF最低松弛度优先算法"></a>LLF最低松弛度优先算法</h3><p>松弛度=完成截至时间–剩余运行时间–当前时间<br>按松弛度排序实时任务的就绪队列，松弛度值最小的任务排在队列最前面</p>
<h3 id="优先级倒置"><a href="#优先级倒置" class="headerlink" title="优先级倒置"></a>优先级倒置</h3><p>即高优先级进程(或线程)被低优先级进程(或线程)延迟或阻塞。<br>主要原因可能是较低优先级任务占用临界资源后未释放而切换任务执行<br>解决方法：</p>
<ul>
<li>规定进入临界区后不允许抢占</li>
<li>优先级继承机制(动态优先级)，即占用同样资源的低优先级进程继承需要资源的进程的高优先级</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="资源问题"><a href="#资源问题" class="headerlink" title="资源问题"></a>资源问题</h3><ul>
<li>可重用性资源(打印机)和消耗性资源(消息)</li>
<li>不可抢占性资源(打印机)</li>
</ul>
<h3 id="计算机系统的死锁"><a href="#计算机系统的死锁" class="headerlink" title="计算机系统的死锁"></a>计算机系统的死锁</h3><p>原因：</p>
<ol>
<li>竞争可重用资源、可消耗资源</li>
<li>进程间推进顺序非法。<br><img src="/2022/03/04/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1647855855262.png" alt="enter description here"></li>
</ol>
<h3 id="定义、必要条件和处理方法"><a href="#定义、必要条件和处理方法" class="headerlink" title="定义、必要条件和处理方法"></a>定义、必要条件和处理方法</h3><p>定义：如果一组进程中的每一个进程<strong>都在等待仅由该组进程中的其他进程才能引发的事件</strong>，那么该组进程是死锁的</p>
<p>四个条件：</p>
<ol>
<li>互斥条件：指进程对所分配到的资源进行排它性使用 。</li>
<li>请求和保持条件：指进程已经保持了至少一个资源，但又提出了新的资源请求 。</li>
<li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链 。</li>
</ol>
<h4 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h4><p>通过<strong>设置某些限制条件</strong>，去破坏产生死锁的四个必要条件中的一个或几个条件，来预防发生死锁。<br>预防死锁使四个必要条件中的第2、3、4条件之一不能成立</p>
<h5 id="破环条件2"><a href="#破环条件2" class="headerlink" title="破环条件2"></a>破环条件2</h5><p>通过：</p>
<ul>
<li>第一种协议<strong>规定开始运行之前，必须一次性申请所需的全部资源</strong></li>
<li>第二种协议规定进程在运行过程中要逐步释放已用资源再请求新资源</li>
<li>*优点**：简单、易于实现且很安全。</li>
<li>*缺点**：资源被严重浪费，使进程延迟运行。</li>
</ul>
<h5 id="破环条件3"><a href="#破环条件3" class="headerlink" title="破环条件3"></a>破环条件3</h5><p>当一个已经保持了某些资源的进程，再提出新的资源请求而<strong>不能立即得到满足</strong>时，必须释放它已经保持了的所有资源。待以后需要时再重新申请<br><strong>缺点</strong>：因反复地申请和释放资源，致使进程执行被无限推迟，延长进程周转时间、增加系统开销、降低吞吐量</p>
<h5 id="破环条件4"><a href="#破环条件4" class="headerlink" title="破环条件4"></a>破环条件4</h5><p>将所有资源按类型进行线性排队，并赋予不同的序号。 所有进程对资源的请求必须严格按照资源序号递增的次序提出<br><strong>优点</strong>：相比前两种提高了资源利用率和系统吞吐量<br><strong>缺点</strong>：各类资源分配的序号必须相对稳定限制了新设备类型的增加；作业使用顺序与系统规定顺序不同造成资源浪费；增加了程序设计难度。</p>
<h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><p>是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。<strong>不会事先设置限制</strong><br>安全状态是指系统能按某种进程顺序，使每个进程都可顺利地完成，称系统处于安全状态。</p>
<h5 id="Dijkstra银行家算法"><a href="#Dijkstra银行家算法" class="headerlink" title="Dijkstra银行家算法"></a>Dijkstra银行家算法</h5><p>可利用资源向量Available<br>最大需求矩阵Max<br>分配矩阵Allocation<br>需求矩阵Need<br>P120</p>
<h4 id="死锁的检测与解除"><a href="#死锁的检测与解除" class="headerlink" title="死锁的检测与解除"></a>死锁的检测与解除</h4><p>检测死锁：通过系统所设置的<strong>检测机构</strong>，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源；<br>解除死锁：当<strong>检测</strong>到系统中<strong>已</strong>发生死锁时，须将进程从死锁状态中<strong>解脱出来</strong>。常用的实施方法是撤消或挂起一些进程。<br><strong>配套使用</strong></p>
<h5 id="检测："><a href="#检测：" class="headerlink" title="检测："></a>检测：</h5><p>系统必须保存有关资源的请求和分配信息，根据信息通过<strong>资源分配图</strong>或<strong>死锁定理</strong>的方法检测死锁</p>
<h5 id="解除："><a href="#解除：" class="headerlink" title="解除："></a>解除：</h5><p>两种常用方法：抢占资源(使死锁进程抢占其它进程资源以完成进程解除死锁)、终止进程(终止或撤销死锁进程)<br>其中终止方法可终止所有死锁进程，更好是按付出代价最小算法逐个解除</p>
<h6 id="付出代价最小算法"><a href="#付出代价最小算法" class="headerlink" title="付出代价最小算法"></a>付出代价最小算法</h6><ul>
<li><p>一种找到付出代价最小的终止顺序，但成本高的算法：</p>
<ol>
<li> 先从死锁进程组中取出一个，形成第一层终止，若有n个死锁进程，则有n个第一层。</li>
<li> 再从n个第一层中取一个，形成第二层终止，每个第一层又有n-1个第二层终止。</li>
<li> 如此循环，直到解除死锁，将各层的总代价计算，得到最小的终止顺序。<br>理解为从最低代价开始依次找到导致死锁的最低代价进程</li>
</ol>
</li>
<li><p>另一种比较有效的算法：</p>
<ol>
<li> 找到死锁进程组中，终止代价最小的，将其从死锁进程组中删去。</li>
<li> 再从新的死锁进程组中，找到终止代价最小的，删去。</li>
<li> 如此循环，直到解除死锁。<br>理解为一直解除最低代价进程(不判断此时死锁是否由它导致)直到解除死锁</li>
</ol>
</li>
</ul>

    </div>

    
    
    

 
   <div>
     <div>
    
        <div style="text-align:center;color: #CDBE70;font-size:24px;">---------------THE<i class="fa fa-exclamation-triangle"></i>END---------------</div>
    
</div>
   </div>
 

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/01/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/" rel="prev" title="网络概述">
      <i class="fa fa-chevron-left"></i> 网络概述
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/04/%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="next" title="数据库">
      数据库 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA"><span class="nav-number">1.</span> <span class="nav-text">操作系统引论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87%E5%92%8C%E4%BD%9C%E7%94%A8"><span class="nav-number">1.1.</span> <span class="nav-text">目标和作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">发展过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="nav-number">1.3.</span> <span class="nav-text">基本特征</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="nav-number">1.4.</span> <span class="nav-text">主要功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD"><span class="nav-number">1.4.1.</span> <span class="nav-text">处理机管理功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD"><span class="nav-number">1.4.2.</span> <span class="nav-text">存储器管理功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD"><span class="nav-number">1.4.3.</span> <span class="nav-text">(I&#x2F;O)设备管理功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD"><span class="nav-number">1.4.4.</span> <span class="nav-text">文件管理功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%94%A8%E6%88%B7%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.4.5.</span> <span class="nav-text">操作系统与用户之间的接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.5.</span> <span class="nav-text">结构设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.1.</span> <span class="nav-text">无结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.2.</span> <span class="nav-text">模块化结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B1%82%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.3.</span> <span class="nav-text">分层式结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD"><span class="nav-number">1.5.4.</span> <span class="nav-text">文件管理功能### 文件管理功能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%A0%E9%A2%98"><span class="nav-number">1.6.</span> <span class="nav-text">习题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6"><span class="nav-number">2.</span> <span class="nav-text">进程的描述与控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%B6%8B%E5%9B%BE%E5%92%8C%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="nav-number">2.1.</span> <span class="nav-text">前趋图和程序执行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="nav-number">2.1.1.</span> <span class="nav-text">程序的顺序执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C"><span class="nav-number">2.1.2.</span> <span class="nav-text">程序的并发执行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="nav-number">2.2.</span> <span class="nav-text">进程的描述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="nav-number">2.2.1.</span> <span class="nav-text">典型定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E5%BE%81"><span class="nav-number">2.2.2.</span> <span class="nav-text">特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81"><span class="nav-number">2.2.3.</span> <span class="nav-text">状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PCB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.4.</span> <span class="nav-text">PCB数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PCB%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="nav-number">2.2.5.</span> <span class="nav-text">PCB的组织方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">2.3.</span> <span class="nav-text">进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8"><span class="nav-number">2.3.1.</span> <span class="nav-text">操作系统内核</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">2.3.2.</span> <span class="nav-text">进程的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">进程的层次结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E8%B5%B7%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">引起创建进程的事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">进程创建</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2"><span class="nav-number">2.3.3.</span> <span class="nav-text">进程的终止</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E8%B5%B7%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">引起进程终止的事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2%E8%BF%87%E7%A8%8B"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">进程的终止过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%94%A4%E9%86%92%E3%80%81%E6%8C%82%E8%B5%B7%E4%B8%8E%E6%BF%80%E6%B4%BB"><span class="nav-number">2.3.4.</span> <span class="nav-text">进程的阻塞与唤醒、挂起与激活</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E8%B5%B7%E8%BF%9B%E7%A8%8B%E9%98%BB%E5%A1%9E%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">引起进程阻塞的事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%98%BB%E5%A1%9E%E8%BF%87%E7%A8%8B"><span class="nav-number">2.3.4.2.</span> <span class="nav-text">进程阻塞过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%94%A4%E9%86%92%E8%BF%87%E7%A8%8B"><span class="nav-number">2.3.4.3.</span> <span class="nav-text">进程唤醒过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8C%82%E8%B5%B7"><span class="nav-number">2.3.4.4.</span> <span class="nav-text">进程的挂起</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%BF%80%E6%B4%BB"><span class="nav-number">2.3.4.5.</span> <span class="nav-text">进程的激活</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">2.4.</span> <span class="nav-text">进程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.4.1.</span> <span class="nav-text">进程同步的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">2.4.2.</span> <span class="nav-text">硬件同步机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="nav-number">2.4.3.</span> <span class="nav-text">信号量机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E5%BD%A2%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">整形信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">2.4.3.2.</span> <span class="nav-text">记录型信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AND%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">2.4.3.3.</span> <span class="nav-text">AND型信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%9B%86"><span class="nav-number">2.4.3.4.</span> <span class="nav-text">信号量集</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="nav-number">2.5.</span> <span class="nav-text">经典进程的同步问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E2%80%94%E2%80%94%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">2.5.1.</span> <span class="nav-text">生产者——消费者问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%A7%A3%E5%86%B3"><span class="nav-number">2.5.1.1.</span> <span class="nav-text">记录型信号量解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AND%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%A7%A3%E5%86%B3"><span class="nav-number">2.5.1.2.</span> <span class="nav-text">AND信号量解决</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="nav-number">2.5.2.</span> <span class="nav-text">哲学家进餐问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AND%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%A7%A3%E5%86%B3-1"><span class="nav-number">2.5.2.1.</span> <span class="nav-text">AND信号量解决</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E8%80%85%E2%80%94%E2%80%94%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">2.5.3.</span> <span class="nav-text">读者——写者问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%A7%A3%E5%86%B3-1"><span class="nav-number">2.5.3.1.</span> <span class="nav-text">记录型信号量解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%9B%86%E8%A7%A3%E5%86%B3"><span class="nav-number">2.5.3.2.</span> <span class="nav-text">信号量集解决</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-number">2.6.</span> <span class="nav-text">进程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.6.1.</span> <span class="nav-text">类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E9%80%9A%E4%BF%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="nav-number">2.6.2.</span> <span class="nav-text">消息传递通信的实现方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F"><span class="nav-number">2.6.3.</span> <span class="nav-text">消息格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F"><span class="nav-number">2.6.4.</span> <span class="nav-text">消息格式进程同步方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E4%B8%8E%E7%9B%91%E6%8E%A7"><span class="nav-number">2.7.</span> <span class="nav-text">进程运行与监控</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="nav-number">2.7.1.</span> <span class="nav-text">Linux进程控制块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#task-struct%E7%BB%93%E6%9E%84"><span class="nav-number">2.7.1.1.</span> <span class="nav-text">task_struct结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#task-struct-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">2.7.1.2.</span> <span class="nav-text">task_struct:进程状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2"><span class="nav-number">2.7.1.3.</span> <span class="nav-text">进程状态切换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#task-struct-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="nav-number">2.7.1.4.</span> <span class="nav-text">task_struct:文件管理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8"><span class="nav-number">2.7.2.</span> <span class="nav-text">进程的启动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fork"><span class="nav-number">2.7.2.1.</span> <span class="nav-text">fork</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80"><span class="nav-number">2.7.2.2.</span> <span class="nav-text">进程内存空间布局</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BF%90%E8%A1%8C%E6%8E%A7%E5%88%B6"><span class="nav-number">2.7.3.</span> <span class="nav-text">进程的运行控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">2.7.3.1.</span> <span class="nav-text">设置环境变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#exec%E7%B3%BB%E5%88%97%E5%87%BD%E6%95%B0"><span class="nav-number">2.7.3.2.</span> <span class="nav-text">exec系列函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%9B%91%E6%B5%8B"><span class="nav-number">2.7.4.</span> <span class="nav-text">进程的监测</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B%E5%87%BD%E6%95%B0"><span class="nav-number">2.7.4.1.</span> <span class="nav-text">终止进程函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E7%9F%A5%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%94%B9%E5%8F%98"><span class="nav-number">2.7.4.2.</span> <span class="nav-text">获知子进程状态改变</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#wait%E5%87%BD%E6%95%B0"><span class="nav-number">2.7.4.2.1.</span> <span class="nav-text">wait函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#waitpid%E5%87%BD%E6%95%B0"><span class="nav-number">2.7.4.2.2.</span> <span class="nav-text">waitpid函数</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.8.</span> <span class="nav-text">线程的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%95%E5%85%A5"><span class="nav-number">2.8.1.</span> <span class="nav-text">线程的引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">2.8.2.</span> <span class="nav-text">线程与进程的比较</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6"><span class="nav-number">2.8.2.1.</span> <span class="nav-text">调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91"><span class="nav-number">2.8.2.2.</span> <span class="nav-text">并发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%A5%E6%9C%89%E8%B5%84%E6%BA%90"><span class="nav-number">2.8.2.3.</span> <span class="nav-text">拥有资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8B%AC%E7%AB%8B%E6%80%A7"><span class="nav-number">2.8.2.4.</span> <span class="nav-text">独立性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E5%BC%80%E9%94%80"><span class="nav-number">2.8.2.5.</span> <span class="nav-text">系统开销</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.8.2.6.</span> <span class="nav-text">支持多处理机系统</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">2.8.3.</span> <span class="nav-text">线程的属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">2.8.4.</span> <span class="nav-text">线程的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-number">2.8.5.</span> <span class="nav-text">线程的组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%AF%B9%E6%AF%94"><span class="nav-number">2.8.6.</span> <span class="nav-text">进程线程对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E5%90%8C%E6%AD%A5%E5%92%8C%E9%80%9A%E4%BF%A1"><span class="nav-number">2.8.7.</span> <span class="nav-text">线程间的同步和通信</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">2.9.</span> <span class="nav-text">线程的实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.9.1.</span> <span class="nav-text">用户级线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%94%AF%E6%8C%81%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.9.2.</span> <span class="nav-text">内核支持线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%96%B9%E5%BC%8F"><span class="nav-number">2.9.3.</span> <span class="nav-text">组合方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%A0%E9%A2%98-1"><span class="nav-number">2.10.</span> <span class="nav-text">习题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81"><span class="nav-number">3.</span> <span class="nav-text">处理机调度与死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E5%B1%82%E6%AC%A1"><span class="nav-number">3.1.</span> <span class="nav-text">处理机调度的层次</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="nav-number">3.2.</span> <span class="nav-text">处理机调度算法的目标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E5%90%8C%E7%9B%AE%E6%A0%87%EF%BC%9A"><span class="nav-number">3.2.1.</span> <span class="nav-text">共同目标：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="nav-number">3.2.2.</span> <span class="nav-text">批处理系统的目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="nav-number">3.2.3.</span> <span class="nav-text">分时系统的目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="nav-number">3.2.4.</span> <span class="nav-text">实时系统的目标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A%E4%B8%8E%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6"><span class="nav-number">3.3.</span> <span class="nav-text">作业与作业调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6%E5%9D%97-JCB"><span class="nav-number">3.3.1.</span> <span class="nav-text">作业控制块(JCB)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A%E8%BF%90%E8%A1%8C%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5%E5%92%8C%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="nav-number">3.3.2.</span> <span class="nav-text">作业运行的三个阶段和三种状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BB%BB%E5%8A%A1"><span class="nav-number">3.3.3.</span> <span class="nav-text">作业调度的主要任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1-FCFS-%E5%92%8C%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88-SJF-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">3.3.4.</span> <span class="nav-text">先来先服务(FCFS)和短作业优先(SJF )调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%EF%BC%9A"><span class="nav-number">3.3.4.1.</span> <span class="nav-text">先来先服务：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9F%AD%E4%BD%9C%E4%B8%9A-%E8%BF%9B%E7%A8%8B-%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95SJ-P-F%EF%BC%9A"><span class="nav-number">3.3.4.2.</span> <span class="nav-text">短作业(进程)优先调度算法SJ(P)F：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E5%92%8C%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">3.3.5.</span> <span class="nav-text">优先级调度算法和高响应比优先调度算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-number">3.4.</span> <span class="nav-text">进程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E4%BB%BB%E5%8A%A1"><span class="nav-number">3.4.1.</span> <span class="nav-text">主要任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6"><span class="nav-number">3.4.2.</span> <span class="nav-text">进程调度机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F"><span class="nav-number">3.4.3.</span> <span class="nav-text">进程调度方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E6%8A%A2%E5%8D%A0%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">非抢占方式：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%A2%E5%8D%A0%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="nav-number">3.4.3.2.</span> <span class="nav-text">抢占方式：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95-RR"><span class="nav-number">3.4.4.</span> <span class="nav-text">轮转调度算法(RR)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">3.4.5.</span> <span class="nav-text">优先级调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">3.4.6.</span> <span class="nav-text">多队列调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">3.4.7.</span> <span class="nav-text">多级反馈队列调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%85%AC%E5%B9%B3%E5%8E%9F%E5%88%99%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">3.4.8.</span> <span class="nav-text">基于公平原则的调度算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6"><span class="nav-number">3.5.</span> <span class="nav-text">实时调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9D%A1%E4%BB%B6"><span class="nav-number">3.5.1.</span> <span class="nav-text">实现实时调度的基本条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">3.5.2.</span> <span class="nav-text">实时调度算法的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E6%8A%A2%E5%8D%A0%E5%BC%8F"><span class="nav-number">3.5.2.1.</span> <span class="nav-text">非抢占式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%A2%E5%8D%A0%E5%BC%8F"><span class="nav-number">3.5.2.2.</span> <span class="nav-text">抢占式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EDF%E6%9C%80%E6%97%A9%E6%88%AA%E8%87%B3%E6%97%B6%E9%97%B4%E7%AE%97%E6%B3%95"><span class="nav-number">3.5.3.</span> <span class="nav-text">EDF最早截至时间算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LLF%E6%9C%80%E4%BD%8E%E6%9D%BE%E5%BC%9B%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95"><span class="nav-number">3.5.4.</span> <span class="nav-text">LLF最低松弛度优先算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E5%80%92%E7%BD%AE"><span class="nav-number">3.5.5.</span> <span class="nav-text">优先级倒置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">3.6.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98"><span class="nav-number">3.6.1.</span> <span class="nav-text">资源问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%AD%BB%E9%94%81"><span class="nav-number">3.6.2.</span> <span class="nav-text">计算机系统的死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E3%80%81%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%E5%92%8C%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="nav-number">3.6.3.</span> <span class="nav-text">定义、必要条件和处理方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="nav-number">3.6.3.1.</span> <span class="nav-text">预防死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A0%B4%E7%8E%AF%E6%9D%A1%E4%BB%B62"><span class="nav-number">3.6.3.1.1.</span> <span class="nav-text">破环条件2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A0%B4%E7%8E%AF%E6%9D%A1%E4%BB%B63"><span class="nav-number">3.6.3.1.2.</span> <span class="nav-text">破环条件3</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A0%B4%E7%8E%AF%E6%9D%A1%E4%BB%B64"><span class="nav-number">3.6.3.1.3.</span> <span class="nav-text">破环条件4</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-number">3.6.3.2.</span> <span class="nav-text">避免死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Dijkstra%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="nav-number">3.6.3.2.1.</span> <span class="nav-text">Dijkstra银行家算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%A7%A3%E9%99%A4"><span class="nav-number">3.6.3.3.</span> <span class="nav-text">死锁的检测与解除</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%EF%BC%9A"><span class="nav-number">3.6.3.3.1.</span> <span class="nav-text">检测：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E9%99%A4%EF%BC%9A"><span class="nav-number">3.6.3.3.2.</span> <span class="nav-text">解除：</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%98%E5%87%BA%E4%BB%A3%E4%BB%B7%E6%9C%80%E5%B0%8F%E7%AE%97%E6%B3%95"><span class="nav-number">3.6.3.3.2.1.</span> <span class="nav-text">付出代价最小算法</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dyinjin"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">dyinjin</p>
  <div class="site-description" itemprop="description">摸鱼窝</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">64</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fas fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dyinjin</span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">本博客全站共168.7k字呐~</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,120,50' opacity='0.3' zIndex='-2' count='100' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
<div class="moon-menu">
  <div class="moon-menu-items">
    
    <div id="moon-menu-item-back2bottom" class="moon-menu-item">
      <i class='fas fa-chevron-down'></i>    </div>
    
    <div id="moon-menu-item-back2top" class="moon-menu-item">
      <i class='fas fa-chevron-up'></i>    </div>
    
  </div>
  <div class="moon-menu-button">
    <svg class="moon-menu-bg">
      <circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle>
      <circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle>
    </svg>
    <div class="moon-menu-content">
      <div class="moon-menu-icon"><i class='fas fa-ellipsis-v'></i></div>
      <div class="moon-menu-text"></div>
    </div>
  </div>
</div><script src="/js/injector.js"></script>
</body>
</html>
