<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":250,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":false,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="存储器管理存储器的层次结构速度从高到低、容量从小到大 存储器管理的目的和功能 主存储器的分配和管理 提高主存储器的利用率 “扩充”主存容量 存储保护  存储分配的三种方式 直接指定方式（汇编地址写入） 静态分配方式（程序装入时确定位置） 动态分配方式  程序的装入和链接将用户源程序变为可在内存中执行的程序：   编译 翻译成机器级代码  链接 使目标模块链接（引用的其它模块）成装入模块的过程  装">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机操作系统(4)存储器">
<meta property="og:url" content="http://example.com/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/index.html">
<meta property="og:site_name" content="岛屿尽">
<meta property="og:description" content="存储器管理存储器的层次结构速度从高到低、容量从小到大 存储器管理的目的和功能 主存储器的分配和管理 提高主存储器的利用率 “扩充”主存容量 存储保护  存储分配的三种方式 直接指定方式（汇编地址写入） 静态分配方式（程序装入时确定位置） 动态分配方式  程序的装入和链接将用户源程序变为可在内存中执行的程序：   编译 翻译成机器级代码  链接 使目标模块链接（引用的其它模块）成装入模块的过程  装">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/1650529219846.png">
<meta property="og:image" content="http://example.com/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/1650532050974.png">
<meta property="og:image" content="http://example.com/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/1650616504120.png">
<meta property="og:image" content="http://example.com/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/1650618210434.png">
<meta property="og:image" content="http://example.com/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/1650618215534.png">
<meta property="og:image" content="http://example.com/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/1650619179190.png">
<meta property="article:published_time" content="2022-04-20T06:51:07.589Z">
<meta property="article:modified_time" content="2022-05-08T05:33:14.286Z">
<meta property="article:author" content="dyinjin">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/1650529219846.png">

<link rel="canonical" href="http://example.com/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<link rel="stylesheet" type="text/css" href="/css/injector/main.css" /><link rel="preload" as="style" href="/css/injector/light.css" /><link rel="preload" as="style" href="/css/injector/dark.css" />
  <title>计算机操作系统(4)存储器 | 岛屿尽</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">岛屿尽</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">dyingjin</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-cube fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-bookmark fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-cubes fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-server fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dyinjin">
      <meta itemprop="description" content="摸鱼窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛屿尽">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机操作系统(4)存储器
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-20 14:51:07" itemprop="dateCreated datePublished" datetime="2022-04-20T14:51:07+08:00">2022-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-08 13:33:14" itemprop="dateModified" datetime="2022-05-08T13:33:14+08:00">2022-05-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h1><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><p><img src="/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/1650529219846.png" alt="enter description here"><br>速度从高到低、容量从小到大</p>
<h3 id="存储器管理的目的和功能"><a href="#存储器管理的目的和功能" class="headerlink" title="存储器管理的目的和功能"></a>存储器管理的目的和功能</h3><ul>
<li>主存储器的分配和管理</li>
<li>提高主存储器的利用率</li>
<li>“扩充”主存容量</li>
<li>存储保护</li>
</ul>
<h3 id="存储分配的三种方式"><a href="#存储分配的三种方式" class="headerlink" title="存储分配的三种方式"></a>存储分配的三种方式</h3><ul>
<li>直接指定方式（汇编地址写入）</li>
<li>静态分配方式（程序装入时确定位置）</li>
<li>动态分配方式</li>
</ul>
<h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><p>将用户源程序变为可在内存中执行的程序：</p>
<ul>
<li> 编译 翻译成机器级代码</li>
<li> 链接 使目标模块链接（引用的其它模块）成装入模块的过程</li>
<li> 装入 由装入程序将装入模块装入内存并执行</li>
</ul>
<h3 id="程序的装入"><a href="#程序的装入" class="headerlink" title="程序的装入"></a>程序的装入</h3><ul>
<li>绝对装入方式</li>
<li>可重定位装入方式（静态、动态）</li>
<li>动态运行时装入方式</li>
</ul>
<h3 id="程序的链接"><a href="#程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h3><ul>
<li>静态链接</li>
<li>装入时动态链接</li>
<li>运行时动态链接</li>
</ul>
<h2 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h2><p>程序空间本来就是连续的用连续的内存装入连续的程序，减少管理工作的难度</p>
<ul>
<li><p>单一连续分配方式（一个进程在内存）</p>
<ul>
<li>优点：易于管理</li>
<li>缺点：对要求内存空间少的程序，造成内存浪费；程序全部装入，很少使用的程序部分也占用内存。</li>
</ul>
</li>
<li><p>分区式分配方式（一个进程占据一个分区）</p>
<ul>
<li>固定分区分配<ul>
<li>易于实现，开销小</li>
<li>内碎片造成浪费；分区总数固定，限制了并发执行的程序数目；存储空间的利用率太低</li>
</ul>
</li>
<li>动态分区分配——分区分配算法</li>
</ul>
</li>
</ul>
<ul>
<li>可重定位分区分配 定时把存储空间中的空白区合并为一个大的连续区 之前的可变式分区分配根据其要求量为其划定相应的区域。消除了 “内零头”，但造成“外零头”</li>
</ul>
<h3 id="分区分配算法"><a href="#分区分配算法" class="headerlink" title="分区分配算法"></a>分区分配算法</h3><p><img src="/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/1650532050974.png" alt="enter description here"></p>
<ul>
<li>内零头(Internal Fragment)：分配给用户但用户没有使用的空间 “多分配的空间”</li>
<li>外零头(External Fragment )：没有分配但无法分配的空间，太小而无法分配，“分不出去的空间”</li>
</ul>
<h4 id="最佳适应算法BF"><a href="#最佳适应算法BF" class="headerlink" title="最佳适应算法BF"></a>最佳适应算法BF</h4><p>选择分区时总是寻找其大小最接近作业所要求的存储区域</p>
<ul>
<li>优点：遇到大作业到来时，比较容易得到满足</li>
<li>缺点： 留下许多无法使用的空白区；回收时，把它插入空白区链也颇为费时</li>
</ul>
<h4 id="最坏适应算法WF"><a href="#最坏适应算法WF" class="headerlink" title="最坏适应算法WF"></a>最坏适应算法WF</h4><p>寻找最大的空白区</p>
<ul>
<li>缺点：将大空间分给了小作业后大作业来到无法满足申请</li>
</ul>
<h4 id="首次适应算法FF"><a href="#首次适应算法FF" class="headerlink" title="首次适应算法FF"></a>首次适应算法FF</h4><p>空白区链的始端开始查找，选择第一个足以满足请求的空白块<br>分配后空白区被分成两部分一部分分配给作业；剩下的部分留在原空白区链中</p>
<ul>
<li>优点：简单，查找速度快</li>
<li>缺点：存储空间利用率不高；找到合适空白区的速度降低。</li>
</ul>
<h4 id="循环首次适应算法NF"><a href="#循环首次适应算法NF" class="headerlink" title="循环首次适应算法NF"></a>循环首次适应算法NF</h4><p>（下次适应算法）从上次查找结束的地方开始，找到一个足够大的空白区，就分配</p>
<ul>
<li>优点：存储空间的利用更加均衡</li>
<li>缺点：需要获得相当大的空白区时，很难满足</li>
</ul>
<h4 id="快速适应算法QF"><a href="#快速适应算法QF" class="headerlink" title="快速适应算法QF"></a>快速适应算法QF</h4><p>每一类具有<strong>相同容量</strong>的空闲分区，单独设立一个空闲分区链表<br>在内存中设立一张<strong>索引表</strong>，每一个表项记录空闲分区链表表头的指针<br>分配过程：根据进程的长度，寻找到能容纳它的最小空闲分区链表，并取下第一块进行分配即可</p>
<ul>
<li>优点：查找效率高；满足对大空间的需求，也不会产生内存碎片</li>
<li>缺点：分区归还算法复杂，系统开销较大；以进程为单位，存在一定的浪费</li>
</ul>
<h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h4><p>固定分区分配：并发执行的进程数量受到限制；内部碎片影响内存利用率<br>动态分区分配：算法复杂，回收分区时系统开销大</p>
<p>在伙伴系统中，可用内存块的大小为 2^k (1≤k≤m) </p>
<ul>
<li>2^1表示分配的最小块的尺寸；</li>
<li>2^m表示分配的最大块的尺寸，通常是可供分配的整个内存空间的大小。</li>
</ul>
<p>对空闲区按照大小分类，相同大小的分区链接为一个双向空闲链表；最多可形成 k（0 ≤k≤m ）个链表。</p>
<h2 id="分页存储管理方式"><a href="#分页存储管理方式" class="headerlink" title="分页存储管理方式"></a>分页存储管理方式</h2><h3 id="引入分页"><a href="#引入分页" class="headerlink" title="引入分页"></a>引入分页</h3><ul>
<li>离散分配方式的引入：<br>  连续分配方式会产生内/外零头<br>  为解决零头问题又要进行紧凑等高开销活动 </li>
<li>什么是离散分配：程序在内存中不一定连续存放 </li>
<li>根据离散时的基本单位不同，可分为三种：<br>  分页存储管理<br>  分段存储管理<br>  段页式存储管理</li>
</ul>
<h4 id="分页存储管理基本思想"><a href="#分页存储管理基本思想" class="headerlink" title="分页存储管理基本思想"></a>分页存储管理基本思想</h4><ul>
<li>离散的基础<pre><code>分页(Pages)：将程序地址空间分页
分块(Frames)：将内存空间分块
</code></pre>
</li>
<li>离散分配的体现<ul>
<li>内存一块可以装入程序一页</li>
<li>连续的多个页不一定装入连续的多个块中</li>
<li>注：系统中页块的大小是不变的。</li>
</ul>
</li>
</ul>
<p>离散分配没有外零头，且内零头肯定少于一个页面</p>
<h4 id="分页存储管理的基本方法"><a href="#分页存储管理的基本方法" class="headerlink" title="分页存储管理的基本方法"></a>分页存储管理的基本方法</h4><p>如何建立程序空间与主存空间的映射——页表<br>如何进行地址变换——从程序逻辑地址到内存物理地址</p>
<h4 id="页面和物理块"><a href="#页面和物理块" class="headerlink" title="页面和物理块"></a>页面和物理块</h4><ul>
<li>页面或页(Page)：把每个进程的逻辑地址空间分成一些大小相等的片。</li>
<li>物理块或页框(Page Frame)：内存空间也分成与页相同大小的若干存储块。在为进程分配存储空间时，总是以页框为单位。</li>
</ul>
<p>页面大小由机器的地址结构决定通常在1KB~8KB之间。</p>
<h4 id="实现分页存储管理的数据结构"><a href="#实现分页存储管理的数据结构" class="headerlink" title="实现分页存储管理的数据结构"></a>实现分页存储管理的数据结构</h4><ul>
<li>页表：进程，描述该进程的各页面在内存中对应的物理块号。页表中包括页号、物理块号。</li>
<li>作业表：系统，记录作业的页表情况。</li>
<li>空闲块表：系统，记录主存当前空闲块。</li>
</ul>
<h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><p>使用寄存器：速度快，成本高<br>一般将页表存在内存进程的PCB中，运行时再装入页表寄存器PTR</p>
<p>分页系统中的地址变换过程如下：</p>
<ol>
<li>根据逻辑地址,<strong>计算出页号和页内偏移量</strong>；</li>
<li>从PTR中得到页表首址，然后<strong>检索页表</strong>，查找指定页面对应的<strong>页框号</strong>；</li>
<li>用页框号乘以页面大小获得其对应的<strong>起始地址</strong>，并将其送入物理地址的<strong>高端</strong>。</li>
<li>将<strong>页内偏移量</strong>送入物理地址低端，<strong>形成完整的物理地址</strong>。</li>
</ol>
<h3 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h3><p>快表TLB为了提高地址变换速度，为进程页表设置一个<strong>专用的高速缓冲存储器</strong>其中专门保存<strong>当前进程最近访问过</strong>的一组页表项。<br>根据逻辑地址中的页号，会先查找快表中是否存在对应的页表项。<br>若快表中存在该表项，称为<strong>命中</strong>，取出其中的页框号加上页内偏移量计算出物理地址。<br>若快表中不存在该页表项，称为<strong>命中失败</strong>，则再查找页表，找到逻辑地址中指定页号对应的页框号。<br>同时，更新快表，将该表项插入快表中。</p>
<h4 id="访问内存的有效时间-EAT"><a href="#访问内存的有效时间-EAT" class="headerlink" title="访问内存的有效时间 EAT"></a>访问内存的有效时间 EAT</h4><p>命中率a、查找快表时间b、访问内存时间c<br>有效访问时间EAT=a ✖ （b+c）+ (1- a) ✖ (b+2c)</p>
<h3 id="两级和多级页表"><a href="#两级和多级页表" class="headerlink" title="两级和多级页表"></a>两级和多级页表</h3><p>引入两级页表采用离散分配方式，来解决难以找到一块连续的大内存空间的问题</p>
<p>利用离散分配方法实现的两级页表只是解决了大页表无需大片<strong>连续</strong>存储空间问题，但并未减少<strong>用较少内存去存放大页表</strong>问题，有关此类问题的成功解决方案在虚拟存储器管理中。</p>
<h3 id="反置页表IPT"><a href="#反置页表IPT" class="headerlink" title="反置页表IPT"></a>反置页表IPT</h3><p>为了解决大页表问题占内存多现象，减少内存开销，避免一个进程一个页表。</p>
<p>IPT采用为主存中的每一个物理块建立一个页表项并按照块号排序，该表每个表项包含正在访问该物理块的进程标识、页号及特征位，用来完成主存物理块到访问进程的页号的转换。</p>
<p><strong>即反过来查，原来是进程查物理现在是物理地址记录进程</strong></p>
<h2 id="对换"><a href="#对换" class="headerlink" title="对换"></a>对换</h2><p>对换就是把内存中暂时不用的程序和数据换到外存，或把需要的程序和数据换入内存。<br>分为：</p>
<ul>
<li>整体对换 以进程为单位</li>
<li>页面/分段对换：以页或段为单位</li>
</ul>
<h2 id="分段存储管理方式"><a href="#分段存储管理方式" class="headerlink" title="分段存储管理方式"></a>分段存储管理方式</h2><p>根据程序模块化设计时会将程序分段（如主程序段、子程序段、数据段等）而分段管理便是按程序模块化设计思想分段存储。</p>
<ul>
<li>作业地址空间按逻辑信息的完整性被划分为若干个段；</li>
<li>段内的地址空间是连续的；</li>
<li>许多编译程序支持分段方式，自动根据源程序的情况产生若干个段。</li>
</ul>
<p>分段较分页易于实现段的共享和段的保护。</p>
<h2 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h2><ul>
<li>分页管理内存管理效率高<ul>
<li>没有外零头</li>
<li>内零头小</li>
</ul>
</li>
<li>分段管理符合模块化思想<ul>
<li>每个分段都具备完整的功能</li>
<li>方便代码共享、保护</li>
<li>没有内零头，存在外零头</li>
</ul>
</li>
</ul>
<p>段页式管理结合：先将用户程序分段，每段内再划分成若干页，每段有段号，每段内部的页有一连续的页号。</p>
<p>但在段页式存储管理方式中，每访问一次数据，需访问三次内存。 访问段表、访问页表、访问相应数据，大大降低了访问速度。<br>可以设置快表，表项应包括段号、页号、物理块号。</p>
<p>总结：</p>
<ul>
<li>综合了分段和分页技术的优点，既能有效地利用存储空间，又能方便用户进行程序设计</li>
<li>但是，实现段页式存储管理系统需要增加硬件成本，系统的复杂度和管理开销也大大增加</li>
<li>因此，段页式存储管理技术适合于大、中型计算机系统，不太适合小型、微型计算机系统</li>
</ul>
<h1 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h1><h2 id="虚拟存储器概述"><a href="#虚拟存储器概述" class="headerlink" title="虚拟存储器概述"></a>虚拟存储器概述</h2><p>传统内存管理的一次性和驻留性严重降低内存利用率，减少系统吞吐量<br>当一个程序要求的存储容量超过内存，或大量作业需要内存空间时<br>从物理上增加内存容量，增加系统成本，并且增加是有限的。<br>所以从逻辑上增加内存容量，是虚拟存储技术所要解决的主要问题。</p>
<p>当进程运行时，先将当前<strong>要运行的部分程序装入内存</strong>，其他部分暂留外存；<br>当要执行的指令不在内存时，处理器发生中断，通知操作系统将所缺部分从外存调入内存，保证程序继续执行；<br>当内存不足时，允许程序部分换入、换出。<br><img src="/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/1650616504120.png" alt="enter description here"></p>
<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>程序的执行总是呈现局部性。即在一个较短的时间段内，程序的执行仅限于某个部分。因此只要保证进程<strong>执行所需</strong>的部分程序和数据<strong>驻留在内存</strong>，一段时间内进程都能顺利执行。</p>
<p>具体表现为</p>
<ul>
<li>时间局限性 被访问过的数据可能再次被访问</li>
<li>空间局限性 被访问过的存储单元其附近也可能被访问</li>
</ul>
<h3 id="虚拟存储器的定义"><a href="#虚拟存储器的定义" class="headerlink" title="虚拟存储器的定义"></a>虚拟存储器的定义</h3><p><strong>虚拟存储器</strong>：是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。<br>是一种性能非常优越的存储器管理技术，故被广泛地应用于大、中、小型机器和微型机中。</p>
<h3 id="虚拟存储器的特征"><a href="#虚拟存储器的特征" class="headerlink" title="虚拟存储器的特征"></a>虚拟存储器的特征</h3><ul>
<li><strong>多次性</strong> 多次性是指一个作业被分成多次调入内存运行。相对传统储存管理的<strong>一次性</strong></li>
<li><strong>对换性</strong> 对换性是指作业的运行过程中进行换进、换出。换进和换出能有效地提高内存利用率。相对传统储存管理的常驻性</li>
<li><strong>虚拟性</strong> 虚拟性是指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。</li>
</ul>
<h2 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h2><p><strong>工作原理</strong>：作业运行时，只将当前的一部分装入内存其余的放在辅存，一旦发现访问的页不在主存中，则发出缺页中断，由OS将其从辅存调入主存，如果内存无空块，则根据某种算法选择一个页淘汰以便装入新的页面。</p>
<p>利用这种方法，可使更多的作业处于就绪状态，且能支持比主存容量大的作业在系统中运行。从而提高存储空间利用率。</p>
<p>为了实现请求调页、页面置换两大功能，系统必须提供如下的硬件支持：</p>
<ol>
<li>请求分页的页表机制。</li>
<li>缺页中断机构。</li>
<li>地址变换机构。</li>
</ol>
<h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><ul>
<li>固定分配局部置换 但是难以确定进程合适的分配大小</li>
<li>可变分配全局置换（常用方式）预先分配用完再加</li>
<li>可变分配局部置换 发现缺页后要换出再自行换入，不干涉其它区域</li>
</ul>
<h3 id="物理块分配算法"><a href="#物理块分配算法" class="headerlink" title="物理块分配算法"></a>物理块分配算法</h3><ul>
<li>平均分配算法</li>
<li>按比例分配算法 根据进程的大小</li>
<li>考虑优先权的分配算法</li>
</ul>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><h3 id="最佳-优-置换算法OPT"><a href="#最佳-优-置换算法OPT" class="headerlink" title="最佳(优)置换算法OPT"></a>最佳(优)置换算法OPT</h3><p>理论上最理想的页面置换策略是：从主存中移出永远不再需要的页面；如无这样的页面存在，则应选择最长时间不需要访问的页面。</p>
<h3 id="先进先出（FIFO）页面置换算法"><a href="#先进先出（FIFO）页面置换算法" class="headerlink" title="先进先出（FIFO）页面置换算法"></a>先进先出（FIFO）页面置换算法</h3><p>实质是：总是选择作业中驻留时间最长(即最老)的一页淘汰。即：先进入主存的页面先退出主存。</p>
<h3 id="最近最久未使用（LRU）置换算法"><a href="#最近最久未使用（LRU）置换算法" class="headerlink" title="最近最久未使用（LRU）置换算法"></a>最近最久未使用（LRU）置换算法</h3><p>实质是：当需要置换一页面时，选择在最近一段时间内最久不用的页面予以淘汰。<br>特别的LRU需要硬件支持记录每个页面的最近使用情况</p>
<p>另有最少使用置换算法LFU：选择到当前时间为止被访问次数最少的页面被置换</p>
<h3 id="简单Clock置换算法"><a href="#简单Clock置换算法" class="headerlink" title="简单Clock置换算法"></a>简单Clock置换算法</h3><p>此算法为每页设置一位访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列。<br>具体操作：</p>
<ul>
<li>当某页被访问时，其访问位被置1。</li>
<li>置换程序从上次停止位置开始检查页面的访问位。<ul>
<li>如果是0，就选择该页换出；</li>
<li>若为1，则重新将它置0，给该页驻留内存的机会暂不换出。</li>
</ul>
</li>
</ul>
<p>例：<br><img src="/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/1650618210434.png" alt="enter description here"><br><img src="/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/1650618215534.png" alt="enter description here"></p>
<h3 id="改进Clock置换算法"><a href="#改进Clock置换算法" class="headerlink" title="改进Clock置换算法"></a>改进Clock置换算法</h3><p>如果该页面驻留内存期间没有被修改过，那么不必把它写回辅存，否则系统必须把它写回辅存。<br><strong>即相对简单CLOCK添加修改位</strong></p>
<p>由访问位A和修改位M组合四种类型页面：</p>
<ol>
<li>类（A=0，M=0：既未彼访问，又未被修改，是最佳淘汰页。</li>
<li>类（A=0，M=1）：最近未被访问，但已被修改，并不是很好的淘汰页。</li>
<li>类（A=1，M=0）：最近已被访问，但未被修改：该页有可能再被访问。</li>
<li>类（A=1，M=1）：最近已被访问且被修改，该页可能再被访问。</li>
</ol>
<h2 id="缺页率对有效访问时间的影响"><a href="#缺页率对有效访问时间的影响" class="headerlink" title="缺页率对有效访问时间的影响"></a>缺页率对有效访问时间的影响</h2><p>设内存读写周期为t，查找快表时间为λ，缺页中断处理时间为ɛ</p>
<ul>
<li>页面在内存且页表项在快表中,只需一次访问内存<br>  EAT= λ + t</li>
<li>页面在内存但页表项不在快表中,需两次访问内存，一次读取页表，一次读取数据，另外还需更新快表。<br>  EAT= λ + t + t + λ=2(λ + t)</li>
<li>页面不在内存：考虑查找快表时间、查找页表时间、缺页中断处理时间、更新快表时间、访问实际物理地址时间<br>  EAT= λ + t +ɛ + λ + t = ɛ + 2(λ + t)<br>综上：</li>
<li>则<strong>引入快表命中率为α</strong>，<strong>缺页中断率为f</strong>，则有效访问内存时间为<br>  EAT= λ + α t + (1- α)[t + f(t +ɛ +λ) + (1-f)(t +λ)]</li>
</ul>
<h2 id="抖动和工作集"><a href="#抖动和工作集" class="headerlink" title="抖动和工作集"></a>抖动和工作集</h2><p><strong>抖动</strong>：如果运行进程的大部分时间都用于页面的换入/换出，而几乎不能完成任何有效的工作，则称此进程处于抖动状态。<br>抖动产生的原因有：</p>
<ul>
<li>进程分配的物理块太少</li>
<li>置换算法选择不当</li>
<li>全局置换使抖动传播</li>
</ul>
<p>可利用抖动发生前出现的征兆发现抖动并加以防范。<br>这些技术有：</p>
<ul>
<li>采取局部置换策略</li>
<li>引入工作集的算法</li>
<li>L=S准则 - L缺页之间的平均时间，S平均缺页服务时间</li>
<li>选择暂停的进程</li>
</ul>
<h2 id="请求分段存储管理方式"><a href="#请求分段存储管理方式" class="headerlink" title="请求分段存储管理方式"></a>请求分段存储管理方式</h2><p>工作原理：<br>请求分段系统中，程序运行之前，只需先调入若部分分段，便可启动运行。<br>当所访问的段不在内存中时，可请求OS将所缺的段调入内存。<br>硬件支持：</p>
<ul>
<li>请求分段的段表机制。</li>
<li>缺段中断机构。</li>
<li>地址变换机构。</li>
</ul>
<h3 id="段表机制"><a href="#段表机制" class="headerlink" title="段表机制"></a>段表机制</h3><p><img src="/2022/04/20/%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(4)/1650619179190.png" alt="enter description here"></p>
<h3 id="环保护"><a href="#环保护" class="headerlink" title="环保护"></a>环保护</h3><p>环保护的基本原则是：<br>一个程序可以<strong>访问</strong>驻留在相同环或<strong>较低</strong>特权环中的数据<br>一个程序可以<strong>调用</strong>驻留在相同环或<strong>较高</strong>特权环中的服务。</p>
<h1 id="习题4"><a href="#习题4" class="headerlink" title="习题4"></a>习题4</h1><h2 id="P162"><a href="#P162" class="headerlink" title="P162"></a>P162</h2><ol start="2">
<li>可采用哪几种方式将程序装入内存？它们分别适合何种场合</li>
</ol>
<ul>
<li>绝对装入方式，适于单道程序环境</li>
<li>可重定位装入方式，适于多道程序环境，静态存储分配</li>
<li>动态运行时装入方式，适于多道程序环境，动态存储分配</li>
</ul>
<ol start="3">
<li>何谓静态链接？静态链接需要解决两个什么问题</li>
</ol>
<ul>
<li>静态链接：在程序运行之前，先将各目标模块及它们所需的库函数，链接成一个完整的装入模块（又称执行模块），以后不再拆开</li>
<li>需要解决：将相对地址进行修改；变换外部调用符号</li>
</ul>
<ol start="5">
<li>何谓运行时动态链接？运行时动态链接有何优点</li>
</ol>
<ul>
<li>运行时动态链接：将某些目标模块的链接推迟到执行时才进行。</li>
<li>优点：节省内存空间</li>
</ul>
<ol start="6">
<li>在动态分区分配方式中，应如何将各空闲分区链接成空闲分区链</li>
</ol>
<ul>
<li><strong>按照地址递增的顺序链接分区</strong>：首次适应、循环首次适应</li>
<li><strong>按照分区大小顺序链接分区</strong>：最佳适应、最坏适应算法</li>
<li><strong>按分区的大小和分类链接成多条分区链</strong>：快速适应、伙伴系统、哈希算法</li>
</ul>
<ol start="8">
<li><p>什么是基于顺序搜索的动态分区分配算法？分为哪几种<br> 它将空闲分区链接成空闲分区链，以此在分配时搜索链上分区，找到满足算法要求的分区<br> 分为首次适应算法、循环首次适应算法、最佳适应算法、最坏适应算法</p>
</li>
<li><p>在采用首次适应算法回收内存时，可能出现哪几种情况？应怎么处理</p>
</li>
</ol>
<ul>
<li>回收区与<strong>上面</strong>的空闲分区邻接，合并，首地址仍是前一空闲分区的，不必为回收分区分配新表项，只需修改前一分区大小</li>
<li>回收区与<strong>下面</strong>的空白区邻接，合并，重新使用新空闲区首址，修改大小</li>
<li>回收区与<strong>上、下面</strong>的空白区邻接，合并，直接将后面空白区取消，修改大小，首地址仍是前一空闲分区的</li>
<li>回收区与<strong>上、下面</strong>的空白区均不邻接，建立新表项</li>
</ul>
<ol start="13">
<li><p>为什么要引入对换？对换可分为哪几种类型<br>为了提高系统的吞吐量，提高内存的利用率和处理机的利用率；<br>全局对换、局部对换。</p>
</li>
<li><p>为实现对换，系统应具备哪几方面的功能<br>对对换空间的管理<br>进程的换入、换出</p>
</li>
<li><p>基于离散分配时所用的基本单位不同，可将离散分配分为哪几种？<br>分页存储管理方式、分段存储管理方式、段页式存储管理方式</p>
</li>
<li><p>什么是页表？页表的作用是什么？<br>每个进程对应 1 个页表，描述该进程的所需各页面在内存中对应的物理块号。</p>
</li>
<li><p>为实现分页存储管理。需要哪些硬件支持?<br>页表寄存器、物理地址寄存器和快表寄存器。<br>地址变换机构。</p>
</li>
<li><p>在分页系统中是如何实现地址变换的?<br>（1）根据逻辑地址,计算出页号和页内偏移量；<br>（2）从PTR中得到页表首址，然后检索页表，查找指定页面对应的页框号；<br>（3）用页框号乘以页面大小获得其对应的起始地址，并将其送入物理地址的高端。<br>（4）将页内偏移量送入物理地址低端，形成完整的物理地址。</p>
</li>
<li><p>在具有快表的段页式存储管理方式中，如何实现地址变换?<br>根据逻辑地址中的页号，查找快表中是否存在对应的页表项。<br>若快表中存在该表项，称为命中（hit），取出其中的页框号，加上页内偏移量，计算出物理地址。<br>若快表中不存在该页表项，称为命中失败，则再查找页表，找到逻辑地址中指定页号对应的页框号。同时，更新快表，将该表项插入快表中。并计算物理地址</p>
</li>
<li><p>分页和分段存储管理有何区别?<br>页是信息的物理单位，而段是信息的逻辑单位。<br>页的大小固定而且由系统决定，段的大小不固定，通常由编译程序划分。<br>分页用户程序地址空间是一维的，分段用户程序地址空间是二维的。</p>
</li>
<li><p>试全面比较连续分配和离散分配方式。<br><strong>连续分配</strong>程序空间本来就是连续的，用连续的内存装入连续的程序，减少管理工作的难度<br><strong>离散分配</strong>方式需要额外的硬件支持，且实现的算法相对比较复杂<br>没有外零头 不受连续空间限制，每块都能分出去，仅有小于一个页面的内零头 程序大小一般不是页大小的整数倍。</p>
</li>
</ol>
<h2 id="P189"><a href="#P189" class="headerlink" title="P189"></a>P189</h2><ol start="2">
<li><p>什么是程序运行时的时间局限性和空间局限性?</p>
<ul>
<li>时间局限性 被访问过的数据可能再次被访问</li>
<li>空间局限性 被访问过的存储单元其附近也可能被访问</li>
</ul>
</li>
<li><p>实现虚拟存储器需要哪些硬件支持?<br> 请求分页/段的页/段表机制<br> 缺页/段中断机构<br> 地址变换机构</p>
</li>
<li><p>实现虚拟存储器需要哪些关键技术？<br> 请求调页/段功能、页面置换功能</p>
</li>
<li><p>请详细说明请求分页系统的地址变换过程。</p>
<ol>
<li>取逻辑地址分解为页号和页内偏移</li>
<li>根据页号查找页表,获得该页的描述信总</li>
<li>若该页中断位为1，产生缺页中断</li>
<li>更新该页的描述信息</li>
<li>根据页块号和页内偏移，计算物理地址。</li>
</ol>
</li>
<li><p>试说明在请求分页系统中页面的调入过程。<br>当程序要访问的页面未在内存时，便向CPU发出缺页中断，中断处理程序通过查找页表，得到该页在外存的物理块后，如果此时内存能容纳新页，则启动磁盘将所缺之页调入内存，然后修改页表。<br>如果内存已满，则须先按照置换算法从内存中选出一页准备换出，然后再把所缺的页调入内存，并修改页表中的相应表项，并将此页表项写入快表中。<br>在缺页调入内存后，修改后的页表形成所要访问数据的物理地址，再去访问内存数据。<br>整个页面的调入过程对用户是透明的。</p>
</li>
<li><p>在请求分页系统中，常采用哪几种页面置换算法?<br>最佳置换算法OPT<br>先进先出置换算法FIFO<br>最近最久未使用置换算法LRU<br>最少使用置换算法LFU<br>简单的Clock置换算法<br>改进型Clock置换算法</p>
</li>
</ol>
<ol start="18">
<li>在请求分页系统中，产生“抖动”的原因是什么?<ul>
<li>进程分配的物理块太少</li>
<li>置换算法选择不当</li>
<li>全局置换使抖动传播</li>
</ul>
</li>
</ol>

    </div>

    
    
    

 
   <div>
     <div>
    
        <div style="text-align:center;color: #CDBE70;font-size:24px;">---------------THE<i class="fa fa-exclamation-triangle"></i>END---------------</div>
    
</div>
   </div>
 

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/26/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE/fabric%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91%E6%AD%A3%E5%BC%8F%E8%AE%B0%E5%BD%95/" rel="prev" title="fabric区块链开发正式记录">
      <i class="fa fa-chevron-left"></i> fabric区块链开发正式记录
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/05/07/Git/" rel="next" title="Git">
      Git <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">存储器管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">存储器的层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86%E7%9A%84%E7%9B%AE%E7%9A%84%E5%92%8C%E5%8A%9F%E8%83%BD"><span class="nav-number">1.1.1.</span> <span class="nav-text">存储器管理的目的和功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">1.1.2.</span> <span class="nav-text">存储分配的三种方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A3%85%E5%85%A5%E5%92%8C%E9%93%BE%E6%8E%A5"><span class="nav-number">1.2.</span> <span class="nav-text">程序的装入和链接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A3%85%E5%85%A5"><span class="nav-number">1.2.1.</span> <span class="nav-text">程序的装入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5"><span class="nav-number">1.2.2.</span> <span class="nav-text">程序的链接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">1.3.</span> <span class="nav-text">连续分配存储管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="nav-number">1.3.1.</span> <span class="nav-text">分区分配算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95BF"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">最佳适应算法BF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%9D%8F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95WF"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">最坏适应算法WF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95FF"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">首次适应算法FF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95NF"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">循环首次适应算法NF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95QF"><span class="nav-number">1.3.1.5.</span> <span class="nav-text">快速适应算法QF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.3.1.6.</span> <span class="nav-text">伙伴系统</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">1.4.</span> <span class="nav-text">分页存储管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E5%85%A5%E5%88%86%E9%A1%B5"><span class="nav-number">1.4.1.</span> <span class="nav-text">引入分页</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">分页存储管理基本思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">分页存储管理的基本方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E5%92%8C%E7%89%A9%E7%90%86%E5%9D%97"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">页面和物理块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.4.1.4.</span> <span class="nav-text">实现分页存储管理的数据结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="nav-number">1.4.2.</span> <span class="nav-text">地址变换机构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E8%A1%A8"><span class="nav-number">1.4.3.</span> <span class="nav-text">快表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E5%86%85%E5%AD%98%E7%9A%84%E6%9C%89%E6%95%88%E6%97%B6%E9%97%B4-EAT"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">访问内存的有效时间 EAT</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E7%BA%A7%E5%92%8C%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="nav-number">1.4.4.</span> <span class="nav-text">两级和多级页表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E7%BD%AE%E9%A1%B5%E8%A1%A8IPT"><span class="nav-number">1.4.5.</span> <span class="nav-text">反置页表IPT</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E6%8D%A2"><span class="nav-number">1.5.</span> <span class="nav-text">对换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">1.6.</span> <span class="nav-text">分段存储管理方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">1.7.</span> <span class="nav-text">段页式存储管理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">2.</span> <span class="nav-text">虚拟存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="nav-number">2.1.</span> <span class="nav-text">虚拟存储器概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="nav-number">2.1.1.</span> <span class="nav-text">局部性原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">2.1.2.</span> <span class="nav-text">虚拟存储器的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E7%89%B9%E5%BE%81"><span class="nav-number">2.1.3.</span> <span class="nav-text">虚拟存储器的特征</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">2.2.</span> <span class="nav-text">请求分页存储管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="nav-number">2.2.1.</span> <span class="nav-text">内存分配策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%9D%97%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="nav-number">2.2.2.</span> <span class="nav-text">物理块分配算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">2.3.</span> <span class="nav-text">页面置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3-%E4%BC%98-%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95OPT"><span class="nav-number">2.3.1.</span> <span class="nav-text">最佳(优)置换算法OPT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%EF%BC%88FIFO%EF%BC%89%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">2.3.2.</span> <span class="nav-text">先进先出（FIFO）页面置换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%EF%BC%88LRU%EF%BC%89%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">2.3.3.</span> <span class="nav-text">最近最久未使用（LRU）置换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95Clock%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">2.3.4.</span> <span class="nav-text">简单Clock置换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E8%BF%9BClock%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">2.3.5.</span> <span class="nav-text">改进Clock置换算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%BA%E9%A1%B5%E7%8E%87%E5%AF%B9%E6%9C%89%E6%95%88%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-number">2.4.</span> <span class="nav-text">缺页率对有效访问时间的影响</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%96%E5%8A%A8%E5%92%8C%E5%B7%A5%E4%BD%9C%E9%9B%86"><span class="nav-number">2.5.</span> <span class="nav-text">抖动和工作集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">2.6.</span> <span class="nav-text">请求分段存储管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E8%A1%A8%E6%9C%BA%E5%88%B6"><span class="nav-number">2.6.1.</span> <span class="nav-text">段表机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E4%BF%9D%E6%8A%A4"><span class="nav-number">2.6.2.</span> <span class="nav-text">环保护</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%A0%E9%A2%984"><span class="nav-number">3.</span> <span class="nav-text">习题4</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#P162"><span class="nav-number">3.1.</span> <span class="nav-text">P162</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#P189"><span class="nav-number">3.2.</span> <span class="nav-text">P189</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dyinjin"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">dyinjin</p>
  <div class="site-description" itemprop="description">摸鱼窝</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fas fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dyinjin</span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">本博客全站共190.6k字呐~</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,120,50' opacity='0.3' zIndex='-2' count='100' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
<div class="moon-menu">
  <div class="moon-menu-items">
    
    <div id="moon-menu-item-back2bottom" class="moon-menu-item">
      <i class='fas fa-chevron-down'></i>    </div>
    
    <div id="moon-menu-item-back2top" class="moon-menu-item">
      <i class='fas fa-chevron-up'></i>    </div>
    
  </div>
  <div class="moon-menu-button">
    <svg class="moon-menu-bg">
      <circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle>
      <circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle>
    </svg>
    <div class="moon-menu-content">
      <div class="moon-menu-icon"><i class='fas fa-ellipsis-v'></i></div>
      <div class="moon-menu-text"></div>
    </div>
  </div>
</div><script src="/js/injector.js"></script>
</body>
</html>
